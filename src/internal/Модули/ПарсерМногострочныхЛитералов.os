// Модуль для парсинга многострочных литералов YAML (| и > стили)
//

// Проверка, является ли значение многострочным литералом
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если это многострочный литерал
//
Функция ЭтоМногострочныйЛитерал(ЗначениеСтрока) Экспорт
	ЗначениеБезПробелов = СокрЛП(ЗначениеСтрока);
	Возврат ЗначениеБезПробелов = "|" ИЛИ ЗначениеБезПробелов = ">";
КонецФункции

// Чтение многострочного блока
//
// Параметры:
//   Строки - Массив - массив всех строк
//   Индекс - Число - индекс начальной строки
//   ТекущийУровеньОтступа - Число - уровень отступа родительского элемента
//   ТипЛитерала - Строка - тип литерала (| или >)
//
// Возвращаемое значение:
//   Строка - многострочное значение
//
Функция СчитатьМногострочныйБлок(Строки, Индекс, ТекущийУровеньОтступа, ТипЛитерала) Экспорт
	МногострочноеЗначение = "";
	ИндексСтроки = Индекс + 1;
	БазовыйОтступ = ОпределитьБазовыйОтступ(Строки, ИндексСтроки, ТекущийУровеньОтступа);
	
	// Обрабатываем все строки многострочного блока
	Пока ИндексСтроки <= Строки.ВГраница() Цикл
		Строка = Строки[ИндексСтроки];
		
		Если ПустаяСтрока(СокрЛП(Строка)) Тогда
			МногострочноеЗначение = ОбработатьПустуюСтрокуВМногострочномБлоке(МногострочноеЗначение, ТипЛитерала);
		ИначеЕсли ПарсерУровней.ПолучитьУровеньОтступа(Строка) <= ТекущийУровеньОтступа Тогда
			Прервать; // Конец многострочного блока
		Иначе
			СодержимоеСтроки = ИзвлечьСодержимоеСтрокиСБазовымОтступом(Строка, БазовыйОтступ);
			МногострочноеЗначение = ДобавитьСтрокуВМногострочныйБлок(МногострочноеЗначение, СодержимоеСтроки, ТипЛитерала);
		КонецЕсли;
		
		ИндексСтроки = ИндексСтроки + 1;
	КонецЦикла;
	
	// Очищаем завершающие символы
	Возврат ОчиститьЗавершающиеСимволы(МногострочноеЗначение, ТипЛитерала);
КонецФункции

// Определение базового отступа многострочного блока
//
// Параметры:
//   Строки - Массив - массив всех строк
//   НачальныйИндекс - Число - начальный индекс для поиска
//   ТекущийУровеньОтступа - Число - уровень отступа родительского элемента
//
// Возвращаемое значение:
//   Число - базовый отступ в символах
//
Функция ОпределитьБазовыйОтступ(Строки, НачальныйИндекс, ТекущийУровеньОтступа)
	Для ИндексСтроки = НачальныйИндекс По Строки.ВГраница() Цикл
		Строка = Строки[ИндексСтроки];
		
		Если ПустаяСтрока(СокрЛП(Строка)) Тогда
			Продолжить;
		КонецЕсли;

		УровеньОтступаСтроки = ПарсерУровней.ПолучитьУровеньОтступа(Строка);
		Если УровеньОтступаСтроки <= ТекущийУровеньОтступа Тогда
			Прервать;
		КонецЕсли;

		Возврат ПарсерУровней.ПолучитьОтступВСимволах(Строка);
	КонецЦикла;
	
	Возврат 0;
КонецФункции

// Обработка пустой строки в многострочном блоке
//
// Параметры:
//   МногострочноеЗначение - Строка - текущее многострочное значение
//   ТипЛитерала - Строка - тип литерала (| или >)
//
// Возвращаемое значение:
//   Строка - обновленное многострочное значение
//
Функция ОбработатьПустуюСтрокуВМногострочномБлоке(МногострочноеЗначение, ТипЛитерала)
	Если ТипЛитерала = "|" Тогда
		Возврат МногострочноеЗначение + Символы.ПС;
	Иначе
		Возврат МногострочноеЗначение;
	КонецЕсли;
КонецФункции

// Извлечение содержимого строки с учетом базового отступа
//
// Параметры:
//   Строка - Строка - строка для обработки
//   БазовыйОтступ - Число - базовый отступ в символах
//
// Возвращаемое значение:
//   Строка - содержимое строки без базового отступа
//
Функция ИзвлечьСодержимоеСтрокиСБазовымОтступом(Строка, БазовыйОтступ)
	Если БазовыйОтступ <= 0 Тогда
		Возврат СокрЛП(Строка);
	КонецЕсли;

	ТекущийОтступ = ПарсерУровней.ПолучитьОтступВСимволах(Строка);
	Если ТекущийОтступ >= БазовыйОтступ Тогда
		// Убираем базовый отступ
		Возврат Сред(Строка, БазовыйОтступ + 1);
	Иначе
		// Строка имеет меньший отступ чем базовый - возвращаем как есть
		Возврат СокрЛП(Строка);
	КонецЕсли;
КонецФункции

// Добавление строки в многострочный блок
//
// Параметры:
//   МногострочноеЗначение - Строка - текущее многострочное значение
//   СодержимоеСтроки - Строка - содержимое добавляемой строки
//   ТипЛитерала - Строка - тип литерала (| или >)
//
// Возвращаемое значение:
//   Строка - обновленное многострочное значение
//
Функция ДобавитьСтрокуВМногострочныйБлок(МногострочноеЗначение, СодержимоеСтроки, ТипЛитерала)
	Если ПустаяСтрока(МногострочноеЗначение) Тогда
		Возврат СодержимоеСтроки;
	КонецЕсли;
	
	Если ТипЛитерала = "|" Тогда
		Возврат МногострочноеЗначение + Символы.ПС + СодержимоеСтроки;
	ИначеЕсли ТипЛитерала = ">" Тогда
		Возврат МногострочноеЗначение + " " + СодержимоеСтроки;
	Иначе
		Возврат МногострочноеЗначение + СодержимоеСтроки;
	КонецЕсли;
КонецФункции

// Очистка завершающих символов в многострочном значении
//
// Параметры:
//   МногострочноеЗначение - Строка - многострочное значение
//   ТипЛитерала - Строка - тип литерала (| или >)
//
// Возвращаемое значение:
//   Строка - очищенное многострочное значение
//
Функция ОчиститьЗавершающиеСимволы(МногострочноеЗначение, ТипЛитерала)
	Если ТипЛитерала = ">" Тогда
		// Для folded style убираем все завершающие пробелы
		Возврат СокрП(МногострочноеЗначение);
	ИначеЕсли ТипЛитерала = "|" Тогда
		// Для literal style убираем завершающие пробелы и лишние переводы строк
		Результат = МногострочноеЗначение;
		
		// Убираем завершающие пробелы
		Пока СтрДлина(Результат) > 0 И Прав(Результат, 1) = " " Цикл
			Результат = Лев(Результат, СтрДлина(Результат) - 1);
		КонецЦикла;
		
		// Убираем завершающие переводы строк (оставляем только последнюю завершающую строку, если необходимо)
		Пока СтрДлина(Результат) > 0 И Прав(Результат, СтрДлина(Символы.ПС)) = Символы.ПС Цикл
			Результат = Лев(Результат, СтрДлина(Результат) - СтрДлина(Символы.ПС));
		КонецЦикла;
		
		Возврат Результат;
	Иначе
		Возврат МногострочноеЗначение;
	КонецЕсли;
КонецФункции
