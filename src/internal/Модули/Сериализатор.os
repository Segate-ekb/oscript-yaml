// Модуль для сериализации данных в формат YAML

// Основная функция сериализации
//
// Параметры:
//   Значение - Произвольный - данные для сериализации
//   УровеньОтступа - Число - текущий уровень отступа (по умолчанию 0)
//
// Возвращаемое значение:
//   Строка - YAML представление данных
//
Функция Сериализовать(Знач Значение, УровеньОтступа = 0) Экспорт
	
	ТипЗначения = ТипЗнч(Значение);
	Результат = "";
	
	// Если это корневой уровень, добавляем разделитель документа
	Если УровеньОтступа = 0 Тогда
		Результат = "---" + Символы.ПС;
	КонецЕсли;
	
	Если ТипЗначения = Тип("Строка") Тогда
		Результат = Результат + СериализоватьСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Результат = Результат + СериализоватьЧисло(Значение);
	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Результат = Результат + СериализоватьБулево(Значение);
	ИначеЕсли ТипЗначения = Тип("Массив") Тогда
		Результат = Результат + СериализоватьМассив(Значение, УровеньОтступа);
	ИначеЕсли ТипЗначения = Тип("Структура") Или ТипЗначения = Тип("Соответствие") Тогда
		Результат = Результат + СериализоватьОбъект(Значение, УровеньОтступа);
	ИначеЕсли Значение = Неопределено Тогда
		Результат = Результат + "null";
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		// Используем JSON писателя для корректной сериализации дат
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON, Значение);
		Результат = Результат + ЗаписьJSON.Закрыть();
	Иначе
		// Для неизвестных типов пытаемся использовать JSON сериализацию
		Попытка
			ЗаписьJSON = Новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON, Значение);
			Результат = Результат + ЗаписьJSON.Закрыть();
		Исключение
			// Если JSON не справился, используем строковое представление
			Результат = Результат + СериализоватьСтроку(Строка(Значение));
		КонецПопытки;
	КонецЕсли;
	
	// Если это корневой уровень, добавляем разделитель конца документа
	Если УровеньОтступа = 0 Тогда
		Результат = Результат + Символы.ПС + "...";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Сериализация строки
//
// Параметры:
//   Значение - Строка - строка для сериализации
//
// Возвращаемое значение:
//   Строка - YAML представление строки
//
Функция СериализоватьСтроку(Значение)
	
	// Если строка пустая
	Если Значение = "" Тогда
		Возврат """""";
	КонецЕсли;
	
	// Если строка содержит переносы строк, используем блочный стиль
	Если СтрНайти(Значение, Символы.ПС) > 0 ИЛИ СтрНайти(Значение, Символы.ВК) > 0 Тогда
		Возврат СериализоватьМногострочнуюСтроку(Значение);
	КонецЕсли;
	
	// Проверяем, нужно ли заключать в кавычки
	Если ТребуетсяЗаключениеВКавычки(Значение) Тогда
		// Используем JSON писателя для корректного экранирования строки
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON, Значение);
		Возврат ЗаписьJSON.Закрыть();
	Иначе
		Возврат Значение;
	КонецЕсли;
	
КонецФункции

// Сериализация многострочной строки
//
// Параметры:
//   Значение - Строка - многострочная строка для сериализации
//
// Возвращаемое значение:
//   Строка - YAML представление многострочной строки
//
Функция СериализоватьМногострочнуюСтроку(Значение)
	
	// Нормализуем переносы строк
	НормализованноеЗначение = СтрЗаменить(Значение, Символы.ВК, Символы.ПС);
	
	// Разделяем на строки
	Строки = СтрРазделить(НормализованноеЗначение, Символы.ПС, Ложь);
	
	// Используем блочный литеральный стиль |
	Результат = "|" + Символы.ПС;
	
	Для Каждого Строка Из Строки Цикл
		Результат = Результат + "  " + Строка + Символы.ПС;
	КонецЦикла;
	
	// Убираем последний перенос строки
	Результат = Лев(Результат, СтрДлина(Результат) - 1);
	
	Возврат Результат;
	
КонецФункции

// Сериализация числа
//
// Параметры:
//   Значение - Число - число для сериализации
//
// Возвращаемое значение:
//   Строка - YAML представление числа
//
Функция СериализоватьЧисло(Значение)
	Если Значение = 0 Тогда
		Возврат "0";
	Иначе
		Возврат Формат(Значение, "ЧРД=.;ЧГ=");
	КонецЕсли;
КонецФункции

// Сериализация булевого значения
//
// Параметры:
//   Значение - Булево - булевое значение для сериализации
//
// Возвращаемое значение:
//   Строка - YAML представление булевого значения
//
Функция СериализоватьБулево(Значение)
	Если Значение Тогда
		Возврат "true";
	Иначе
		Возврат "false";
	КонецЕсли;
КонецФункции

// Сериализация массива
//
// Параметры:
//   Массив - Массив - массив для сериализации
//   УровеньОтступа - Число - текущий уровень отступа
//
// Возвращаемое значение:
//   Строка - YAML представление массива
//
Функция СериализоватьМассив(Массив, УровеньОтступа = 0)
	
	Если Массив.Количество() = 0 Тогда
		Возврат "[]";
	КонецЕсли;
	
	Результат = "";
	Отступ = ПолучитьОтступ(УровеньОтступа);
	ПервыйЭлемент = Истина;
	
	Для Каждого Элемент Из Массив Цикл
		Если НЕ ПервыйЭлемент Тогда
			Результат = Результат + Символы.ПС;
		КонецЕсли;
		ПервыйЭлемент = Ложь;
		
		ТипЭлемента = ТипЗнч(Элемент);
		
		// Для объектов и массивов используем специальную обработку
		Если ТипЭлемента = Тип("Структура") ИЛИ ТипЭлемента = Тип("Соответствие") ИЛИ ТипЭлемента = Тип("Массив") Тогда
			СериализованныйЭлемент = Сериализовать(Элемент, УровеньОтступа + 1);
			Результат = Результат + ОбработатьМногострочныйЭлементМассива(СериализованныйЭлемент, Отступ, УровеньОтступа);
		Иначе
			// Простые значения (строки, числа, булево)
			СериализованныйЭлемент = Сериализовать(Элемент, УровеньОтступа + 1);
			Результат = Результат + Отступ + "- " + СериализованныйЭлемент;
		КонецЕсли;

	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Обработка многострочного элемента в массиве
//
// Параметры:
//   СериализованныйЭлемент - Строка - сериализованный элемент с переносами строк
//   Отступ - Строка - базовый отступ для массива
//   УровеньОтступа - Число - уровень отступа
//
// Возвращаемое значение:
//   Строка - отформатированный элемент массива
//
Функция ОбработатьМногострочныйЭлементМассива(СериализованныйЭлемент, Отступ, УровеньОтступа)
	
	МассивСтрок = СтрРазделить(СериализованныйЭлемент, Символы.ПС, Ложь);
	ОжидаемыйОтступ = ПолучитьОтступ(УровеньОтступа + 1);
	
	Результат = "";
	Для Инд = 0 По МассивСтрок.Количество() - 1 Цикл
		СтрокаЭлемента = МассивСтрок[Инд];
		
		Если Инд = 0 Тогда
			// Первая строка - убираем ожидаемый отступ и добавляем "- "
			СтрокаБезОтступа = УбратьОжидаемыйОтступ(СтрокаЭлемента, ОжидаемыйОтступ);
			Результат = Результат + Отступ + "- " + СтрокаБезОтступа;
		Иначе
			// Остальные строки - заменяем ожидаемый отступ на отступ массива + 2 пробела
			ОстатокСтроки = УбратьОжидаемыйОтступ(СтрокаЭлемента, ОжидаемыйОтступ);
			Результат = Результат + Символы.ПС + Отступ + "  " + ОстатокСтроки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Убрать ожидаемый отступ из строки
//
// Параметры:
//   СтрокаЭлемента - Строка - исходная строка
//   ОжидаемыйОтступ - Строка - ожидаемый отступ для удаления
//
// Возвращаемое значение:
//   Строка - строка без ожидаемого отступа
//
Функция УбратьОжидаемыйОтступ(СтрокаЭлемента, ОжидаемыйОтступ)
	
	Если СтрНачинаетсяС(СтрокаЭлемента, ОжидаемыйОтступ) Тогда
		Возврат Сред(СтрокаЭлемента, СтрДлина(ОжидаемыйОтступ) + 1);
	Иначе
		Возврат СокрЛП(СтрокаЭлемента);
	КонецЕсли;
	
КонецФункции

// Сериализация объекта
//
// Параметры:
//   Объект - Соответствие, Структура - соответствие для сериализации
//   УровеньОтступа - Число - текущий уровень отступа
//
// Возвращаемое значение:
//   Строка - YAML представление соответствия
//
Функция СериализоватьОбъект(Объект, УровеньОтступа = 0)
	
	Если Объект.Количество() = 0 Тогда
		Возврат "{}";
	КонецЕсли;
	
	Результат = "";
	Отступ = ПолучитьОтступ(УровеньОтступа);
	ПервыйЭлемент = Истина;
	
	Для Каждого КлючЗначение Из Объект Цикл
		Если НЕ ПервыйЭлемент Тогда
			Результат = Результат + Символы.ПС;
		КонецЕсли;
		ПервыйЭлемент = Ложь;
		
		Ключ = КлючЗначение.Ключ;
		Значение = КлючЗначение.Значение;
		
		СериализованныйКлюч = СериализоватьКлюч(Ключ);
		СериализованноеЗначение = Сериализовать(Значение, УровеньОтступа + 1);
		
		// Если значение содержит переносы строк (массив или сложный объект),
		// то нужно размещать его на новой строке с правильными отступами
		Если СтрНайти(СериализованноеЗначение, Символы.ПС) > 0 Тогда
			// Сложное значение - размещаем на новой строке
			// Но для многострочных строк с | добавляем пробел
			Если СтрНачинаетсяС(СериализованноеЗначение, "|") Тогда
				Результат = Результат + Отступ + СериализованныйКлюч + ": " + СериализованноеЗначение;
			Иначе
				// Для массивов и объектов - значение начинается с новой строки
				Результат = Результат + Отступ + СериализованныйКлюч + ":" + Символы.ПС + СериализованноеЗначение;
			КонецЕсли;
		Иначе
			// Простое значение - размещаем на той же строке
			Результат = Результат + Отступ + СериализованныйКлюч + ": " + СериализованноеЗначение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Сериализация ключа
//
// Параметры:
//   Ключ - Произвольный - ключ для сериализации
//
// Возвращаемое значение:
//   Строка - YAML представление ключа
//
Функция СериализоватьКлюч(Ключ)
	
	ТипКлюча = ТипЗнч(Ключ);
	
	Если ТипКлюча = Тип("Строка") Тогда
		// Для ключей применяем те же правила, что и для строк
		Возврат СериализоватьСтроку(Ключ);
	ИначеЕсли ТипКлюча = Тип("Число") Тогда
		Возврат СериализоватьЧисло(Ключ);
	ИначеЕсли ТипКлюча = Тип("Булево") Тогда
		Возврат СериализоватьБулево(Ключ);
	Иначе
		// Для других типов преобразуем в строку
		Возврат СериализоватьСтроку(Строка(Ключ));
	КонецЕсли;
	
КонецФункции

// Получение строки отступа
//
// Параметры:
//   УровеньОтступа - Число - уровень отступа
//
// Возвращаемое значение:
//   Строка - строка с соответствующим количеством пробелов
//
Функция ПолучитьОтступ(УровеньОтступа)
	
	Если УровеньОтступа <= 0 Тогда
		Возврат "";
	КонецЕсли;
	
	// Используем 2 пробела на каждый уровень отступа
	КоличествоПробелов = УровеньОтступа * 2;
	
	Результат = "";
	Пока СтрДлина(Результат) < КоличествоПробелов Цикл
		Результат = Результат + " ";
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверка, является ли строка числом
//
// Параметры:
//   Значение - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если строка представляет число
//
Функция ЭтоЧисло(Значение)
	
	Если Значение = "" Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Убираем пробелы по краям
	ОчищенноеЗначение = СокрЛП(Значение);
	
	// Проверяем регулярным выражением на простое число
	Если СтрДлина(ОчищенноеЗначение) = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Простая проверка: число может содержать цифры, знак в начале и одну точку
	РазрешенныеСимволы = "0123456789.-+";
	КоличествоТочек = 0;
	КоличествоЗнаков = 0;
	
	Для Позиция = 1 По СтрДлина(ОчищенноеЗначение) Цикл
		Символ = Сред(ОчищенноеЗначение, Позиция, 1);
		
		Если СтрНайти(РазрешенныеСимволы, Символ) = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Символ = "." Тогда
			КоличествоТочек = КоличествоТочек + 1;
		КонецЕсли;
		
		Если Символ = "-" ИЛИ Символ = "+" Тогда
			КоличествоЗнаков = КоличествоЗнаков + 1;
			// Знак может быть только в начале
			Если Позиция > 1 Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Не может быть больше одной точки или одного знака
	Возврат КоличествоТочек <= 1 И КоличествоЗнаков <= 1;
	
КонецФункции

// Проверка, требуется ли заключение строки в кавычки
//
// Параметры:
//   Значение - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если строку нужно заключить в кавычки
//
Функция ТребуетсяЗаключениеВКавычки(Значение)
	
	// Пустая строка должна быть в кавычках
	Если Значение = "" Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Строки, которые могут интерпретироваться как специальные значения YAML
	// НО только если они точно совпадают
	СпециальныеЗначения = Новый Массив;
	СпециальныеЗначения.Добавить("true");
	СпециальныеЗначения.Добавить("false");
	СпециальныеЗначения.Добавить("null");
	СпециальныеЗначения.Добавить("~");
	СпециальныеЗначения.Добавить("yes");
	СпециальныеЗначения.Добавить("no");
	СпециальныеЗначения.Добавить("on");
	СпециальныеЗначения.Добавить("off");
	
	НижнийРегистр = НРег(СокрЛП(Значение));
	Для Каждого СпециальноеЗначение Из СпециальныеЗначения Цикл
		Если НижнийРегистр = СпециальноеЗначение Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	// Проверяем, является ли строка числом
	Если ЭтоЧисло(Значение) Тогда
		Возврат Истина; // Если это число, заключаем в кавычки
	КонецЕсли;
	
	// Проверяем специальные символы YAML
	СпециальныеСимволы = ":#@`|>{}[]!%&*";
	Для Инд = 1 По СтрДлина(СпециальныеСимволы) Цикл
		Символ = Сред(СпециальныеСимволы, Инд, 1);
		Если СтрНайти(Значение, Символ) > 0 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	// Проверяем, начинается ли с пробела или заканчивается пробелом
	Если Лев(Значение, 1) = " " ИЛИ Прав(Значение, 1) = " " Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Проверяем на наличие переносов строк, табов и кавычек
	Если СтрНайти(Значение, Символы.ПС) > 0 ИЛИ СтрНайти(Значение, Символы.ВК) > 0 
		ИЛИ СтрНайти(Значение, Символы.ВТаб) > 0 ИЛИ СтрНайти(Значение, """") > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции
