////////////////////////////////////////////////////////////////////////////////
// Модуль для десериализации YAML документов
// 
// Поддерживает парсинг различных типов YAML структур:
// - Объекты (соответствия)
// - Массивы 
// - Скалярные значения
// - Многострочные строки
// - Flow-синтаксис (объекты и массивы)
// - Якоря и алиасы
////////////////////////////////////////////////////////////////////////////////

#Использовать logos

Перем лог;

////////////////////////////////////////////////////////////////////////////////
// ФАБРИКА СТРУКТУР
////////////////////////////////////////////////////////////////////////////////

// Константы YAML символов
Перем YAML_РАЗДЕЛИТЕЛЬ_ДОКУМЕНТА;
Перем YAML_ТЕРМИНАТОР_ДОКУМЕНТА;

// Создает структуру результата обработки документа
//
// Параметры:
//   Документ - Массив - документ для возврата
//
// Возвращаемое значение:
//   Структура - структура с полем Документ
//
Функция СоздатьРезультатОбработкиДокумента(Документ)
    Возврат Новый Структура("Документ", Документ);
КонецФункции

// Создает структуру для управляющего символа и его позиции
//
// Параметры:
//   Символ - Строка - найденный символ
//   Позиция - Число - позиция символа
//
// Возвращаемое значение:
//   Структура - структура с полями Символ и Позиция
//
Функция СоздатьСтруктуруУправляющегоСимвола(Символ = "", Позиция = 0)
    Возврат Новый Структура("Символ, Позиция", Символ, Позиция);
КонецФункции

// Создает структуру результата обработки сущности
//
// Параметры:
//   Сущность - Структура - обработанная сущность
//   НовыйИндекс - Число - новый индекс для продолжения обработки
//
// Возвращаемое значение:
//   Структура - структура с полями Сущность и НовыйИндекс
//
Функция СоздатьРезультатОбработкиСущности(Сущность, НовыйИндекс)
    Возврат Новый Структура("Сущность, НовыйИндекс", Сущность, НовыйИндекс);
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПУБЛИЧНЫЕ МЕТОДЫ
////////////////////////////////////////////////////////////////////////////////

// Основная функция для десериализации YAML
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для парсинга
//
// Возвращаемое значение:
//   Массив - массив распарсенных документов YAML
//
// Исключения:
//   При некорректном синтаксисе YAML
//
Функция Прочитать(СтрокаYaml) Экспорт
    Лог.Отладка("Начало десериализации YAML");
    Если ПустаяСтрока(СтрокаYaml) Тогда
        Лог.Отладка("Входная строка YAML пуста, возвращаем пустое соответствие");
        Возврат Новый Соответствие();
    КонецЕсли;
    
    Лог.Отладка("Инициализация менеджера якорей");
    МенеджерЯкорей.Инициализировать();
    
    // Разбиваем на строки
    Строки = СтрРазделить(СтрокаYaml, Символы.ПС);
    Лог.Отладка("Строка YAML разбита на " + Строки.Количество() + " строк");
    
    МассивДокументов = Новый Массив();
    МассивСтрокДокументов = РазбитьНаДокументы(Строки);
    Лог.Отладка("Найдено " + МассивСтрокДокументов.Количество() + " документов YAML");
    
    Для каждого СтрокиДокумента Из МассивСтрокДокументов Цикл
        Лог.Отладка("Обработка документа с " + СтрокиДокумента.Количество() + " строками");
        МассивДокументов.Добавить(ДанныеИзМассиваСтрок(СтрокиДокумента));
    КонецЦикла;
    
    Лог.Отладка("Десериализация YAML завершена успешно");
    Возврат МассивДокументов;
    
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МЕТОДЫ РАБОТЫ С ДОКУМЕНТАМИ
////////////////////////////////////////////////////////////////////////////////

// Разбивает массив строк на отдельные YAML документы
//
// Параметры:
//   МассивСтрок - Массив - массив строк исходного YAML
//
// Возвращаемое значение:
//   Массив - массив документов, каждый документ представлен массивом строк
//
Функция РазбитьНаДокументы(МассивСтрок)
    Лог.Отладка("Начало разбиения на документы");
    МассивСтрокДокументов = Новый Массив();
    Документ = Новый Массив();
    
    Для Каждого Строка Из МассивСтрок Цикл
        Результат = ОбработатьСтрокуДокумента(Строка, Документ, МассивСтрокДокументов);
        Документ = Результат.Документ;
    КонецЦикла;
    
    Если Не Документ = Неопределено и Документ.Количество() > 0 Тогда
        МассивСтрокДокументов.Добавить(Документ);
    КонецЕсли;
    
    Лог.Отладка("Разбиение на документы завершено, найдено " + МассивСтрокДокументов.Количество() + " документов");
    Возврат МассивСтрокДокументов;
КонецФункции

// Обрабатывает одну строку документа
//
// Параметры:
//   Строка - Строка - обрабатываемая строка
//   Документ - Массив - текущий документ
//   МассивСтрокДокументов - Массив - массив всех документов
//
// Возвращаемое значение:
//   Структура - результат обработки с полем Документ
//
Функция ОбработатьСтрокуДокумента(Строка, Документ, МассивСтрокДокументов)
    
    Если СтрНачинаетсяС(СокрЛП(Строка), YAML_РАЗДЕЛИТЕЛЬ_ДОКУМЕНТА) Тогда
        Лог.Отладка("Найден разделитель документа " + YAML_РАЗДЕЛИТЕЛЬ_ДОКУМЕНТА);
        Документ = ОбработатьРазделительДокумента(Строка, Документ, МассивСтрокДокументов);
    ИначеЕсли СтрНачинаетсяС(СокрЛП(Строка), YAML_ТЕРМИНАТОР_ДОКУМЕНТА) Тогда
        Лог.Отладка("Найден терминатор документа " + YAML_ТЕРМИНАТОР_ДОКУМЕНТА);
        Документ = ОбработатьТерминаторДокумента(Документ, МассивСтрокДокументов);
    Иначе
        Документ = ОбработатьОбычнуюСтроку(Строка, Документ);
    КонецЕсли;
    
    Результат = СоздатьРезультатОбработкиДокумента(Документ);
    Возврат Результат;
    
КонецФункции

// Обрабатывает разделитель документа ---
//
// Параметры:
//   Строка - Строка - строка с разделителем
//   Документ - Массив - текущий документ
//   МассивСтрокДокументов - Массив - массив всех документов
//
// Возвращаемое значение:
//   Массив - новый документ
//
Функция ОбработатьРазделительДокумента(Строка, Документ, МассивСтрокДокументов)
    
    // Конец документа, сохраняем текущий и начинаем новый
    Если Документ <> Неопределено И Документ.Количество() > 0 Тогда
        МассивСтрокДокументов.Добавить(Документ);
    КонецЕсли;
    
    Документ = Новый Массив();
    Строка = СтрЗаменить(Строка, YAML_РАЗДЕЛИТЕЛЬ_ДОКУМЕНТА, "");
    Если Не ПустаяСтрока(СокрЛП(Строка)) Тогда
        Документ.Добавить(Строка);
    КонецЕсли;
    
    Возврат Документ;
    
КонецФункции

// Обрабатывает терминатор документа ...
//
// Параметры:
//   Документ - Массив - текущий документ
//   МассивСтрокДокументов - Массив - массив всех документов
//
// Возвращаемое значение:
//   Массив - новый документ (Неопределено если вне документа)
//
Функция ОбработатьТерминаторДокумента(Документ, МассивСтрокДокументов)
    
    // Конец текущего документа
    Если Документ <> Неопределено И Документ.Количество() > 0 Тогда
        МассивСтрокДокументов.Добавить(Документ);
    КонецЕсли;
    Документ = Неопределено; // Переходим в состояние вне документа
    
    Возврат Документ;
    
КонецФункции

// Обрабатывает обычную строку
//
// Параметры:
//   Строка - Строка - обрабатываемая строка
//   Документ - Массив - текущий документ
//
// Возвращаемое значение:
//   Массив - документ с добавленной строкой
//
Функция ОбработатьОбычнуюСтроку(Строка, Документ)
    
    Если Документ = Неопределено Тогда
        Если СокрЛП(Строка) = "" Тогда
            Возврат Документ; // мы вне документа, может там после и есть что-то, но эти строки нам не нужны
        КонецЕсли;
        
        // Проверяем, является ли строка YAML-директивой
        СтрокаБезПробелов = СокрЛП(Строка);
        Если СтрНачинаетсяС(СтрокаБезПробелов, "%YAML") 
             ИЛИ СтрНачинаетсяС(СтрокаБезПробелов, "%TAG") Тогда
            // Директивы YAML игнорируем вне документа
            Возврат Документ;
        КонецЕсли;
        
        Лог.Ошибка("Найдено содержимое вне документа YAML: " + Строка);
        ВызватьИсключение "Найдено содержимое вне документа YAML: " + Строка;
    КонецЕсли;   

    Документ.Добавить(Строка);
    
    Возврат Документ;
    
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МЕТОДЫ РАБОТЫ СО СТРОКАМИ И КОММЕНТАРИЯМИ
////////////////////////////////////////////////////////////////////////////////

// Очистка строк от комментариев и пустых строк
//
// Параметры:
//   Строки - Массив - массив строк для очистки
//
// Возвращаемое значение:
//   Массив - очищенный массив строк
//
Функция ОчиститьСтроки(Строки)
    
    ОчищенныеСтроки = Новый Массив();
    
    Для Каждого Строка Из Строки Цикл
        ОчищеннаяСтрока = СокрЛП(Строка);
        
        ОчищенныеСтроки.Добавить(УбратьКомментарийИзСтроки(ОчищеннаяСтрока));
    КонецЦикла;
    
    Возврат ОчищенныеСтроки;
    
КонецФункции

// Проверка, является ли строка пустой или комментарием
// Параметры:
//   Строка - Строка - строка для проверки
// Возвращаемое значение:
//   Булево - Истина, если строка пустая или комментарий
//
Функция ЭтоПустаяСтрокаИлиКомментарий(Знач Строка)
    Если (Не СтрНайти(Строка, Символы.Таб) И СокрЛП(Строка) = "") ИЛИ Лев(СокрЛП(Строка), 1) = "#" Тогда
        Возврат Истина;
    КонецЕсли;
    
    Возврат Ложь;
КонецФункции

// Убирает комментарий из строки, если она на него заканчивается
// Параметры:
//   Строка - Строка - строка для очистки
// Возвращаемое значение:
//   Строка - очищенная строка без комментариев
//
Функция УбратьКомментарийИзСтроки(Знач Строка)
    // Ищем позицию комментария неэкранированного символа #,
    // т.е. пропускаем символы в кавычках и тд.
    
    ПозицияКомментария = ПозицияНеЭкранированногоСимвола(Строка, "#");
    
    Если ПозицияКомментария = 0 Тогда
        Возврат Строка;
    КонецЕсли;  

    Возврат Лев(Строка, ПозицияКомментария - 1);
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МЕТОДЫ ОПРЕДЕЛЕНИЯ ТИПОВ ДАННЫХ
////////////////////////////////////////////////////////////////////////////////

// Определение типа содержимого строки
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Строка - тип содержимого: "Объект", "Массив", "FlowПоследовательность", "FlowОбъект", "МногострочнаяСтрока", Неопределено
//
Функция ОпределитьТипСодержимого(Строки)
    Лог.Отладка("Определение типа содержимого для " + Строки.Количество() + " строк");
    
    Для Каждого Строка Из Строки Цикл
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Продолжить;
        КонецЕсли;
        // Если это не пустая строка, то управляющий символ должен быть в ней.
        // Если мы не нашли его, то это Строка или число, или что-то другое.
        ТипДанных = НайтиТипДанныхПоСтроке(Строка);
        Лог.Отладка("Определен тип содержимого: " + ТипДанных + " по строке: " + Строка);
        Возврат ТипДанных;
    КонецЦикла;
    
    Лог.Предупреждение("Не найдено ни одной строки с данными");
    Возврат Неопределено; // Если не найдено ни одной строки с данными - возвращаем неопределено.
    
КонецФункции

// Определяет тип данных по строке
// Параметры:
//   Строка - Строка - строка для анализа
// Возвращаемое значение:
//   Строка - тип данных: "Объект", "Массив", "FlowПоследовательность", "FlowОбъект", "МногострочнаяСтрока"
Функция НайтиТипДанныхПоСтроке(Знач Строка)
    ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
    
    Если ДанныеУправляющегоСимвола.Позиция = 0 Тогда
        Лог.Отладка("Управляющий символ не найден, определен как скаляр");
        Возврат "Скаляр";
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "[" Тогда
        Лог.Отладка("Найден символ flow последовательности: [");
        Возврат "FlowПоследовательность";
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "{" Тогда
        Лог.Отладка("Найден символ flow объекта: {");
        Возврат "FlowОбъект";
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = ":" Тогда
        Лог.Отладка("Найден символ объекта: :");
        Возврат "Объект";
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "-" Тогда
        Лог.Отладка("Найден символ массива: -");
        Возврат "Массив"; // Массив начинается с тире и пробела
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "|" ИЛИ ДанныеУправляющегоСимвола.Символ = ">" Тогда
        Лог.Отладка("Найден символ многострочной строки: " + ДанныеУправляющегоСимвола.Символ);
        Возврат "МногострочнаяСтрока"; // Многострочная строка начинается с | или >
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "&" Тогда
        Лог.Отладка("Найден символ якоря: &");
        Возврат "Якорь"; // Якорь начинается с &
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "*" Тогда
        Лог.Отладка("Найден символ алиаса: *");
        Возврат "Алиас";      
    Иначе
        // Если не найдено ни одного управляющего символа, то это может быть строка или число
        Лог.Ошибка("Не удалось определить тип данных в строке: " + Строка);
        ВызватьИсключение "Не удалось определить тип данных в строке: " + Строка;
    КонецЕсли;
    
КонецФункции

Функция НайтиУправляющийСимволИЕгоПозицию(Знач Строка)

    СтруктураВозврата = СоздатьСтруктуруУправляющегоСимвола();
    
    МассивУправляющихСимволов = Новый Массив;
    МассивУправляющихСимволов.Добавить(":"); // Двоеточие для объектов
    МассивУправляющихСимволов.Добавить("-"); // Тире для массивов
    МассивУправляющихСимволов.Добавить("|"); // Вертикальная черта для многострочных строк
    МассивУправляющихСимволов.Добавить(">"); // Знак больше для многострочных строк
    МассивУправляющихСимволов.Добавить("&"); // Символ для определения якоря
    МассивУправляющихСимволов.Добавить("*"); // Символ для алиасов
    МассивУправляющихСимволов.Добавить("{"); // Открывающая фигурная скобка для объектов
    МассивУправляющихСимволов.Добавить("["); // Открывающая квадратная скобка для массивов

    МинимальнаяНайденнаяПозиция = 9999999;
    Для каждого Символ Из МассивУправляющихСимволов Цикл
        НайденнаяПозиция = ПозицияНеЭкранированногоСимвола(Строка, Символ);
        Если НайденнаяПозиция > 0 И МинимальнаяНайденнаяПозиция > НайденнаяПозиция Тогда
            СтруктураВозврата.Символ = Символ;
            СтруктураВозврата.Позиция = НайденнаяПозиция;
            МинимальнаяНайденнаяПозиция = НайденнаяПозиция;
        КонецЕсли;
    КонецЦикла;
    
    Возврат СтруктураВозврата;
КонецФункции

// Обрабатывает открытие кавычек
//
// Параметры:
//   Символ - Строка - текущий символ
//   ВКавычках - Булево - флаг нахождения в кавычках (изменяется)
//   ТипКавычек - Строка - тип кавычек (изменяется)
//
// Возвращаемое значение:
//   Булево - Истина, если символ обработан как открывающая кавычка
//
Функция ОбработатьОткрытиеКавычек(Символ, ВКавычках, ТипКавычек)
    Если (Символ = """" ИЛИ Символ = "'") И НЕ ВКавычках Тогда
        ВКавычках = Истина;
        ТипКавычек = Символ;
        Возврат Истина;
    КонецЕсли;
    Возврат Ложь;
КонецФункции

// Обрабатывает закрытие кавычек с учетом экранирования
//
// Параметры:
//   Строка - Строка - исходная строка
//   Позиция - Число - текущая позиция
//   Символ - Строка - текущий символ
//   ВКавычках - Булево - флаг нахождения в кавычках (изменяется)
//   ТипКавычек - Строка - тип кавычек (изменяется)
//
// Возвращаемое значение:
//   Булево - Истина, если символ обработан как закрывающая кавычка
//
Функция ОбработатьЗакрытиеКавычек(Строка, Позиция, Символ, ВКавычках, ТипКавычек)
    Если НЕ (ВКавычках И Символ = ТипКавычек) Тогда
        Возврат Ложь;
    КонецЕсли;
    
    // Проверяем, не является ли кавычка экранированной
    КоличествоЭкранирований = 0;
    ПредыдущаяПозиция = Позиция - 1;
    Пока ПредыдущаяПозиция >= 1 И Сред(Строка, ПредыдущаяПозиция, 1) = "\" Цикл
        КоличествоЭкранирований = КоличествоЭкранирований + 1;
        ПредыдущаяПозиция = ПредыдущаяПозиция - 1;
    КонецЦикла;
    
    // Если количество слешей четное, то кавычка не экранирована
    Если КоличествоЭкранирований % 2 = 0 Тогда
        ВКавычках = Ложь;
        ТипКавычек = "";
    КонецЕсли;
    
    Возврат Истина;
КонецФункции

Функция ПозицияНеЭкранированногоСимвола(Строка, ИскомыйСимвол, ЭтоFlowСтиль = Ложь)
    НайденнаяПозиция = 0;
    ВКавычках = Ложь;
    ТипКавычек = "";
    
    Для Позиция = 1 По СтрДлина(Строка) Цикл
        Символ = Сред(Строка, Позиция, 1);
        
        // Обработка открытия кавычек
        Если ОбработатьОткрытиеКавычек(Символ, ВКавычках, ТипКавычек) Тогда
            Продолжить;
        КонецЕсли;
        
        // Обработка закрытия кавычек
        Если ОбработатьЗакрытиеКавычек(Строка, Позиция, Символ, ВКавычках, ТипКавычек) Тогда
            Продолжить;
        КонецЕсли;
        
        // Поиск символа (не в кавычках и с пробелом после)
        Если НЕ ВКавычках И Символ = ИскомыйСимвол Тогда
            Если ЭтоЗначащийСимвол(Строка, Позиция, ИскомыйСимвол, ЭтоFlowСтиль) Тогда
                НайденнаяПозиция = Позиция;
                Прервать;
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат НайденнаяПозиция;
КонецФункции

// Проверяет, является ли Символ Значащим
// (должно быть в конце строки или с пробелом/табом после него)
//
// Параметры:
//   Строка - Строка - строка для анализа
//   Позиция - Число - позиция Символа в строке
//   ИскомыйСимвол - Строка - символ, который мы ищем
//   ЭтоFlowСтиль - Булево - флаг обработки в flow-стиле (по умолчанию Ложь)
//
// Возвращаемое значение:
//   Булево - Истина, если Символ является разделителем ключ-значение
//
Функция ЭтоЗначащийСимвол(Строка, Позиция, ИскомыйСимвол, ЭтоFlowСтиль = Ложь)

    Если ИскомыйСимвол = "#" Тогда

        Возврат Истина;
       
    КонецЕсли;
    
    // Для двоеточия в flow стиле особая обработка
    Если ИскомыйСимвол = ":" И ЭтоFlowСтиль Тогда
        // В flow стиле двоеточие должно быть разделителем ключ-значение
        // Не должно быть в начале строки как первый символ
        Если Позиция = 1 Тогда
            Возврат Ложь; // Двоеточие в начале не является разделителем
        КонецЕсли;
        
        Возврат Истина;
    КонецЕсли;
     
    ЭтоМногострочнаяСтрока = ИскомыйСимвол = "|" ИЛИ ИскомыйСимвол = ">";
    ЭтоЯкорьИлиАлиас = ИскомыйСимвол = "&" Или ИскомыйСимвол = "*";
    ЭтоНачалоFlowПоследовательности = ИскомыйСимвол = "{" Или ИскомыйСимвол = "[";
    
    Если ЭтоНачалоFlowПоследовательности Тогда
        // Для flow стиля проверяем, что символ находится в начале строки (после отступа)
        Возврат СтрНачинаетсяС(СокрЛП(Строка), ИскомыйСимвол);
    КонецЕсли;
    
    Если ЭтоЯкорьИлиАлиас Тогда
        Имя = МенеджерЯкорей.ИзвлечьИмяЯкоряИлиАлиаса(Строка);
        Возврат Не Имя = "";
    КонецЕсли;    
    Если Позиция = СтрДлина(Строка) Тогда
        Возврат Истина; 
    КонецЕсли;
    
    МассивДопустимыхСимволов = Новый Массив();
    МассивДопустимыхСимволов.Добавить(" "); // Пробел
    МассивДопустимыхСимволов.Добавить(Символы.Таб); // Табуляция
    Если ЭтоМногострочнаяСтрока Тогда
        МассивДопустимыхСимволов.Добавить("-");
        МассивДопустимыхСимволов.Добавить("+");
    КонецЕсли;
    
    СледующийСимвол = Сред(Строка, Позиция + 1, 1);
        
    ЭтоЗначащийСимвол = НЕ МассивДопустимыхСимволов.Найти(СледующийСимвол) = Неопределено;
    Возврат ЭтоЗначащийСимвол;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ОСНОВНЫЕ ПАРСЕРЫ ТИПОВ ДАННЫХ
////////////////////////////////////////////////////////////////////////////////

// Получает данные из массива строк
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Произвольный - результат парсинга
//
Функция ДанныеИзМассиваСтрок(Строки) 
    ТипСодержимого = ОпределитьТипСодержимого(Строки);
    Лог.Отладка("Обработка данных типа: " + ТипСодержимого);
    
    Если ТипСодержимого = "Объект" Тогда
        Возврат ПарсерОбъектов(Строки);
    ИначеЕсли ТипСодержимого = "Массив" Тогда
        Возврат ПарсерМассивов(Строки);
    ИначеЕсли ТипСодержимого = "FlowПоследовательность" Тогда
        Возврат ПарсерFlowПоследовательности(Строки);
    ИначеЕсли ТипСодержимого = "FlowОбъект" Тогда
        Возврат ПарсерFlowОбъекта(Строки);
    ИначеЕсли ТипСодержимого = "МногострочнаяСтрока" Тогда
        Возврат ПарсерМногострочныхСтрок(Строки);
    ИначеЕсли ТипСодержимого = "Якорь" Тогда
        Возврат ПарсерЯкорей(Строки);
    ИначеЕсли ТипСодержимого = "Алиас" Тогда
        Возврат ПарсерАлиасов(Строки);
    ИначеЕсли ТипСодержимого = "Скаляр" Тогда
        Лог.Отладка("Обработка скалярного значения");
        ОчищенныеСтроки = ОчиститьСтроки(Строки);
        ИтоговаяСтрока = СокрЛП(СтрЗаменить(СтрСоединить(ОчищенныеСтроки, " "), "  ", Символы.ПС));
        
        // Безопасная проверка на число без использования исключений
        Если ЭтоЧисло(ИтоговаяСтрока) Тогда
            Результат = Число(ИтоговаяСтрока);
            Лог.Отладка("Скаляр преобразован в число: " + Результат);
            Возврат Результат;
        КонецЕсли;
        
        ИтоговаяСтрока = УбратьКавычки(ИтоговаяСтрока);
        Лог.Отладка("Скаляр обработан как строка: " + ИтоговаяСтрока);
        Возврат ИтоговаяСтрока;
    Иначе
        Лог.Предупреждение("Неопределенный тип содержимого, возвращаем Неопределено");
        Возврат Неопределено; // Если не определено, то возвращаем неопределено
    КонецЕсли;
    
КонецФункции

Функция УбратьКавычки(Строка)
    // Убираем кавычки из строки, если они есть
    Если (СтрНачинаетсяС(Строка, """") И СтрЗаканчиваетсяНа(Строка, """")) 
        Или (СтрНачинаетсяС(Строка, "'") И СтрЗаканчиваетсяНа(Строка, "'")) Тогда
        Результат = Сред(Строка, 2, СтрДлина(Строка) - 2);
        
        // Обрабатываем экранированные символы в двойных кавычках
        Если СтрНачинаетсяС(Строка, """") Тогда
            // Заменяем экранированные символы
            Результат = СтрЗаменить(Результат, "\""", """");
            Результат = СтрЗаменить(Результат, "\\", "\");
            Результат = СтрЗаменить(Результат, "\n", Символы.ПС);
            Результат = СтрЗаменить(Результат, "\t", Символы.Таб);
            Результат = СтрЗаменить(Результат, "\r", Символы.ВК);
        КонецЕсли;
        
        Возврат Результат;
    КонецЕсли;
    
    Возврат Строка; // Если кавычек нет, возвращаем строку как есть
    
КонецФункции

// Проверяет, является ли строка числом
// Параметры:
//   Строка - Строка - строка для проверки
// Возвращаемое значение:
//   Булево - Истина, если строка является числом
//
Функция ЭтоЧисло(Знач Строка)
    
    Если ПустаяСтрока(Строка) Тогда
        Возврат Ложь;
    КонецЕсли;
    
    // Убираем пробелы в начале и конце
    Строка = СокрЛП(Строка);
    
    // Проверяем на специальные значения
    Если ВРег(Строка) = "TRUE" Или ВРег(Строка) = "FALSE" Или ВРег(Строка) = "NULL" Тогда
        Возврат Ложь;
    КонецЕсли;
    
    // Проверяем регулярным выражением на соответствие числу
    // Простая проверка: может начинаться с + или -, далее цифры, возможно с точкой и экспонентой
    Для Позиция = 1 По СтрДлина(Строка) Цикл
        Символ = Сред(Строка, Позиция, 1);
        Если Позиция = 1 И (Символ = "+" Или Символ = "-") Тогда
            Продолжить; // Знак в начале допустим
        ИначеЕсли Символ >= "0" И Символ <= "9" Тогда
            Продолжить; // Цифра допустима
        ИначеЕсли Символ = "." Тогда
            Продолжить; // Десятичная точка допустима
        ИначеЕсли ВРег(Символ) = "E" Тогда
            Продолжить; // Экспонента допустима
        Иначе
            Возврат Ложь; // Недопустимый символ
        КонецЕсли;
    КонецЦикла;
    
    Возврат Истина;
    
КонецФункции

// Парсер объектов
//
// Параметры:
//   Строки - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Соответствие - результат парсинга объектов
//
Функция ПарсерОбъектов(Строки)
    Лог.Отладка("Начало парсинга объектов");
    
    МассивОбъектов = ПолучитьМассивСущностей(Строки);
    СоответствиеОбъектов = Новый Соответствие();
    
    Лог.Отладка("Найдено " + МассивОбъектов.Количество() + " объектов для обработки");

    Для Каждого Объект Из МассивОбъектов Цикл
        Если Объект.ИмяОбъекта = "<<" Тогда
            Лог.Отладка("Обработка якоря");
            // Это якорь. Разыменуем его.
            Данные = ДанныеИзМассиваСтрок(Объект.Содержимое);
            Если не ТипЗнч(Данные) = Тип("Соответствие") Тогда
                Лог.Ошибка("Якорь должен быть объектом, а получено: " + ТипЗнч(Данные));
                ВызватьИсключение "Якорь должен быть объектом, а получено: " + ТипЗнч(Данные);
            КонецЕсли;
            // Добавляем все ключи и значения из якоря в текущее соответствие    
            Для каждого КлючИЗначение Из Данные Цикл
                СоответствиеОбъектов.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
            КонецЦикла;
        Иначе
            Лог.Отладка("Обработка объекта с ключом: " + Объект.ИмяОбъекта);
            СоответствиеОбъектов.Вставить(УбратьКавычки(Объект.ИмяОбъекта), ДанныеИзМассиваСтрок(Объект.Содержимое));
        КонецЕсли;
    КонецЦикла;
    
    Лог.Отладка("Парсинг объектов завершен, получено " + СоответствиеОбъектов.Количество() + " свойств");
    Возврат СоответствиеОбъектов;
    
КонецФункции

// Парсер якорей
//
// Параметры:
//   Строки - Массив - массив строк для парсинга якоря
//
// Возвращаемое значение:
//   Соответствие - результат парсинга объекта с якорем
//
Функция ПарсерЯкорей(Строки)
    Лог.Отладка("Начало парсинга якоря");
    
    // Находим параметры якоря
    ПараметрыЯкоря = НайтиПараметрыЯкоря(Строки);
    
    Если ПараметрыЯкоря = Неопределено Тогда
        Лог.Ошибка("Не найдено определение якоря");
        ВызватьИсключение "Не найдено определение якоря";
    КонецЕсли;
    
    Лог.Отладка("Найден якорь с именем: " + ПараметрыЯкоря.ИмяЯкоря);
    
    // Извлекаем строки содержимого (без строки с определением якоря)
    СтрокиСодержимого = ИзвлечьСодержимоеЯкоря(Строки, ПараметрыЯкоря);
    
    // Парсим содержимое как объект
    РезультатПарсинга = ДанныеИзМассиваСтрок(СтрокиСодержимого);
    
    // Сохраняем результат под якорем
    МенеджерЯкорей.СохранитьЯкорь(ПараметрыЯкоря.ИмяЯкоря, РезультатПарсинга);
    Лог.Отладка("Якорь сохранен в менеджере якорей");
    
    // Возвращаем результат парсинга
    Возврат РезультатПарсинга;
    
КонецФункции

Функция ПарсерАлиасов(Строки)
    Лог.Отладка("Начало парсинга алиаса");
    
    Для каждого Строка Из Строки Цикл
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Продолжить;
        КонецЕсли;
        ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
        Если ДанныеУправляющегоСимвола.Символ <> "*" Тогда
            Лог.Ошибка("Ожидался алиас, а найдено: " + Строка);
            ВызватьИсключение "Ожидался алиас, а найдено: " + Строка;
        КонецЕсли;
        ИмяАлиаса = МенеджерЯкорей.ИзвлечьИмяЯкоряИлиАлиаса(Строка);
        Если ПустаяСтрока(ИмяАлиаса) Тогда
            Лог.Ошибка("Не указано имя алиаса в строке: " + Строка);
            ВызватьИсключение "Не указано имя алиаса в строке: " + Строка;
        КонецЕсли;
        Лог.Отладка("Найден алиас с именем: " + ИмяАлиаса);
        Прервать;
    КонецЦикла;
    
    // Получаем значение алиаса из менеджера якорей
    ЗначениеАлиаса = МенеджерЯкорей.ПолучитьЗначениеЯкоря(ИмяАлиаса);
    
    Если ЗначениеАлиаса = Неопределено Тогда
        Лог.Ошибка("Не найден алиас: " + ИмяАлиаса);
        ВызватьИсключение "Не найден алиас: " + ИмяАлиаса;
    КонецЕсли;
    
    Лог.Отладка("Алиас успешно разрешен");
    Возврат ЗначениеАлиаса;
КонецФункции
// Парсер массивов
//
// Параметры:
//   Строки - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Массив - результат парсинга массива
//
Функция ПарсерМассивов(Строки)
    Лог.Отладка("Начало парсинга массива");
    
    МассивЭлементов = ПолучитьМассивСущностей(Строки);
    МассивРезультат = Новый Массив();
    
    Лог.Отладка("Найдено " + МассивЭлементов.Количество() + " элементов массива");
    
    Для Каждого Элемент Из МассивЭлементов Цикл
        Лог.Отладка("Обработка элемента массива");
        МассивРезультат.Добавить(ДанныеИзМассиваСтрок(Элемент.Содержимое));
    КонецЦикла;
    
    Лог.Отладка("Парсинг массива завершен, получено " + МассивРезультат.Количество() + " элементов");
    Возврат МассивРезультат;
КонецФункции

// Создает структуру сущности с базовыми параметрами
//
// Параметры:
//   ТипОбъекта - Строка - тип объекта (Объект, ЭлементМассива)
//   ИмяОбъекта - Строка - имя объекта
//   МинимальныйОтступ - Число - минимальный отступ
//
// Возвращаемое значение:
//   Структура - структура сущности
//
Функция СоздатьСтруктуруСущности(ТипОбъекта, ИмяОбъекта, МинимальныйОтступ)
    Сущность = Новый Структура();
    Сущность.Вставить("ТипОбъекта", ТипОбъекта);
    Сущность.Вставить("ИмяОбъекта", ИмяОбъекта);
    Сущность.Вставить("МинимальныйОтступ", МинимальныйОтступ);
    Возврат Сущность;
КонецФункции

// Обрабатывает одну сущность из массива строк
//
// Параметры:
//   Строка - Строка - обрабатываемая строка
//   Строки - Массив - массив всех строк
//   Индекс - Число - индекс текущей строки
//   МассивСущностей - Массив - уже обработанные сущности
//
// Возвращаемое значение:
//   Структура - результат обработки сущности с полями: Сущность, НовыйИндекс
//
Функция ОбработатьОднуСущность(Строка, Строки, Индекс, МассивСущностей)
    ТекущийОтступ = ОпределитьОтступ(Строка);
    ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
    
    Если ДанныеУправляющегоСимвола.Символ = ":" Тогда // Это объект
        ИмяОбъекта = СокрЛП(Лев(Строка, ДанныеУправляющегоСимвола.Позиция - 1));
        Сущность = СоздатьСтруктуруСущности("Объект", ИмяОбъекта, ТекущийОтступ + 1);
        Лог.Отладка("Найден объект: " + ИмяОбъекта);
        МодифицированнаяСтрока = ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, ДанныеУправляющегоСимвола.Позиция);
        СледующийУправляющийСимвол = НайтиУправляющийСимволИЕгоПозицию(МодифицированнаяСтрока);
        Если СледующийУправляющийСимвол.Позиция > 0 
                И (СледующийУправляющийСимвол.Символ = ":" 
                Или СледующийУправляющийСимвол.Символ = "-") Тогда
            Лог.Ошибка("Найдено несколько управляющих символов в строке: " + Строка);
            ВызватьИсключение "Найдено несколько управляющих символов в строке: " + Строка;
        КонецЕсли;
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "-" Тогда // Это элемент массива
        Сущность = СоздатьСтруктуруСущности("ЭлементМассива", "ЭлементМассива", ТекущийОтступ + 1);
        Лог.Отладка("Найден элемент массива");
        МодифицированнаяСтрока = ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, ДанныеУправляющегоСимвола.Позиция);
    Иначе
        Лог.Ошибка("Не удалось выделить управляющий символ в строке: " + Строка);
        ВызватьИсключение "Не удалось выделить управляющий символ в строке: " + Строка;
    КонецЕсли;
    
    ПроверитьВалидностьСущности(Сущность, МассивСущностей);

    Строки[Индекс] = МодифицированнаяСтрока; // Обновим строку с отступом
    СтрокиСодержимого = ВыделитьСодержимое(Строки, Индекс, ТекущийОтступ);
    
    Сущность.Вставить("Содержимое", СтрокиСодержимого);
    НовыйИндекс = Индекс + СтрокиСодержимого.Количество() - 1;

    Результат = СоздатьРезультатОбработкиСущности(Сущность, НовыйИндекс);
    Возврат Результат;
КонецФункции

// Получение массива объектов из строк
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Массив - массив структур с описанием объектов
//
Функция ПолучитьМассивСущностей(Строки)
    Лог.Отладка("Начало извлечения сущностей из " + Строки.Количество() + " строк");
    
    МассивСущностей = Новый Массив();
    
    Для Индекс = 0 По Строки.Количество() - 1 Цикл
        Строка = Строки[Индекс];

        // Пропускаем пустые строки и комментарии
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Продолжить;
        КонецЕсли;
        
        РезультатОбработки = ОбработатьОднуСущность(Строка, Строки, Индекс, МассивСущностей);
        МассивСущностей.Добавить(РезультатОбработки.Сущность);
        Индекс = РезультатОбработки.НовыйИндекс;
    КонецЦикла;
    
    Лог.Отладка("Извлечение сущностей завершено, найдено " + МассивСущностей.Количество() + " сущностей");
    Возврат МассивСущностей;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ ДЛЯ ОБРАБОТКИ СТРОК И ОТСТУПОВ
////////////////////////////////////////////////////////////////////////////////

Функция ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, Позиция)
    
    Отступ = "";
    Пока СтрДлина(Отступ) < Позиция Цикл
        Отступ = Отступ + " ";
    КонецЦикла;
    ПолучившаясяСтрока = Отступ + Сред(Строка, Позиция + 1);
    Возврат ПолучившаясяСтрока;
КонецФункции

Процедура ПроверитьВалидностьСущности(Сущность, МассивСущностей)
    
    Если МассивСущностей.Количество() = 0 Тогда
        Возврат; // Если массив пустой, то валидность не проверяем
    КонецЕсли;
    ПервыйОбъект = МассивСущностей[0];
    
    Если НЕ Сущность.МинимальныйОтступ = ПервыйОбъект.МинимальныйОтступ Тогда
        ТекстОшибки = СтрШаблон(
                "Отступ <%1> отличается от требуемого <%2>. Все сущности должны иметь одинаковый отступ.",
                Сущность.МинимальныйОтступ - 1, ПервыйОбъект.МинимальныйОтступ - 1);
        Лог.Ошибка(ТекстОшибки);
        ВызватьИсключение ТекстОшибки;
    КонецЕсли;
    
    Если НЕ Сущность.ТипОбъекта = ПервыйОбъект.ТипОбъекта Тогда
        ТекстОшибки = СтрШаблон(
                "Тип сущности <%1> отличается от требуемого <%2>. Все сущности должны иметь одинаковый тип.",
                Сущность.ТипОбъекта, ПервыйОбъект.ТипОбъекта);
        Лог.Ошибка(ТекстОшибки);
        ВызватьИсключение ТекстОшибки;
    КонецЕсли;

КонецПроцедуры

// Функция для выделения содержимого из строк
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//   Индекс - Число - индекс строки для анализа
//   ТекущийОтступ - Число - минимальный отступ для выделения содержимого
//
// Возвращаемое значение:
//   Массив - массив строк, содержащих выделенное содержимое
//
Функция ВыделитьСодержимое(Строки, Индекс, ТекущийОтступ)
    
    Содержимое = Новый Массив();
    Для НомерСтроки = Индекс По Строки.Количество() - 1 Цикл
        Строка = Строки[НомерСтроки];
        Если ОпределитьОтступ(Строка) > ТекущийОтступ ИЛИ ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Содержимое.Добавить(Строка);
        Иначе
            Прервать;
        КонецЕсли;
    КонецЦикла;
    
    Возврат Содержимое;
КонецФункции

Функция ОпределитьОтступ(Строка)
    // Определяем отступ в строке
    Отступ = 0;
    Для а = 1 По СтрДлина(Строка) Цикл
        Символ = Сред(Строка, а, 1);
        Если Символ = " " Тогда
            Отступ = Отступ + 1;
        Иначе
            Прервать; // Прерываем цикл при первом не-пробельном символе
        КонецЕсли;
    КонецЦикла;
    
    Возврат Отступ;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПАРСЕРЫ МНОГОСТРОЧНЫХ СТРОК И СПЕЦИАЛЬНЫХ КОНСТРУКЦИЙ
////////////////////////////////////////////////////////////////////////////////

// Парсер многострочных строк
//
// Параметры:
//   МассивСтрок - Массив - массив строк для парсинга многострочной строки
//
// Возвращаемое значение:
//   Строка - результат парсинга многострочной строки
//
Функция ПарсерМногострочныхСтрок(МассивСтрок)
    
    // Определяем параметры многострочной строки
    ПараметрыМногострочнойСтроки = НайтиПараметрыМногострочнойСтроки(МассивСтрок);
    
    Если ПараметрыМногострочнойСтроки = Неопределено Тогда
        Возврат ""; // Не найден управляющий символ, возвращаем пустую строку
    КонецЕсли;
    
    // Извлекаем строки содержимого
    СтрокиСодержимого = ИзвлечьСодержимоеМногострочнойСтроки(МассивСтрок, ПараметрыМногострочнойСтроки);
    
    // Обрабатываем пустые строки в конце если необходимо
    СтрокиСодержимого = ОбработатьПустыеСтрокиВКонце(СтрокиСодержимого, ПараметрыМногострочнойСтроки);
    
    // Собираем финальную строку
    Возврат СобратьМногострочнуюСтроку(СтрокиСодержимого, ПараметрыМногострочнойСтроки);
    
КонецФункции

// Создает структуру параметров многострочной строки
//
// Параметры:
//   ТипСтроки - Строка - тип многострочной строки ("|" или ">")
//   УправляющийПодсимвол - Строка - подсимвол (+, -, или пустая строка)
//   ИндексНачалаСодержимого - Число - индекс строки начала содержимого
//   ОтступСодержимого - Число - отступ содержимого
//
// Возвращаемое значение:
//   Структура - структура параметров многострочной строки
//
Функция СоздатьПараметрыМногострочнойСтроки(ТипСтроки, УправляющийПодсимвол, ИндексНачалаСодержимого, ОтступСодержимого)
    Параметры = Новый Структура();
    Параметры.Вставить("ТипСтроки", ТипСтроки); // "|" или ">"
    Параметры.Вставить("СохранятьПустыеСтрокиВКонце", УправляющийПодсимвол = "+");
    Параметры.Вставить("ДобавлятьПереносПоследнейСтроки", УправляющийПодсимвол <> "-");
    Параметры.Вставить("ИндексНачалаСодержимого", ИндексНачалаСодержимого);
    Параметры.Вставить("ОтступСодержимого", ОтступСодержимого);
    
    Возврат Параметры;
КонецФункции

// Находит параметры многострочной строки по управляющим символам
//
// Параметры:
//   МассивСтрок - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Структура - параметры многострочной строки или Неопределено
//
Функция НайтиПараметрыМногострочнойСтроки(МассивСтрок)
    Лог.Отладка("Поиск параметров многострочной строки");
    
    Для Индекс = 0 По МассивСтрок.Количество() - 1 Цикл
        Строка = МассивСтрок[Индекс];
        
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) тогда
            Продолжить; // Пропускаем пустые строки и комментарии
        КонецЕсли;
        
        ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
        
        Если НЕ (ДанныеУправляющегоСимвола.Символ = "|" ИЛИ ДанныеУправляющегоСимвола.Символ = ">") тогда
            Лог.Ошибка("Ожидался управляющий символ многострочной строки, но найдено: " + Строка);
            ВызватьИсключение "Ожидался управляющий символ многострочной строки, но найдено: " + Строка;
        КонецЕсли;
        
        УправляющийПодсимвол = ПолучитьУправляющийПодсимвол(Строка, ДанныеУправляющегоСимвола.Позиция + 1);
        Лог.Отладка("Найден управляющий символ: " + ДанныеУправляющегоСимвола.Символ + " с подсимволом: " + УправляющийПодсимвол);
        
        // Определяем отступ для содержимого
        ОтступСодержимого = 0;
        Если Индекс + 1 < МассивСтрок.Количество() Тогда
            ОтступСодержимого = ОпределитьОтступ(МассивСтрок[Индекс + 1]);
        КонецЕсли;
        
        Параметры = СоздатьПараметрыМногострочнойСтроки(
            ДанныеУправляющегоСимвола.Символ, 
            УправляющийПодсимвол, 
            Индекс + 1, 
            ОтступСодержимого
        );
        
        Лог.Отладка("Параметры многострочной строки найдены");
        Возврат Параметры;
    КонецЦикла;
    
    Лог.Предупреждение("Управляющий символ многострочной строки не найден");
    Возврат Неопределено; // Управляющий символ не найден
    
КонецФункции

// Извлекает строки содержимого многострочной строки
//
// Параметры:
//   МассивСтрок - Массив - исходный массив строк
//   Параметры - Структура - параметры многострочной строки
//
// Возвращаемое значение:
//   Массив - массив строк содержимого
//
Функция ИзвлечьСодержимоеМногострочнойСтроки(МассивСтрок, Параметры)
    Лог.Отладка("Извлечение содержимого многострочной строки");
    
    СтрокиСодержимого = Новый Массив();
    
    Для Индекс = Параметры.ИндексНачалаСодержимого По МассивСтрок.Количество() - 1 Цикл
        ИсходнаяСтрока = МассивСтрок[Индекс];
        
        Если ОпределитьОтступ(ИсходнаяСтрока) < Параметры.ОтступСодержимого 
            И Не ЭтоПустаяСтрокаИлиКомментарий(ИсходнаяСтрока) Тогда
             Лог.Ошибка("Отступ строки меньше требуемого");
             ВызватьИсключение "Отступ строки меньше требуемого"; // Прерываем, если отступ меньше, чем заданный
        КонецЕсли;  
        // Убираем отступ с учетом базового отступа содержимого
        СтрокаБезОтступа = Сред(ИсходнаяСтрока, Параметры.ОтступСодержимого + 1);
        СтрокиСодержимого.Добавить(СтрокаБезОтступа);
    КонецЦикла;
    
    Лог.Отладка("Извлечено " + СтрокиСодержимого.Количество() + " строк содержимого");
    Возврат СтрокиСодержимого;
    
КонецФункции

// Обрабатывает пустые строки в конце массива строк
//
// Параметры:
//   СтрокиСодержимого - Массив - строки содержимого
//   Параметры - Структура - параметры многострочной строки
//
// Возвращаемое значение:
//   Массив - обработанный массив строк
//
Функция ОбработатьПустыеСтрокиВКонце(СтрокиСодержимого, Параметры)
    
    Если Параметры.СохранятьПустыеСтрокиВКонце Тогда
        Возврат СтрокиСодержимого; // Сохраняем все строки как есть
    КонецЕсли;
    
    // Удаляем пустые строки с конца
    Пока СтрокиСодержимого.Количество() > 0 
        И СтрЗаменить(СтрокиСодержимого[СтрокиСодержимого.Количество() - 1], " ", "") = "" Цикл
        СтрокиСодержимого.Удалить(СтрокиСодержимого.Количество() - 1);
    КонецЦикла;
    
    Возврат СтрокиСодержимого;
    
КонецФункции

// Собирает финальную многострочную строку
//
// Параметры:
//   СтрокиСодержимого - Массив - строки содержимого
//   Параметры - Структура - параметры многострочной строки
//
// Возвращаемое значение:
//   Строка - собранная многострочная строка
//
Функция СобратьМногострочнуюСтроку(СтрокиСодержимого, Параметры)
    
    Если СтрокиСодержимого.Количество() = 0 Тогда
        Возврат "";
    КонецЕсли;
    
    // Определяем разделитель строк в зависимости от типа
    Разделитель = ?(Параметры.ТипСтроки = "|", Символы.ПС, " ");
    
    // Соединяем строки разделителем
    РезультирующаяСтрока = СтрСоединить(СтрокиСодержимого, Разделитель);
    
    // Заменяем двойные пробелы на переносы строк для блочного стиля
    Если Параметры.ТипСтроки = ">" Тогда
        РезультирующаяСтрока = СтрЗаменить(РезультирующаяСтрока, "  ", Символы.ПС);
    КонецЕсли;
    
    // Добавляем перенос строки в конце если необходимо
    Если Параметры.ДобавлятьПереносПоследнейСтроки Тогда
        РезультирующаяСтрока = РезультирующаяСтрока + Символы.ПС;
    КонецЕсли;
    
    Возврат РезультирующаяСтрока;
    
КонецФункции

Функция ПолучитьУправляющийПодсимвол(Строка, Позиция)
    Если СтрДлина(Строка) < Позиция Тогда
        Возврат ""; // Нет подсимвола, возвращаем пустую строку
    КонецЕсли;
    Возврат Сред(Строка, Позиция, 1);
КонецФункции

// Создает структуру параметров якоря
//
// Параметры:
//   ИмяЯкоря - Строка - имя якоря
//   ИндексСтрокиСЯкорем - Число - индекс строки с якорем
//
// Возвращаемое значение:
//   Структура - структура параметров якоря
//
Функция СоздатьПараметрыЯкоря(ИмяЯкоря, ИндексСтрокиСЯкорем)
    Параметры = Новый Структура();
    Параметры.Вставить("ИмяЯкоря", ИмяЯкоря);
    Параметры.Вставить("ИндексСтрокиСЯкорем", ИндексСтрокиСЯкорем);
    
    Возврат Параметры;
КонецФункции

// Находит параметры якоря по управляющему символу &
//
// Параметры:
//   МассивСтрок - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Структура - параметры якоря или Неопределено
//
Функция НайтиПараметрыЯкоря(МассивСтрок)
    Лог.Отладка("Поиск параметров якоря");
    
    Для Индекс = 0 По МассивСтрок.Количество() - 1 Цикл
        Строка = МассивСтрок[Индекс];
        
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) тогда
            Продолжить; // Пропускаем пустые строки и комментарии
        КонецЕсли;
        
        ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
        
        Если НЕ ДанныеУправляющегоСимвола.Символ = "&" тогда
            Лог.Ошибка("Ожидался управляющий символ якоря (&), но найдено: " + Строка);
            ВызватьИсключение "Ожидался управляющий символ якоря (&), но найдено: " + Строка;
        КонецЕсли;
        
        
        // Извлекаем имя якоря
        ИмяЯкоря = МенеджерЯкорей.ИзвлечьИмяЯкоряИлиАлиаса(Строка);
        Если ПустаяСтрока(ИмяЯкоря) Тогда
            Лог.Ошибка("Не удалось извлечь имя якоря из строки: " + Строка);
            ВызватьИсключение "Не удалось извлечь имя якоря из строки: " + Строка;
        КонецЕсли;
        
        Лог.Отладка("Найден якорь с именем: " + ИмяЯкоря);
        
        Параметры = СоздатьПараметрыЯкоря(ИмяЯкоря, Индекс);
        
        Возврат Параметры;
    КонецЦикла;
    
    Лог.Предупреждение("Управляющий символ якоря не найден");
    Возврат Неопределено; // Управляющий символ якоря не найден
    
КонецФункции

// Извлекает строки содержимого якоря (убирает строку с определением якоря)
//
// Параметры:
//   МассивСтрок - Массив - исходный массив строк
//   Параметры - Структура - параметры якоря
//
// Возвращаемое значение:
//   Массив - массив строк содержимого без определения якоря
//
Функция ИзвлечьСодержимоеЯкоря(МассивСтрок, Параметры)
    
    СтрокиСодержимого = Новый Массив();
    
    // Обрабатываем строку с якорем - убираем определение якоря
    СтрокаСЯкорем = МассивСтрок[Параметры.ИндексСтрокиСЯкорем];
    ОчищеннаяСтрока = МенеджерЯкорей.УдалитьОпределениеЯкоря(СтрокаСЯкорем);
   
    СтрокиСодержимого.Добавить(ОчищеннаяСтрока);
   
    
    // Добавляем все остальные строки
    Для Индекс = Параметры.ИндексСтрокиСЯкорем + 1 По МассивСтрок.Количество() - 1 Цикл
        СтрокиСодержимого.Добавить(МассивСтрок[Индекс]);
    КонецЦикла;

    Возврат СтрокиСодержимого;
    
КонецФункции

// Проверяет корректность YAML строки flow последовательности
//
// Параметры:
//   СтрокаFlow - Строка - строка flow последовательности для проверки
//
// Исключения:
//   При некорректном формате flow последовательности
//
Процедура ВалидироватьFlowПоследовательность(СтрокаFlow)
    Если ПустаяСтрока(СтрокаFlow) Тогда
        Лог.Ошибка("Не найдена строка с flow последовательностью");
        ВызватьИсключение "Не найдена строка с flow последовательностью";
    КонецЕсли;
    
    Если НЕ СтрНачинаетсяС(СтрокаFlow, "[") Тогда
        Лог.Ошибка("Flow последовательность должна начинаться с [. Получено: " + СтрокаFlow);
        ВызватьИсключение "Flow последовательность должна начинаться с [";
    КонецЕсли;
КонецПроцедуры

// Парсер flow последовательностей (массивов в стиле [1, 2, 3])
//
// Параметры:
//   Строки - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Массив - результат парсинга flow последовательности
//
Функция ПарсерFlowПоследовательности(Строки)
    Лог.Отладка("Начало парсинга flow последовательности");
    
    // Объединяем все строки в одну, удаляя комментарии
    СтрокаFlow = ОбъединитьСтрокиFlowСинтаксиса(Строки);
    
    // Валидируем строку flow последовательности
    ВалидироватьFlowПоследовательность(СтрокаFlow);
    
    // Найдем позицию соответствующей закрывающей скобки
    ПозицияЗакрытия = НайтиСоответствующуюЗакрывающуюСкобку(СтрокаFlow, 1);
    Если ПозицияЗакрытия = 0 Тогда
        Лог.Ошибка("Flow последовательность должна заканчиваться ]. Получено: " + СтрокаFlow);
        ВызватьИсключение "Flow последовательность должна заканчиваться ]";
    КонецЕсли;
    
    // Проверим, что после соответствующей закрывающей скобки нет значащих символов
    ОстатокСтроки = СокрЛП(Сред(СтрокаFlow, ПозицияЗакрытия + 1));
    Если НЕ ПустаяСтрока(ОстатокСтроки) Тогда
        Лог.Ошибка("После закрывающей скобки flow последовательности не должно быть других символов. Получено: " + СтрокаFlow);
        ВызватьИсключение "После закрывающей скобки flow последовательности не должно быть других символов";
    КонецЕсли;

    СодержимоеМассива = Сред(СтрокаFlow, 2, ПозицияЗакрытия - 2);
    Лог.Отладка("Содержимое flow последовательности: " + СодержимоеМассива);
    
    // Проверяем валидность синтаксиса
    ПроверитьВалидностьFlowПоследовательности(СодержимоеМассива);
    
    // Разбираем элементы
    Элементы = РазбитьFlowЭлементы(СодержимоеМассива);
    
    МассивРезультат = Новый Массив();
    Для Каждого Элемент Из Элементы Цикл
        ОчищенныйЭлемент = СокрЛП(Элемент);
        Если НЕ ПустаяСтрока(ОчищенныйЭлемент) Тогда
            // Рекурсивно обрабатываем каждый элемент
            СтрокиЭлемента = Новый Массив();
            СтрокиЭлемента.Добавить(ОчищенныйЭлемент);
            МассивРезультат.Добавить(ДанныеИзМассиваСтрок(СтрокиЭлемента));
        КонецЕсли;
    КонецЦикла;
    
    Лог.Отладка("Парсинг flow последовательности завершен, получено " + МассивРезультат.Количество() + " элементов");
    Возврат МассивРезультат;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ ДЛЯ FLOW-СИНТАКСИСА
////////////////////////////////////////////////////////////////////////////////

// Объединяет массив строк в одну строку, удаляя комментарии
//
// Параметры:
//   Строки - Массив - массив строк для объединения
//
// Возвращаемое значение:
//   Строка - объединенная строка без комментариев
//
Функция ОбъединитьСтрокиFlowСинтаксиса(Строки)
    СтрокаFlow = "";
    Для Каждого Строка Из Строки Цикл
        Если НЕ ПустаяСтрока(СокрЛП(Строка)) Тогда
            // Удаляем комментарии из строки
            СтрокаБезКомментария = УбратьКомментарийИзСтроки(Строка);
            Если НЕ ПустаяСтрока(СокрЛП(СтрокаБезКомментария)) Тогда
                СтрокаFlow = СтрокаFlow + " " + СокрЛП(СтрокаБезКомментария);
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат СокрЛП(СтрокаFlow);
КонецФункции

// Обрабатывает один элемент flow объекта
//
// Параметры:
//   ОчищенныйЭлемент - Строка - элемент для обработки
//   СоответствиеРезультат - Соответствие - результирующее соответствие
//
Процедура ОбработатьЭлементFlowОбъекта(ОчищенныйЭлемент, СоответствиеРезультат)
    Если ПустаяСтрока(ОчищенныйЭлемент) Тогда
        Возврат;
    КонецЕсли;
    
    // Ищем разделитель ключ-значение
    ПозицияДвоеточия = ПозицияНеЭкранированногоСимвола(ОчищенныйЭлемент, ":", Истина);
    Если ПозицияДвоеточия = 0 Тогда
        Лог.Отладка("Не найден разделитель ':' в элементе flow объекта: " + ОчищенныйЭлемент);
        Ключ = ОчищенныйЭлемент;
        Значение = "";
    Иначе
        Ключ = СокрЛП(Лев(ОчищенныйЭлемент, ПозицияДвоеточия - 1));
        Значение = СокрЛП(Сред(ОчищенныйЭлемент, ПозицияДвоеточия + 1));
    КонецЕсли;
    
    // Убираем кавычки с ключа
    Ключ = УбратьКавычки(Ключ);
    
    // Обрабатываем пустые значения
    Если ПустаяСтрока(Значение) Тогда
        СоответствиеРезультат.Вставить(Ключ, Null);
    Иначе
        // Рекурсивно обрабатываем значение
        СтрокиЗначения = Новый Массив();
        СтрокиЗначения.Добавить(Значение);
        СоответствиеРезультат.Вставить(Ключ, ДанныеИзМассиваСтрок(СтрокиЗначения));
    КонецЕсли;
КонецПроцедуры

// Проверяет корректность YAML строки flow объекта
//
// Параметры:
//   СтрокаFlow - Строка - строка flow объекта для проверки
//
// Исключения:
//   При некорректном формате flow объекта
//
Процедура ВалидироватьFlowОбъект(СтрокаFlow)
    Если ПустаяСтрока(СтрокаFlow) Тогда
        Лог.Ошибка("Не найдена строка с flow объектом");
        ВызватьИсключение "Не найдена строка с flow объектом";
    КонецЕсли;
    
    Если НЕ (СтрНачинаетсяС(СтрокаFlow, "{") И СтрЗаканчиваетсяНа(СтрокаFlow, "}")) Тогда
        Лог.Ошибка("Flow объект должен начинаться с { и заканчиваться }. Получено: " + СтрокаFlow);
        ВызватьИсключение "Flow объект должен начинаться с { и заканчиваться }";
    КонецЕсли;
КонецПроцедуры

// Парсер flow объектов (объектов в стиле {key1: value1, key2: value2})
//
// Параметры:
//   Строки - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Соответствие - результат парсинга flow объекта
//
Функция ПарсерFlowОбъекта(Строки)
    Лог.Отладка("Начало парсинга flow объекта");
    
    // Объединяем все строки в одну, удаляя комментарии
    СтрокаFlow = ОбъединитьСтрокиFlowСинтаксиса(Строки);
    
    // Валидируем строку flow объекта
    ВалидироватьFlowОбъект(СтрокаFlow);
    
    СодержимоеОбъекта = Сред(СтрокаFlow, 2, СтрДлина(СтрокаFlow) - 2);
    Лог.Отладка("Содержимое flow объекта: " + СодержимоеОбъекта);
    
    // Проверяем валидность синтаксиса
    ПроверитьВалидностьFlowОбъекта(СодержимоеОбъекта);
    
    // Разбираем пары ключ-значение
    Элементы = РазбитьFlowЭлементы(СодержимоеОбъекта);
    
    СоответствиеРезультат = Новый Соответствие();
    Для Каждого Элемент Из Элементы Цикл
        ОчищенныйЭлемент = СокрЛП(Элемент);
        ОбработатьЭлементFlowОбъекта(ОчищенныйЭлемент, СоответствиеРезультат);
    КонецЦикла;
    
    Лог.Отладка("Парсинг flow объекта завершен, получено " + СоответствиеРезультат.Количество() + " свойств");
    Возврат СоответствиеРезультат;
КонецФункции

// Разбивает строку flow элементов на отдельные элементы с учетом вложенности
//
// Параметры:
//   СтрокаЭлементов - Строка - строка с элементами для разбиения
//
// Возвращаемое значение:
//   Массив - массив отдельных элементов
//
Функция РазбитьFlowЭлементы(СтрокаЭлементов)
    Лог.Отладка("Разбиение flow элементов: " + СтрокаЭлементов);
    
    Элементы = Новый Массив();
    ТекущийЭлемент = "";
    УровеньВложенности = 0;
    ВКавычках = Ложь;
    ТипКавычек = "";
    
    Для Позиция = 1 По СтрДлина(СтрокаЭлементов) Цикл
        Символ = Сред(СтрокаЭлементов, Позиция, 1);
        
        // Обработка кавычек
        Если ОбработатьКавычки(Символ, ВКавычках, ТипКавычек) Тогда
            ТекущийЭлемент = ТекущийЭлемент + Символ;
            Продолжить;
        КонецЕсли;
        
        Если НЕ ВКавычках Тогда
            // Обрабатываем элементы вне кавычек
            Если ОбработатьЭлементВнеКавычек(Символ, УровеньВложенности, ТекущийЭлемент, Элементы) Тогда
                Продолжить;
            КонецЕсли;
        КонецЕсли;
        
        ТекущийЭлемент = ТекущийЭлемент + Символ;
    КонецЦикла;
    
    // Добавляем последний элемент
    Если НЕ ПустаяСтрока(ТекущийЭлемент) Тогда
        Элементы.Добавить(ТекущийЭлемент);
    КонецЕсли;
    
    Лог.Отладка("Разбиение завершено, получено " + Элементы.Количество() + " элементов");
    Возврат Элементы;
КонецФункции

// Обрабатывает кавычки в flow элементах
//
// Параметры:
//   Символ - Строка - текущий символ
//   ВКавычках - Булево - флаг нахождения в кавычках (передается по ссылке)
//   ТипКавычек - Строка - тип кавычек (передается по ссылке)
//
// Возвращаемое значение:
//   Булево - Истина, если символ обработан как кавычка
//
Функция ОбработатьКавычки(Символ, ВКавычках, ТипКавычек)
    
    Если (Символ = """" ИЛИ Символ = "'") И НЕ ВКавычках Тогда
        ВКавычках = Истина;
        ТипКавычек = Символ;
        Возврат Истина;
    ИначеЕсли ВКавычках И Символ = ТипКавычек Тогда
        ВКавычках = Ложь;
        ТипКавычек = "";
        Возврат Истина;
    Иначе
        Возврат Ложь;
    КонецЕсли;
    
КонецФункции

// Обрабатывает элемент вне кавычек
//
// Параметры:
//   Символ - Строка - текущий символ
//   УровеньВложенности - Число - уровень вложенности (передается по ссылке)
//   ТекущийЭлемент - Строка - текущий элемент (передается по ссылке)
//   Элементы - Массив - массив элементов (передается по ссылке)
//
// Возвращаемое значение:
//   Булево - Истина, если нужно продолжить итерацию
//
Функция ОбработатьЭлементВнеКавычек(Символ, УровеньВложенности, ТекущийЭлемент, Элементы)
    
    Если Символ = "[" ИЛИ Символ = "{" Тогда
        УровеньВложенности = УровеньВложенности + 1;
    ИначеЕсли Символ = "]" ИЛИ Символ = "}" Тогда
        УровеньВложенности = УровеньВложенности - 1;
    ИначеЕсли Символ = "," И УровеньВложенности = 0 Тогда
        // Это разделитель элементов на верхнем уровне
        Элементы.Добавить(ТекущийЭлемент);
        ТекущийЭлемент = "";
        Возврат Истина;
    Иначе
        Возврат Ложь;
    КонецЕсли;
    
    Возврат Ложь;
    
КонецФункции

// Проверяет валидность flow последовательности
//
// Параметры:
//   СодержимоеМассива - Строка - содержимое между [ и ]
//
// Исключения:
//   При обнаружении некорректного синтаксиса
//
Процедура ПроверитьВалидностьFlowПоследовательности(СодержимоеМассива)
    
    Если ПустаяСтрока(СокрЛП(СодержимоеМассива)) Тогда
        Возврат; // Пустая последовательность валидна
    КонецЕсли;
    
    // Проверяем на недопустимые символы в начале
    ОчищенноеСодержимое = СокрЛП(СодержимоеМассива);
    Если СтрНачинаетсяС(ОчищенноеСодержимое, ",") Тогда
        Лог.Ошибка("Flow последовательность не может начинаться с запятой");
        ВызватьИсключение "Flow последовательность не может начинаться с запятой";
    КонецЕсли;
    
    Если СтрНачинаетсяС(ОчищенноеСодержимое, "-") Тогда
        Лог.Ошибка("Flow последовательность не может содержать дефисы");
        ВызватьИсключение "Flow последовательность не может содержать дефисы";
    КонецЕсли;
    
    // Проверяем на двойные запятые (недопустимо)
    Если СтрНайти(СодержимоеМассива, ",,") > 0 Тогда
        Лог.Ошибка("Flow последовательность содержит лишние запятые");
        ВызватьИсключение "Flow последовательность содержит лишние запятые";
    КонецЕсли;
    
    // Проверяем на запятые с пробелами между ними (тоже недопустимо)
    Если СтрНайти(СодержимоеМассива, ", ,") > 0 Тогда
        Лог.Ошибка("Flow последовательность содержит лишние запятые");
        ВызватьИсключение "Flow последовательность содержит лишние запятые";
    КонецЕсли;
    
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// МЕТОДЫ ВАЛИДАЦИИ И ПРОВЕРКИ СИНТАКСИСА
////////////////////////////////////////////////////////////////////////////////

// Проверяет валидность flow объекта
//
// Параметры:
//   СодержимоеОбъекта - Строка - содержимое между { и }
//
// Возвращаемое значение:
//   Булево - истина, если синтаксис корректен
//
Функция ПроверитьВалидностьFlowОбъекта(СодержимоеОбъекта)
    
    // Проверяем на недопустимые конструкции
    ОчищенноеСодержимое = СокрЛП(СодержимоеОбъекта);
    
    // Проверяем на недопустимые запятые
    Если СтрНачинаетсяС(ОчищенноеСодержимое, ",") Тогда
        Лог.Ошибка("Flow объект не может начинаться с запятой");
        ВызватьИсключение "Flow объект не может начинаться с запятой";
    КонецЕсли;
    
    Возврат Истина;
    
КонецФункции

// Поиск соответствующей закрывающей скобки с учетом вложенности
//
// Параметры:
//   Строка - Строка - строка для поиска
//   НачальнаяПозиция - Число - позиция открывающей скобки
//
// Возвращаемое значение:
//   Число - позиция соответствующей закрывающей скобки или 0, если не найдена
//
Функция НайтиСоответствующуюЗакрывающуюСкобку(Строка, НачальнаяПозиция)
    
    УровеньВложенности = 1;
    ДлинаСтроки = СтрДлина(Строка);
    
    Для Позиция = НачальнаяПозиция + 1 По ДлинаСтроки Цикл
        Символ = Сред(Строка, Позиция, 1);
        
        Если Символ = "[" Тогда
            УровеньВложенности = УровеньВложенности + 1;
        ИначеЕсли Символ = "]" Тогда
            УровеньВложенности = УровеньВложенности - 1;
            Если УровеньВложенности = 0 Тогда
                Возврат Позиция;
            КонецЕсли;
        Иначе
            Продолжить;
        КонецЕсли;
    КонецЦикла;
    
    Возврат 0; // Не найдена соответствующая закрывающая скобка
    
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ИНИЦИАЛИЗАЦИЯ МОДУЛЯ
////////////////////////////////////////////////////////////////////////////////

// Инициализация константы YAML символов
YAML_РАЗДЕЛИТЕЛЬ_ДОКУМЕНТА = "---";
YAML_ТЕРМИНАТОР_ДОКУМЕНТА = "...";

// Инициализация логгера модуля
Лог = Логирование.ПолучитьЛог("oscript.oscript-yaml.deserializer");

////////////////////////////////////////////////////////////////////////////////
// АРХИТЕКТУРНЫЕ ЗАМЕТКИ
//
// Модуль организован по принципу разделения ответственности:
// 1. Публичные методы - точки входа в модуль
// 2. Методы работы с документами - разбиение на документы, обработка разделителей
// 3. Методы работы со строками и комментариями - очистка, обработка кавычек
// 4. Методы определения типов данных - анализ содержимого для выбора парсера
// 5. Основные парсеры типов данных - парсинг различных YAML-структур
// 6. Парсеры многострочных строк - специальная обработка | и > синтаксиса
// 7. Вспомогательные методы для flow-синтаксиса - парсинг [...] и {...}
// 8. Вспомогательные методы для строк и отступов - работа с форматированием
// 9. Методы валидации и проверки синтаксиса - контроль корректности YAML
//
// Каждая секция содержит логически связанные функции, что упрощает навигацию
// и поддержку кода.
////////////////////////////////////////////////////////////////////////////////