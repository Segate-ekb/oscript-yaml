// Модуль для десериализации YAML

// Основная функция для десериализации YAML
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для парсинга
//
// Возвращаемое значение:
//   Произвольный - распарсенная структура данных или скалярное значение
//
Функция Прочитать(СтрокаYaml) Экспорт
    
    Если ПустаяСтрока(СтрокаYaml) Тогда
        Возврат Новый Соответствие();
    КонецЕсли;
    МенеджерЯкорей.Инициализировать();
    // Разбиваем на строки
    Строки = СтрРазделить(СтрокаYaml, Символы.ПС);
    
    // Анализируем многострочное содержимое
    Возврат ДанныеИзМассиваСтрок(Строки);
    
КонецФункции

// Очистка строк от комментариев и пустых строк
//
// Параметры:
//   Строки - Массив - массив строк для очистки
//
// Возвращаемое значение:
//   Массив - очищенный массив строк
//
Функция ОчиститьСтроки(Строки)
    
    ОчищенныеСтроки = Новый Массив();
    
    Для Каждого Строка Из Строки Цикл
        ОчищеннаяСтрока = СокрЛП(Строка);
        
        Если ЭтоПустаяСтрокаИлиКомментарий(ОчищеннаяСтрока) Тогда
            Продолжить;
        КонецЕсли;
        
        ОчищенныеСтроки.Добавить(УбратьКомментарийИзСтроки(ОчищеннаяСтрока));
    КонецЦикла;
    
    Возврат ОчищенныеСтроки;
    
КонецФункции

// Проверка, является ли строка пустой или комментарием
// Параметры:
//   Строка - Строка - строка для проверки
// Возвращаемое значение:
//   Булево - Истина, если строка пустая или комментарий
//
Функция ЭтоПустаяСтрокаИлиКомментарий(Знач Строка)
    Строка = СокрЛП(Строка);
    Если ПустаяСтрока(Строка) ИЛИ Лев(Строка, 1) = "#" Тогда
        Возврат Истина;
    КонецЕсли;
    
    Возврат Ложь;
КонецФункции

// Убирает комментарий из строки, если она на него заканчивается
// Параметры:
//   Строка - Строка - строка для очистки
// Возвращаемое значение:
//   Строка - очищенная строка без комментариев
//
Функция УбратьКомментарийИзСтроки(Знач Строка)
    // Ищем позицию комментария неэкранированного символа #,
    // т.е. пропускаем символы в кавычках и тд.
    
    ПозицияКомментария = СтрНайти(Строка, "#");
    
    Если ПозицияКомментария > 0 Тогда
        Возврат Лев(Строка, ПозицияКомментария - 1);
    КонецЕсли;
    
    Возврат Строка;
КонецФункции

// Определение типа содержимого строки
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Строка - тип содержимого: "Объект", "Массив", "Json", "МногострочнаяСтрока", Неопределено
//
Функция ОпределитьТипСодержимого(Строки)
    
    Для Каждого Строка Из Строки Цикл
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Продолжить;
        КонецЕсли;
        
        // Если это не пустая строка, то управляющий символ должен быть в ней.
        // Если мы не нашли его, то это Строка или число, или что-то другое.
        Возврат НайтиТипДанныхПоСтроке(Строка);
    КонецЦикла;
    
    Возврат Неопределено; // Если не найдено ни одной строки с данными - возвращаем неопределено.
    
КонецФункции

// Определяет тип данных по строке
// Параметры:
//   Строка - Строка - строка для анализа
// Возвращаемое значение:
//   Строка - тип данных: "Объект", "Массив", "Json", "МногострочнаяСтрока"
Функция НайтиТипДанныхПоСтроке(Знач Строка)
    ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);

    Если ДанныеУправляющегоСимвола.Позиция = 0 Тогда
        Возврат "Json";
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = ":" Тогда
        Возврат "Объект";
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "-" Тогда
        Возврат "Массив"; // Массив начинается с тире и пробела
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "|" ИЛИ ДанныеУправляющегоСимвола.Символ = ">" Тогда
        Возврат "МногострочнаяСтрока"; // Многострочная строка начинается с | или >
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "&" Тогда
        Возврат "Якорь"; // Якорь начинается с &
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "*" Тогда
        Возврат "Алиас";      
    Иначе
        // Если не найдено ни одного управляющего символа, то это может быть строка или число
        ВызватьИсключение "Не удалось определить тип данных в строке: " + Строка;
    КонецЕсли;
    
КонецФункции

Функция НайтиУправляющийСимволИЕгоПозицию(Знач Строка)

    СтруктураВозврата = Новый Структура("Символ, Позиция", "", 0);
    
    МассивУправляющихСимволов = Новый Массив;
    МассивУправляющихСимволов.Добавить(":"); // Двоеточие для объектов
    МассивУправляющихСимволов.Добавить("-"); // Тире для массивов
    МассивУправляющихСимволов.Добавить("|"); // Вертикальная черта для многострочных строк
    МассивУправляющихСимволов.Добавить(">"); // Знак больше для многострочных строк
    МассивУправляющихСимволов.Добавить("&"); // Символ для определения якоря
    МассивУправляющихСимволов.Добавить("*"); // Символ для алиасов

    МинимальнаяНайденнаяПозиция = 9999999;
    Для каждого Символ Из МассивУправляющихСимволов Цикл
        НайденнаяПозиция = ПозицияНеЭкранированногоСимвола(Строка, Символ);
        Если НайденнаяПозиция > 0 И МинимальнаяНайденнаяПозиция > НайденнаяПозиция Тогда
            СтруктураВозврата.Символ = Символ;
            СтруктураВозврата.Позиция = НайденнаяПозиция;
            МинимальнаяНайденнаяПозиция = НайденнаяПозиция;
        КонецЕсли;
    КонецЦикла;
    
    Возврат СтруктураВозврата;
КонецФункции   

Функция ПозицияНеЭкранированногоСимвола(Строка, ИскомыйСимвол)
    НайденнаяПозиция = 0;
    ВКавычках = Ложь;
    ТипКавычек = "";
    
    
    Для Позиция = 1 По СтрДлина(Строка) Цикл
        Символ = Сред(Строка, Позиция, 1);
        
        // Обработка кавычек
        Если (Символ = """" ИЛИ Символ = "'") И НЕ ВКавычках Тогда
            ВКавычках = Истина;
            ТипКавычек = Символ;
            Продолжить;
        КонецЕсли;
        
        Если ВКавычках И Символ = ТипКавычек Тогда
            ВКавычках = Ложь;
            ТипКавычек = "";
            Продолжить;
        КонецЕсли;
        
        // Поиск символа (не в кавычках и с пробелом после)
        Если НЕ ВКавычках И Символ = ИскомыйСимвол Тогда
            Если ЭтоЗначащийСимвол(Строка, Позиция, ИскомыйСимвол) Тогда
                НайденнаяПозиция = Позиция;
                Прервать;
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат НайденнаяПозиция;
КонецФункции

// Проверяет, является ли Символ Значащим
// (должно быть в конце строки или с пробелом/табом после него)
//
// Параметры:
//   Строка - Строка - строка для анализа
//   Позиция - Число - позиция Символа в строке
//   ИскомыйСимвол - Строка - символ, который мы ищем
//
// Возвращаемое значение:
//   Булево - Истина, если Символ является разделителем ключ-значение
//
Функция ЭтоЗначащийСимвол(Строка, Позиция, ИскомыйСимвол)
     
    ЭтоМногострочнаяСтрока = ИскомыйСимвол = "|" ИЛИ ИскомыйСимвол = ">";
    ЭтоЯкорьИлиАлиас = ИскомыйСимвол = "&" Или ИскомыйСимвол = "*";
    Если ЭтоЯкорьИлиАлиас Тогда
        Имя = МенеджерЯкорей.ИзвлечьИмяЯкоряИлиАлиаса(Строка);
        Возврат Не Имя = "";
    КонецЕсли;    
    Если Позиция = СтрДлина(Строка) Тогда
        Возврат Истина; 
    КонецЕсли;
    
    МассивДопустимыхСимволов = Новый Массив();
    МассивДопустимыхСимволов.Добавить(" "); // Пробел
    МассивДопустимыхСимволов.Добавить(Символы.Таб); // Табуляция
    Если ЭтоМногострочнаяСтрока Тогда
        МассивДопустимыхСимволов.Добавить("-");
        МассивДопустимыхСимволов.Добавить("+");
    КонецЕсли;
    
    СледующийСимвол = Сред(Строка, Позиция + 1, 1);
        
    ЭтоЗначащийСимвол = НЕ МассивДопустимыхСимволов.Найти(СледующийСимвол) = Неопределено;
    Возврат ЭтоЗначащийСимвол;

КонецФункции

// Получает данные из массива строк
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Произвольный - результат парсинга
//
Функция ДанныеИзМассиваСтрок(Строки)
    Сообщить("Обрабатываем массив строк: " + Строки.Количество());
    Для Каждого Строка Из Строки Цикл
        Сообщить("  " + Строка);
    КонецЦикла;    
    ТипСодержимого = ОпределитьТипСодержимого(Строки);
    Если ТипСодержимого = "Объект" Тогда
        Возврат ПарсерОбъектов(Строки);
    ИначеЕсли ТипСодержимого = "Массив" Тогда
        Возврат ПарсерМассивов(Строки);
    ИначеЕсли ТипСодержимого = "МногострочнаяСтрока" Тогда
        Возврат ПарсерМногострочныхСтрок(Строки);
    ИначеЕсли ТипСодержимого = "Якорь" Тогда
        Возврат ПарсерЯкорей(Строки);
    ИначеЕсли ТипСодержимого = "Алиас" Тогда
        Возврат ПарсерАлиасов(Строки);
    ИначеЕсли ТипСодержимого = "Json" Тогда
        ОчищенныеСтроки = ОчиститьСтроки(Строки);
        Возврат ДесериализоватьJSON(СтрСоединить(ОчищенныеСтроки, ""));
    Иначе
        Возврат Неопределено; // Если не определено, то возвращаем неопределено
    КонецЕсли;
    
КонецФункции

// Парсер объектов
//
// Параметры:
//   Строки - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Соответствие - результат парсинга объектов
//
Функция ПарсерОбъектов(Строки)
    
    МассивОбъектов = ПолучитьМассивСущностей(Строки);
    СоответствиеОбъектов = Новый Соответствие();

    Для Каждого Объект Из МассивОбъектов Цикл
        Если Объект.ИмяОбъекта = "<<" Тогда
            // Это якорь. Разыменуем его.
            Данные = ДанныеИзМассиваСтрок(Объект.Содержимое);
            Если не ТипЗнч(Данные) = Тип("Соответствие") Тогда
                ВызватьИсключение "Якорь должен быть объектом, а получено: " + ТипЗнч(Данные);
            КонецЕсли;
            // Добавляем все ключи и значения из якоря в текущее соответствие    
            Для каждого КлючИЗначение Из Данные Цикл
                СоответствиеОбъектов.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
            КонецЦикла;
        Иначе
            СоответствиеОбъектов.Вставить(Объект.ИмяОбъекта, ДанныеИзМассиваСтрок(Объект.Содержимое));
        КонецЕсли;
    КонецЦикла;
    Возврат СоответствиеОбъектов;
    
КонецФункции

// Парсер якорей
//
// Параметры:
//   Строки - Массив - массив строк для парсинга якоря
//
// Возвращаемое значение:
//   Соответствие - результат парсинга объекта с якорем
//
Функция ПарсерЯкорей(Строки)
    
    // Находим параметры якоря
    ПараметрыЯкоря = НайтиПараметрыЯкоря(Строки);
    
    Если ПараметрыЯкоря = Неопределено Тогда
        ВызватьИсключение "Не найдено определение якоря";
    КонецЕсли;
    
    // Извлекаем строки содержимого (без строки с определением якоря)
    СтрокиСодержимого = ИзвлечьСодержимоеЯкоря(Строки, ПараметрыЯкоря);
    
    // Парсим содержимое как объект
    РезультатПарсинга = ДанныеИзМассиваСтрок(СтрокиСодержимого);
    
    // Сохраняем результат под якорем
    МенеджерЯкорей.СохранитьЯкорь(ПараметрыЯкоря.ИмяЯкоря, РезультатПарсинга);
    
    // Возвращаем результат парсинга
    Возврат РезультатПарсинга;
    
КонецФункции

Функция ПарсерАлиасов(Строки)
    
    Для каждого Строка Из Строки Цикл
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Продолжить;
        КонецЕсли;
        ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
        Если ДанныеУправляющегоСимвола.Символ <> "*" Тогда
            ВызватьИсключение "Ожидался алиас, а найдено: " + Строка;
        КонецЕсли;
        ИмяАлиаса = МенеджерЯкорей.ИзвлечьИмяЯкоряИлиАлиаса(Строка);
        Если ПустаяСтрока(ИмяАлиаса) Тогда
            ВызватьИсключение "Не указано имя алиаса в строке: " + Строка;
        КонецЕсли;
        Прервать;
    КонецЦикла;
    
    // Получаем значение алиаса из менеджера якорей
    ЗначениеАлиаса = МенеджерЯкорей.ПолучитьЗначениеЯкоря(ИмяАлиаса);
    
    Если ЗначениеАлиаса = Неопределено Тогда
        ВызватьИсключение "Не найден алиас: " + ИмяАлиаса;
    КонецЕсли;
    
    Возврат ЗначениеАлиаса;
КонецФункции
// Парсер массивов
//
// Параметры:
//   Строки - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Массив - результат парсинга массива
//
Функция ПарсерМассивов(Строки)
    
    МассивЭлементов = ПолучитьМассивСущностей(Строки);
    МассивРезультат = Новый Массив();
    Для Каждого Элемент Из МассивЭлементов Цикл
        МассивРезультат.Добавить(ДанныеИзМассиваСтрок(Элемент.Содержимое));
    КонецЦикла;
    
    Возврат МассивРезультат;
КонецФункции

// Получение массива объектов из строк
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Массив - массив структур с описанием объектов
//
Функция ПолучитьМассивСущностей(Строки)
    
    МассивСущностей = Новый Массив();
    
    Для Индекс = 0 По Строки.Количество() - 1 Цикл
        Строка = Строки[Индекс];

        Сущность = Новый Структура();
        // Пропускаем пустые строки и комментарии
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Продолжить;
        КонецЕсли;
        ТекущийОтступ = ОпределитьОтступ(Строка);
        Сущность.Вставить("МинимальныйОтступ", ТекущийОтступ + 1);
        ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
        Если ДанныеУправляющегоСимвола.Символ = ":" Тогда // Это объект
            Сущность.Вставить("ТипОбъекта", "Объект");
            Сущность.Вставить("ИмяОбъекта", СокрЛП(Лев(Строка, ДанныеУправляющегоСимвола.Позиция - 1)));
            МодифицированнаяСтрока = ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, ДанныеУправляющегоСимвола.Позиция);
            СледующийУправляющийСимвол = НайтиУправляющийСимволИЕгоПозицию(МодифицированнаяСтрока);
            Если СледующийУправляющийСимвол.Позиция > 0 
                    и СледующийУправляющийСимвол.Символ <> "&" 
                    и СледующийУправляющийСимвол.Символ <> "*" Тогда
                ВызватьИсключение "Найдено несколько управляющих символов в строке: " + Строка;
            КонецЕсли;
        ИначеЕсли ДанныеУправляющегоСимвола.Символ = "-" Тогда // Это элемент массива
            Сущность.Вставить("ТипОбъекта", "ЭлементМассива");
            Сущность.Вставить("ИмяОбъекта", "ЭлементМассива");
            МодифицированнаяСтрока = ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, ДанныеУправляющегоСимвола.Позиция);
        Иначе
            ВызватьИсключение "Не удалось выделить управляющий символ в строке: " + Строка;
            
        КонецЕсли;
        
        ПроверитьВалидностьСущности(Сущность, МассивСущностей);

        Строки[Индекс] = МодифицированнаяСтрока; // Обновим строку с отступом
        СтрокиСодержимого = ВыделитьСодержимое(Строки, Индекс, ТекущийОтступ);
        
        Сущность.Вставить("Содержимое", СтрокиСодержимого);
        Индекс = Индекс + СтрокиСодержимого.Количество() - 1;

        МассивСущностей.Добавить(Сущность);
    КонецЦикла;
    
    Возврат МассивСущностей;
КонецФункции

Функция ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, Позиция)
    
    Отступ = "";
    Пока СтрДлина(Отступ) < Позиция Цикл
        Отступ = Отступ + " ";
    КонецЦикла;
    ПолучившаясяСтрока = Отступ + Сред(Строка, Позиция + 1);
    Возврат ПолучившаясяСтрока;
КонецФункции

Процедура ПроверитьВалидностьСущности(Сущность, МассивСущностей)
    
    Если МассивСущностей.Количество() = 0 Тогда
        Возврат; // Если массив пустой, то валидность не проверяем
    КонецЕсли;
    ПервыйОбъект = МассивСущностей[0];
    
    Если НЕ Сущность.МинимальныйОтступ = ПервыйОбъект.МинимальныйОтступ Тогда
        ТекстОшибки = СтрШаблон(
                "Отступ <%1> отличается от требуемого <%2>. Все сущности должны иметь одинаковый отступ.",
                Сущность.МинимальныйОтступ - 1, ПервыйОбъект.МинимальныйОтступ - 1);
        ВызватьИсключение ТекстОшибки;
    КонецЕсли;
    
    Если НЕ Сущность.ТипОбъекта = ПервыйОбъект.ТипОбъекта Тогда
        ТекстОшибки = СтрШаблон(
                "Тип сущности <%1> отличается от требуемого <%2>. Все сущности должны иметь одинаковый тип.",
                Сущность.ТипОбъекта, ПервыйОбъект.ТипОбъекта);
        ВызватьИсключение ТекстОшибки;
    КонецЕсли;

КонецПроцедуры

// Функция для выделения содержимого из строк
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//   Индекс - Число - индекс строки для анализа
//   ТекущийОтступ - Число - минимальный отступ для выделения содержимого
//
// Возвращаемое значение:
//   Массив - массив строк, содержащих выделенное содержимое
//
Функция ВыделитьСодержимое(Строки, Индекс, ТекущийОтступ)
    
    Содержимое = Новый Массив();
    Для НомерСтроки = Индекс По Строки.Количество() - 1 Цикл
        Строка = Строки[НомерСтроки];
        Сообщить("Обрабатываем строку: " + Строка + " с отступом " + ТекущийОтступ);
        Если ОпределитьОтступ(Строка) > ТекущийОтступ ИЛИ ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Сообщить("  Найдено содержимое: " + Строка);
            Содержимое.Добавить(Строка);
        Иначе
            Прервать;
        КонецЕсли;
    КонецЦикла;
    
    Возврат Содержимое;
КонецФункции

Функция ОпределитьОтступ(Строка)
    // Определяем отступ в строке
    Отступ = 0;
    Для а = 1 По СтрДлина(Строка) Цикл
        Символ = Сред(Строка, а, 1);
        Если Символ = " " Тогда
            Отступ = Отступ + 1;
        Иначе
            Прервать; // Прерываем цикл при первом не-пробельном символе
        КонецЕсли;
    КонецЦикла;
    
    Возврат Отступ;
КонецФункции

Функция ДесериализоватьJSON(СтрокаJSON)
    
    Попытка
        ЧтениеJSON = Новый ЧтениеJSON();
        ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
        Результат = ПрочитатьJSON(ЧтениеJSON);
        ЧтениеJSON.Закрыть();
        Возврат Результат;
    Исключение
        // Если не удалось десериализовать как JSON, возвращаем как строку
        Возврат СтрокаJSON;
    КонецПопытки;
    
КонецФункции

// Парсер многострочных строк
//
// Параметры:
//   МассивСтрок - Массив - массив строк для парсинга многострочной строки
//
// Возвращаемое значение:
//   Строка - результат парсинга многострочной строки
//
Функция ПарсерМногострочныхСтрок(МассивСтрок)
    
    // Определяем параметры многострочной строки
    ПараметрыМногострочнойСтроки = НайтиПараметрыМногострочнойСтроки(МассивСтрок);
    
    Если ПараметрыМногострочнойСтроки = Неопределено Тогда
        Возврат ""; // Не найден управляющий символ, возвращаем пустую строку
    КонецЕсли;
    
    // Извлекаем строки содержимого
    СтрокиСодержимого = ИзвлечьСодержимоеМногострочнойСтроки(МассивСтрок, ПараметрыМногострочнойСтроки);
    
    // Обрабатываем пустые строки в конце если необходимо
    СтрокиСодержимого = ОбработатьПустыеСтрокиВКонце(СтрокиСодержимого, ПараметрыМногострочнойСтроки);
    
    // Собираем финальную строку
    Возврат СобратьМногострочнуюСтроку(СтрокиСодержимого, ПараметрыМногострочнойСтроки);
    
КонецФункции

// Находит параметры многострочной строки по управляющим символам
//
// Параметры:
//   МассивСтрок - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Структура - параметры многострочной строки или Неопределено
//
Функция НайтиПараметрыМногострочнойСтроки(МассивСтрок)
    
    Для Индекс = 0 По МассивСтрок.Количество() - 1 Цикл
        Строка = МассивСтрок[Индекс];
        
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) тогда
            Продолжить; // Пропускаем пустые строки и комментарии
        КонецЕсли;
        
        ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
        
        Если НЕ (ДанныеУправляющегоСимвола.Символ = "|" ИЛИ ДанныеУправляющегоСимвола.Символ = ">") тогда
            ВызватьИсключение "Ожидался управляющий символ многострочной строки, но найдено: " + Строка;
        КонецЕсли;
        
        УправляющийПодсимвол = ПолучитьУправляющийПодсимвол(Строка, ДанныеУправляющегоСимвола.Позиция + 1);
        
        // Определяем отступ для содержимого
        ОтступСодержимого = 0;
        Если Индекс + 1 < МассивСтрок.Количество() Тогда
            ОтступСодержимого = ОпределитьОтступ(МассивСтрок[Индекс + 1]);
        КонецЕсли;
        
        Параметры = Новый Структура();
        Параметры.Вставить("ТипСтроки", ДанныеУправляющегоСимвола.Символ); // "|" или ">"
        Параметры.Вставить("СохранятьПустыеСтрокиВКонце", УправляющийПодсимвол = "+");
        Параметры.Вставить("ДобавлятьПереносПоследнейСтроки", УправляющийПодсимвол <> "-");
        Параметры.Вставить("ИндексНачалаСодержимого", Индекс + 1);
        Параметры.Вставить("ОтступСодержимого", ОтступСодержимого);
        
        Возврат Параметры;
    КонецЦикла;
    
    Возврат Неопределено; // Управляющий символ не найден
    
КонецФункции

// Извлекает строки содержимого многострочной строки
//
// Параметры:
//   МассивСтрок - Массив - исходный массив строк
//   Параметры - Структура - параметры многострочной строки
//
// Возвращаемое значение:
//   Массив - массив строк содержимого
//
Функция ИзвлечьСодержимоеМногострочнойСтроки(МассивСтрок, Параметры)
    
    СтрокиСодержимого = Новый Массив();
    
    Для Индекс = Параметры.ИндексНачалаСодержимого По МассивСтрок.Количество() - 1 Цикл
        ИсходнаяСтрока = МассивСтрок[Индекс];
        
        // Убираем отступ с учетом базового отступа содержимого
        СтрокаБезОтступа = Сред(ИсходнаяСтрока, Параметры.ОтступСодержимого + 1);
        СтрокиСодержимого.Добавить(СтрокаБезОтступа);
    КонецЦикла;
    
    Возврат СтрокиСодержимого;
    
КонецФункции

// Обрабатывает пустые строки в конце массива строк
//
// Параметры:
//   СтрокиСодержимого - Массив - строки содержимого
//   Параметры - Структура - параметры многострочной строки
//
// Возвращаемое значение:
//   Массив - обработанный массив строк
//
Функция ОбработатьПустыеСтрокиВКонце(СтрокиСодержимого, Параметры)
    
    Если Параметры.СохранятьПустыеСтрокиВКонце Тогда
        Возврат СтрокиСодержимого; // Сохраняем все строки как есть
    КонецЕсли;
    
    // Удаляем пустые строки с конца
    Пока СтрокиСодержимого.Количество() > 0 
        И СокрЛП(СтрокиСодержимого[СтрокиСодержимого.Количество() - 1]) = "" Цикл
        СтрокиСодержимого.Удалить(СтрокиСодержимого.Количество() - 1);
    КонецЦикла;
    
    Возврат СтрокиСодержимого;
    
КонецФункции

// Собирает финальную многострочную строку
//
// Параметры:
//   СтрокиСодержимого - Массив - строки содержимого
//   Параметры - Структура - параметры многострочной строки
//
// Возвращаемое значение:
//   Строка - собранная многострочная строка
//
Функция СобратьМногострочнуюСтроку(СтрокиСодержимого, Параметры)
    
    Если СтрокиСодержимого.Количество() = 0 Тогда
        Возврат "";
    КонецЕсли;
    
    // Определяем разделитель строк в зависимости от типа
    Разделитель = ?(Параметры.ТипСтроки = "|", Символы.ПС, " ");
    
    // Соединяем строки разделителем
    РезультирующаяСтрока = СтрСоединить(СтрокиСодержимого, Разделитель);
    
    // Заменяем двойные пробелы на переносы строк для блочного стиля
    Если Параметры.ТипСтроки = ">" Тогда
        РезультирующаяСтрока = СтрЗаменить(РезультирующаяСтрока, "  ", Символы.ПС);
    КонецЕсли;
    
    // Добавляем перенос строки в конце если необходимо
    Если Параметры.ДобавлятьПереносПоследнейСтроки Тогда
        РезультирующаяСтрока = РезультирующаяСтрока + Символы.ПС;
    КонецЕсли;
    
    Возврат РезультирующаяСтрока;
    
КонецФункции

Функция ПолучитьУправляющийПодсимвол(Строка, Позиция)
    Если СтрДлина(Строка) < Позиция Тогда
        Возврат ""; // Нет подсимвола, возвращаем пустую строку
    КонецЕсли;
    Возврат Сред(Строка, Позиция, 1);
КонецФункции

// Находит параметры якоря по управляющему символу &
//
// Параметры:
//   МассивСтрок - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Структура - параметры якоря или Неопределено
//
Функция НайтиПараметрыЯкоря(МассивСтрок)
    
    Для Индекс = 0 По МассивСтрок.Количество() - 1 Цикл
        Строка = МассивСтрок[Индекс];
        
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) тогда
            Продолжить; // Пропускаем пустые строки и комментарии
        КонецЕсли;
        
        ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
        
        Если НЕ ДанныеУправляющегоСимвола.Символ = "&" тогда
            ВызватьИсключение "Ожидался управляющий символ якоря (&), но найдено: " + Строка;
        КонецЕсли;
        
        
        // Извлекаем имя якоря
        ИмяЯкоря = МенеджерЯкорей.ИзвлечьИмяЯкоряИлиАлиаса(Строка);
        Если ПустаяСтрока(ИмяЯкоря) Тогда
            ВызватьИсключение "Не удалось извлечь имя якоря из строки: " + Строка;
        КонецЕсли;
        
        Параметры = Новый Структура();
        Параметры.Вставить("ИмяЯкоря", ИмяЯкоря);
        Параметры.Вставить("ИндексСтрокиСЯкорем", Индекс);
        
        Возврат Параметры;
    КонецЦикла;
    
    Возврат Неопределено; // Управляющий символ якоря не найден
    
КонецФункции

// Извлекает строки содержимого якоря (убирает строку с определением якоря)
//
// Параметры:
//   МассивСтрок - Массив - исходный массив строк
//   Параметры - Структура - параметры якоря
//
// Возвращаемое значение:
//   Массив - массив строк содержимого без определения якоря
//
Функция ИзвлечьСодержимоеЯкоря(МассивСтрок, Параметры)
    
    СтрокиСодержимого = Новый Массив();
    
    // Обрабатываем строку с якорем - убираем определение якоря
    СтрокаСЯкорем = МассивСтрок[Параметры.ИндексСтрокиСЯкорем];
    ОчищеннаяСтрока = МенеджерЯкорей.УдалитьОпределениеЯкоря(СтрокаСЯкорем);
   
    СтрокиСодержимого.Добавить(ОчищеннаяСтрока);
   
    
    // Добавляем все остальные строки
    Для Индекс = Параметры.ИндексСтрокиСЯкорем + 1 По МассивСтрок.Количество() - 1 Цикл
        СтрокиСодержимого.Добавить(МассивСтрок[Индекс]);
    КонецЦикла;

    Возврат СтрокиСодержимого;
    
КонецФункции