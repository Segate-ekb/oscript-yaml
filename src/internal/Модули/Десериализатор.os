////////////////////////////////////////////////////////////////////////////////
// Модуль для десериализации YAML документов
// 
// Поддерживает парсинг различных типов YAML структур:
// - Объекты (соответствия)
// - Массивы 
// - Скалярные значения
// - Многострочные строки
// - Flow-синтаксис (объекты и массивы)
// - Якоря и алиасы
////////////////////////////////////////////////////////////////////////////////

#Использовать logos

// Логгер для отладочной информации
Перем лог;

////////////////////////////////////////////////////////////////////////////////
// ФАБРИКА СТРУКТУР
////////////////////////////////////////////////////////////////////////////////

// Константы YAML символов
// Разделитель документов в YAML
Перем YAML_РАЗДЕЛИТЕЛЬ_ДОКУМЕНТА;
// Терминатор документов в YAML  
Перем YAML_ТЕРМИНАТОР_ДОКУМЕНТА;

// Константы для обработки строк
Перем МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ; // = 2
// Константы для действий при обработке строк
Перем ДЕЙСТВИЕ_ПРЕРВАТЬ; // = "прервать"
// Сообщения об ошибках
Перем ОШИБКА_ЛИШНИЕ_ЗАПЯТЫЕ_FLOW; // = "Flow последовательность содержит лишние запятые"

// Создает структуру результата обработки документа
//
// Параметры:
//   Документ - Массив - документ для возврата
//
// Возвращаемое значение:
//   Структура - структура с полем Документ
//
Функция СоздатьРезультатОбработкиДокумента(Документ)
    Возврат Новый Структура("Документ", Документ);
КонецФункции

// Создает структуру для управляющего символа и его позиции
//
// Параметры:
//   Символ - Строка - найденный символ
//   Позиция - Число - позиция символа
//
// Возвращаемое значение:
//   Структура - структура с полями Символ и Позиция
//
Функция СоздатьСтруктуруУправляющегоСимвола(Символ = "", Позиция = 0)
    Возврат Новый Структура("Символ, Позиция", Символ, Позиция);
КонецФункции

// Создает структуру результата обработки сущности
//
// Параметры:
//   Сущность - Структура - обработанная сущность
//   НовыйИндекс - Число - новый индекс для продолжения обработки
//
// Возвращаемое значение:
//   Структура - структура с полями Сущность и НовыйИндекс
//
Функция СоздатьРезультатОбработкиСущности(Сущность, НовыйИндекс)
    Возврат Новый Структура("Сущность, НовыйИндекс", Сущность, НовыйИндекс);
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПУБЛИЧНЫЕ МЕТОДЫ
////////////////////////////////////////////////////////////////////////////////

// Основная функция для десериализации YAML
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для парсинга
//
// Возвращаемое значение:
//   Массив - массив распарсенных документов YAML
//
// Исключения:
//   При некорректном синтаксисе YAML
//
Функция Прочитать(СтрокаYaml) Экспорт
    Лог.Отладка("Начало десериализации YAML");
    Если ПустаяСтрока(СтрокаYaml) Тогда
        Лог.Отладка("Входная строка YAML пуста, возвращаем пустое соответствие");
        Возврат Новый Соответствие();
    КонецЕсли;
    
    Лог.Отладка("Инициализация менеджера якорей");
    МенеджерЯкорей.Инициализировать();
    
    // Разбиваем на строки
    Строки = СтрРазделить(СтрокаYaml, Символы.ПС);
    Лог.Отладка("Строка YAML разбита на " + Строки.Количество() + " строк");
    
    МассивДокументов = Новый Массив();
    МассивСтрокДокументов = РазбитьНаДокументы(Строки);
    Лог.Отладка("Найдено " + МассивСтрокДокументов.Количество() + " документов YAML");
    
    Для каждого СтрокиДокумента Из МассивСтрокДокументов Цикл
        Лог.Отладка("Обработка документа с " + СтрокиДокумента.Количество() + " строками");
        МассивДокументов.Добавить(ДанныеИзМассиваСтрок(СтрокиДокумента));
    КонецЦикла;
    
    Лог.Отладка("Десериализация YAML завершена успешно");
    Возврат МассивДокументов;
    
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МЕТОДЫ РАБОТЫ С ДОКУМЕНТАМИ
////////////////////////////////////////////////////////////////////////////////

// Разбивает массив строк на отдельные YAML документы
//
// Параметры:
//   МассивСтрок - Массив - массив строк исходного YAML
//
// Возвращаемое значение:
//   Массив - массив документов, каждый документ представлен массивом строк
//
Функция РазбитьНаДокументы(МассивСтрок)
    Лог.Отладка("Начало разбиения на документы");
    МассивСтрокДокументов = Новый Массив();
    Документ = Новый Массив();
    
    Для Каждого Строка Из МассивСтрок Цикл
        Результат = ОбработатьСтрокуДокумента(Строка, Документ, МассивСтрокДокументов);
        Документ = Результат.Документ;
    КонецЦикла;
    
    Если Не Документ = Неопределено и Документ.Количество() > 0 Тогда
        МассивСтрокДокументов.Добавить(Документ);
    КонецЕсли;
    
    Лог.Отладка("Разбиение на документы завершено, найдено " + МассивСтрокДокументов.Количество() + " документов");
    Возврат МассивСтрокДокументов;
КонецФункции

// Обрабатывает одну строку документа
//
// Параметры:
//   Строка - Строка - обрабатываемая строка
//   Документ - Массив - текущий документ
//   МассивСтрокДокументов - Массив - массив всех документов
//
// Возвращаемое значение:
//   Структура - результат обработки с полем Документ
//
Функция ОбработатьСтрокуДокумента(Строка, Документ, МассивСтрокДокументов)
    
    Если СтрНачинаетсяС(СокрЛП(Строка), YAML_РАЗДЕЛИТЕЛЬ_ДОКУМЕНТА) Тогда
        Лог.Отладка("Найден разделитель документа " + YAML_РАЗДЕЛИТЕЛЬ_ДОКУМЕНТА);
        Документ = ОбработатьРазделительДокумента(Строка, Документ, МассивСтрокДокументов);
    ИначеЕсли СтрНачинаетсяС(СокрЛП(Строка), YAML_ТЕРМИНАТОР_ДОКУМЕНТА) Тогда
        Лог.Отладка("Найден терминатор документа " + YAML_ТЕРМИНАТОР_ДОКУМЕНТА);
        Документ = ОбработатьТерминаторДокумента(Документ, МассивСтрокДокументов);
    Иначе
        Документ = ОбработатьОбычнуюСтроку(Строка, Документ);
    КонецЕсли;
    
    Результат = СоздатьРезультатОбработкиДокумента(Документ);
    Возврат Результат;
    
КонецФункции

// Обрабатывает разделитель документа ---
//
// Параметры:
//   Строка - Строка - строка с разделителем
//   Документ - Массив - текущий документ
//   МассивСтрокДокументов - Массив - массив всех документов
//
// Возвращаемое значение:
//   Массив - новый документ
//
Функция ОбработатьРазделительДокумента(Строка, Документ, МассивСтрокДокументов)
    
    // Конец документа, сохраняем текущий и начинаем новый
    Если Документ <> Неопределено И Документ.Количество() > 0 Тогда
        МассивСтрокДокументов.Добавить(Документ);
    КонецЕсли;
    
    Документ = Новый Массив();
    Строка = СтрЗаменить(Строка, YAML_РАЗДЕЛИТЕЛЬ_ДОКУМЕНТА, "");
    Если Не ПустаяСтрока(СокрЛП(Строка)) Тогда
        Документ.Добавить(Строка);
    КонецЕсли;
    
    Возврат Документ;
    
КонецФункции

// Обрабатывает терминатор документа ...
//
// Параметры:
//   Документ - Массив - текущий документ
//   МассивСтрокДокументов - Массив - массив всех документов
//
// Возвращаемое значение:
//   Массив - новый документ (Неопределено если вне документа)
//
Функция ОбработатьТерминаторДокумента(Документ, МассивСтрокДокументов)
    
    // Конец текущего документа
    Если Документ <> Неопределено И Документ.Количество() > 0 Тогда
        МассивСтрокДокументов.Добавить(Документ);
    КонецЕсли;
    Документ = Неопределено; // Переходим в состояние вне документа
    
    Возврат Документ;
    
КонецФункции

// Обрабатывает обычную строку
//
// Параметры:
//   Строка - Строка - обрабатываемая строка
//   Документ - Массив - текущий документ
//
// Возвращаемое значение:
//   Массив - документ с добавленной строкой
//
Функция ОбработатьОбычнуюСтроку(Строка, Документ)
    
    Если Документ = Неопределено Тогда
        Если ЭтоПустаяСтрокаПослеОбрезки(Строка) Тогда
            Возврат Документ; // мы вне документа, может там после и есть что-то, но эти строки нам не нужны
        КонецЕсли;
        
        // Проверяем, является ли строка YAML-директивой
        СтрокаБезПробелов = СокрЛП(Строка);
        Если СтрНачинаетсяС(СтрокаБезПробелов, "%YAML") 
             ИЛИ СтрНачинаетсяС(СтрокаБезПробелов, "%TAG") Тогда
            // Директивы YAML игнорируем вне документа
            Возврат Документ;
        КонецЕсли;
        
        Лог.Ошибка("Найдено содержимое вне документа YAML: " + Строка);
        ВызватьИсключение "Найдено содержимое вне документа YAML: " + Строка;
    КонецЕсли;   

    Документ.Добавить(Строка);
    
    Возврат Документ;
    
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МЕТОДЫ РАБОТЫ СО СТРОКАМИ И КОММЕНТАРИЯМИ
////////////////////////////////////////////////////////////////////////////////

// Очистка строк от комментариев и пустых строк
//
// Параметры:
//   Строки - Массив - массив строк для очистки
//
// Возвращаемое значение:
//   Массив - очищенный массив строк
//
Функция ОчиститьСтроки(Строки)
    
    ОчищенныеСтроки = Новый Массив();
    
    Для Каждого Строка Из Строки Цикл
        ОчищеннаяСтрока = УбратьКомментарийИзСтроки(СокрЛП(Строка));
        ОчищенныеСтроки.Добавить(ОчищеннаяСтрока);
    КонецЦикла;
    
    Возврат ОчищенныеСтроки;
    
КонецФункции

// Проверка, является ли строка пустой или комментарием
// Параметры:
//   Строка - Строка - строка для проверки
// Возвращаемое значение:
//   Булево - Истина, если строка пустая или комментарий
//
Функция ЭтоПустаяСтрокаИлиКомментарий(Знач Строка)
    Если ЭтоПустаяСтрокаПослеОбрезки(Строка) ИЛИ Лев(СокрЛП(Строка), 1) = "#" Тогда
        Возврат Истина;
    КонецЕсли;
    
    Возврат Ложь;
КонецФункции

// Убирает комментарий из строки, если она на него заканчивается
// Параметры:
//   Строка - Строка - строка для очистки
// Возвращаемое значение:
//   Строка - очищенная строка без комментариев
//
Функция УбратьКомментарийИзСтроки(Знач Строка)
    // Ищем позицию комментария неэкранированного символа #,
    // т.е. пропускаем символы в кавычках и тд.
    
    ПозицияКомментария = ПозицияНеЭкранированногоСимвола(Строка, "#");
    
    Если ПозицияКомментария = 0 Тогда
        Возврат Строка;
    КонецЕсли;

    Возврат Лев(Строка, ПозицияКомментария - 1);
КонецФункции

// Очищает строку от комментариев и пробелов, возвращает обрезанную строку
// 
// Параметры:
//   Строка - Строка - исходная строка для очистки
//
// Возвращаемое значение:
//   Строка - очищенная от комментариев и обрезанная строка
//
Функция ОчиститьСтрокуОтКомментариев(Знач Строка)
    Возврат СокрЛП(УбратьКомментарийИзСтроки(Строка));
КонецФункции

// Добавляет значение в массив строк, если оно не пустое
//
// Параметры:
//   МассивСтрок - Массив - массив для добавления
//   Значение - Строка - значение для добавления
//
Процедура ДобавитьНепустоеЗначение(МассивСтрок, Знач Значение)
    Если НЕ ПустаяСтрока(Значение) Тогда
        МассивСтрок.Добавить(Значение);
    КонецЕсли;
КонецПроцедуры

// Парсит значение из массива строк с учетом особенностей YAML
//
// Параметры:
//   СтрокиЗначения - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Произвольный - результат парсинга YAML значения
//
Функция СпарситьЗначениеИзМассиваСтрок(СтрокиЗначения)
    Если СтрокиЗначения.Количество() = 0 Тогда
        Возврат Неопределено;
    ИначеЕсли СтрокиЗначения.Количество() = 1 И ТипЗнч(СтрокиЗначения[0]) = Тип("Строка") Тогда
        // Одна строка - создаем массив из одной строки и парсим
        МассивОднойСтроки = Новый Массив();
        МассивОднойСтроки.Добавить(СтрокиЗначения[0]);
        Возврат ДанныеИзМассиваСтрок(МассивОднойСтроки);
    Иначе
        Возврат ДанныеИзМассиваСтрок(СтрокиЗначения);
    КонецЕсли;
КонецФункции

// Проверяет строку на наличие табуляции после двоеточия
//
// Параметры:
//   СтрокаБезОтступов - Строка - строка для проверки
//
Процедура ПроверитьОтсутствиеТабуляцииПослеДвоеточия(СтрокаБезОтступов)
    Если СтрДлина(СтрокаБезОтступов) > 1 И Сред(СтрокаБезОтступов, МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ, 1) = Символы.Таб Тогда
        ВызватьИсключение("YAML Error: Использование символов табуляции после двоеточия запрещено спецификацией YAML");
    КонецЕсли;
КонецПроцедуры

// Извлекает значение после двоеточия в начале строки
//
// Параметры:
//   СтрокаБезОтступов - Строка - строка с двоеточием в начале
//
// Возвращаемое значение:
//   Строка - значение после двоеточия без пробелов
//
Функция ИзвлечьЗначениеПослеДвоеточия(СтрокаБезОтступов)
    Возврат УдалитьПервыйСимволСОчисткой(СтрокаБезОтступов);
КонецФункции

// Проверяет, является ли строка пустой после удаления пробелов
//
// Параметры:
//   Строка - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если строка пуста после обрезки пробелов
//
Функция ЭтоПустаяСтрокаПослеОбрезки(Строка)
    Возврат СокрЛП(Строка) = "";
КонецФункции

// Обрабатывает escape-последовательности в строке
//
// Параметры:
//   Строка - Строка - строка для обработки
//   ТипКавычек - Строка - тип кавычек ("double" для двойных, "single" для одинарных)
//
// Возвращаемое значение:
//   Строка - строка с обработанными escape-последовательностями
//
Функция ОбработатьEscapeПоследовательности(Строка, ТипКавычек)
    Результат = Строка;
    
    Если ТипКавычек = "double" Тогда
        // Заменяем экранированные символы в двойных кавычках
        Результат = СтрЗаменить(Результат, "\""", """");
        Результат = СтрЗаменить(Результат, "\\", "\");
        Результат = СтрЗаменить(Результат, "\/", "/");
        Результат = СтрЗаменить(Результат, "\n", Символы.ПС);
        Результат = СтрЗаменить(Результат, "\t", Символы.Таб);
        Результат = СтрЗаменить(Результат, "\r", Символы.ВК);
    ИначеЕсли ТипКавычек = "single" Тогда
        // Заменяем экранированные символы в одинарных кавычках
        Результат = СтрЗаменить(Результат, "''", "'");
    Иначе
        // Если тип кавычек не определен, возвращаем строку без изменений
        Результат = Строка;
    КонецЕсли;
    
    Возврат Результат;
КонецФункции

// Удаляет первый и последний символы из строки
//
// Параметры:
//   Строка - Строка - строка для обработки
//
// Возвращаемое значение:
//   Строка - строка без первого и последнего символов
//
Функция УдалитьПервыйИПоследнийСимволы(Строка)
    Если СтрДлина(Строка) <= МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ Тогда
        Возврат "";
    КонецЕсли;
    
    Возврат Сред(Строка, МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ, СтрДлина(Строка) - МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ);
КонецФункции

// Извлекает и очищает значение после двоеточия в строке
//
// Параметры:
//   Строка - Строка - строка содержащая двоеточие
//   ПозицияДвоеточия - Число - позиция двоеточия в строке
//
// Возвращаемое значение:
//   Строка - очищенное значение после двоеточия
//
Функция ИзвлечьЗначениеПослеДвоеточияСОчисткой(Строка, ПозицияДвоеточия)
    Возврат СокрЛП(Сред(Строка, ПозицияДвоеточия + 1));
КонецФункции

// Удаляет первый символ из строки и очищает от пробелов
//
// Параметры:
//   Строка - Строка - строка для обработки
//
// Возвращаемое значение:
//   Строка - очищенная строка без первого символа
//
Функция УдалитьПервыйСимволСОчисткой(Строка)
    Возврат СокрЛП(Сред(Строка, МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ));
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МЕТОДЫ ОПРЕДЕЛЕНИЯ ТИПОВ ДАННЫХ
////////////////////////////////////////////////////////////////////////////////

// Определение типа содержимого строки
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Строка - тип содержимого: "Объект", "Массив", "FlowПоследовательность", 
//     "FlowОбъект", "МногострочнаяСтрока", Неопределено
//
Функция ОпределитьТипСодержимого(Строки)
    Лог.Отладка("Определение типа содержимого для " + Строки.Количество() + " строк");
    
    Для Каждого Строка Из Строки Цикл
        
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Продолжить;
        КонецЕсли;
        // Если это не пустая строка, то управляющий символ должен быть в ней.
        // Если мы не нашли его, то это Строка или число, или что-то другое.
        ТипДанных = НайтиТипДанныхПоСтроке(Строка);
        Лог.Отладка("Определен тип содержимого: " + ТипДанных + " по строке: " + Строка);
        Возврат ТипДанных;
    КонецЦикла;
    
    Лог.Предупреждение("Не найдено ни одной строки с данными");
    Возврат Неопределено; // Если не найдено ни одной строки с данными - возвращаем неопределено.
    
КонецФункции

// Определяет тип данных по строке
// Параметры:
//   Строка - Строка - строка для анализа
// Возвращаемое значение:
//   Строка - тип данных: "Объект", "Массив", "FlowПоследовательность", "FlowОбъект", "МногострочнаяСтрока"
Функция НайтиТипДанныхПоСтроке(Знач Строка)
    ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
    
    Если ДанныеУправляющегоСимвола.Позиция = 0 Тогда
        Лог.Отладка("Управляющий символ не найден, определен как скаляр");
        Возврат "Скаляр";
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "[" Тогда
        Лог.Отладка("Найден символ flow последовательности: [");
        Возврат "FlowПоследовательность";
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "{" Тогда
        Лог.Отладка("Найден символ flow объекта: {");
        Возврат "FlowОбъект";
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = ":" Тогда
        Лог.Отладка("Найден символ объекта: :");
        Возврат "Объект";
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "-" Тогда
        Лог.Отладка("Найден символ массива: -");
        Возврат "Массив"; // Массив начинается с тире и пробела
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "|" ИЛИ ДанныеУправляющегоСимвола.Символ = ">" Тогда
        Лог.Отладка("Найден символ многострочной строки: " + ДанныеУправляющегоСимвола.Символ);
        Возврат "МногострочнаяСтрока"; // Многострочная строка начинается с | или >
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "&" Тогда
        Лог.Отладка("Найден символ якоря: &");
        Возврат "Якорь"; // Якорь начинается с &
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "*" Тогда
        Лог.Отладка("Найден символ алиаса: *");
        Возврат "Алиас";      
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "?" Тогда
        Лог.Отладка("Найден символ явного ключа: ?");
        Возврат "Объект"; // Явный ключ обрабатывается как объект
    Иначе
        // Если не найдено ни одного управляющего символа, то это может быть строка или число
        Лог.Ошибка("Не удалось определить тип данных в строке: " + Строка);
        ВызватьИсключение "Не удалось определить тип данных в строке: " + Строка;
    КонецЕсли;
    
КонецФункции

// Создает массив управляющих символов YAML
//
// Возвращаемое значение:
//   Массив - массив управляющих символов
Функция СоздатьМассивУправляющихСимволов()
    МассивУправляющихСимволов = Новый Массив;
    МассивУправляющихСимволов.Добавить(":"); // Двоеточие для объектов
    МассивУправляющихСимволов.Добавить("-"); // Тире для массивов
    МассивУправляющихСимволов.Добавить("?"); // Знак вопроса для явных ключей
    МассивУправляющихСимволов.Добавить("|"); // Вертикальная черта для многострочных строк
    МассивУправляющихСимволов.Добавить(">"); // Знак больше для многострочных строк
    МассивУправляющихСимволов.Добавить("&"); // Символ для определения якоря
    МассивУправляющихСимволов.Добавить("*"); // Символ для алиасов
    МассивУправляющихСимволов.Добавить("{"); // Открывающая фигурная скобка для объектов
    МассивУправляющихСимволов.Добавить("["); // Открывающая квадратная скобка для массивов
    
    Возврат МассивУправляющихСимволов;
КонецФункции

// Проверяет корректность позиции знака вопроса
//
// Параметры:
//   Строка - Строка - исходная строка
//   Позиция - Число - позиция символа
//
// Возвращаемое значение:
//   Булево - Истина, если позиция корректна
Функция ПроверитьПозициюЗнакаВопроса(Строка, Позиция)
    ОтступСтроки = ОпределитьОтступ(Строка);
    // Знак вопроса считается управляющим только если он идет сразу после отступа
    Возврат Позиция = ОтступСтроки + 1;
КонецФункции

// Проверяет недопустимые табы после структурных символов
//
// Параметры:
//   Строка - Строка - исходная строка
//   Символ - Строка - структурный символ
//   Позиция - Число - позиция символа
Процедура ПроверитьТабыПослеСтруктурныхСимволов(Строка, Символ, Позиция)
    // Проверка на табы после структурных символов только в начале строки
    // (после отступа) - запрещено YAML спецификацией
    Если НЕ (Символ = "?" ИЛИ Символ = ":") ИЛИ Позиция >= СтрДлина(Строка) Тогда
        Возврат;
    КонецЕсли;
    
    // Проверяем, что символ в начале строки (после пробелов)
    ОтступСтроки = ОпределитьОтступ(Строка);
    Если Позиция = ОтступСтроки + 1 Тогда // Символ сразу после отступа
        СледующийСимвол = Сред(Строка, Позиция + 1, 1);
        Если СледующийСимвол = Символы.Таб Тогда
            СообщениеОшибки = "YAML Error: Использование символов табуляции после структурных символов (" + Символ + 
                ") в начале строки запрещено спецификацией YAML";
            ВызватьИсключение(СообщениеОшибки);
        КонецЕсли;
    КонецЕсли;
КонецПроцедуры

Функция НайтиУправляющийСимволИЕгоПозицию(Знач Строка)

    СтруктураВозврата = СоздатьСтруктуруУправляющегоСимвола();
    МассивУправляющихСимволов = СоздатьМассивУправляющихСимволов();

    МинимальнаяНайденнаяПозиция = 9999999;
    Для каждого Символ Из МассивУправляющихСимволов Цикл
        НайденнаяПозиция = ПозицияНеЭкранированногоСимвола(Строка, Символ);
        Если НайденнаяПозиция > 0 И МинимальнаяНайденнаяПозиция > НайденнаяПозиция Тогда
            
            // Специальная проверка для знака вопроса - он должен быть в начале строки
            Если Символ = "?" И НЕ ПроверитьПозициюЗнакаВопроса(Строка, НайденнаяПозиция) Тогда
                Продолжить; // Пропускаем этот символ вопроса
            КонецЕсли;
            
            // Проверка на табы после структурных символов
            ПроверитьТабыПослеСтруктурныхСимволов(Строка, Символ, НайденнаяПозиция);
            
            СтруктураВозврата.Символ = Символ;
            СтруктураВозврата.Позиция = НайденнаяПозиция;
            МинимальнаяНайденнаяПозиция = НайденнаяПозиция;
        КонецЕсли;
    КонецЦикла;
    
    Возврат СтруктураВозврата;
КонецФункции

// Обрабатывает закрытие кавычек с учетом экранирования
//
// Параметры:
//   Строка - Строка - исходная строка
//   Позиция - Число - текущая позиция
//   Символ - Строка - текущий символ
//   ВКавычках - Булево - флаг нахождения в кавычках (изменяется)
//   ТипКавычек - Строка - тип кавычек (изменяется)
//
// Возвращаемое значение:
//   Булево - Истина, если символ обработан как закрывающая кавычка
//
Функция ОбработатьЗакрытиеКавычек(Строка, Позиция, Символ, ВКавычках, ТипКавычек)
    Если НЕ (ВКавычках И Символ = ТипКавычек) Тогда
        Возврат Ложь;
    КонецЕсли;
    
    // Проверяем, не является ли кавычка экранированной
    КоличествоЭкранирований = 0;
    ПредыдущаяПозиция = Позиция - 1;
    Пока ПредыдущаяПозиция >= 1 И Сред(Строка, ПредыдущаяПозиция, 1) = "\" Цикл
        КоличествоЭкранирований = КоличествоЭкранирований + 1;
        ПредыдущаяПозиция = ПредыдущаяПозиция - 1;
    КонецЦикла;
    
    // Если количество слешей четное, то кавычка не экранирована
    Если КоличествоЭкранирований % МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ = 0 Тогда
        ВКавычках = Ложь;
        ТипКавычек = "";
    КонецЕсли;
    
    Возврат Истина;
КонецФункции

// Проверяет можно ли открыть кавычки в данной позиции
//
// Параметры:
//   Строка - Строка - исходная строка
//   Позиция - Число - текущая позиция
//   Символ - Строка - текущий символ
//
// Возвращаемое значение:
//   Булево - Истина, если кавычки можно открыть
Функция МожноОткрытьКавычки(Строка, Позиция, Символ)
    Если НЕ (Символ = """" ИЛИ Символ = "'") Тогда
        Возврат Ложь;
    КонецЕсли;
    
    // Проверяем, что кавычка в начале строки или после пробела/tab
    ПредыдущийСимвол = "";
    Если Позиция > 1 Тогда
        ПредыдущийСимвол = Сред(Строка, Позиция - 1, 1);
    КонецЕсли;
    
    Возврат Позиция = 1 ИЛИ ПредыдущийСимвол = " " ИЛИ ПредыдущийСимвол = Символы.Таб;
КонецФункции

// Обрабатывает состояние кавычек для одного символа
//
// Параметры:
//   Строка - Строка - исходная строка
//   Позиция - Число - текущая позиция
//   Символ - Строка - текущий символ
//   ВКавычках - Булево - состояние кавычек (изменяется)
//   ТипКавычек - Строка - тип кавычек (изменяется)
//
// Возвращаемое значение:
//   Булево - Истина, если нужно перейти к следующему символу
Функция ОбработатьСостояниеКавычек(Строка, Позиция, Символ, ВКавычках, ТипКавычек)
    // Обработка открытия кавычек
    Если НЕ ВКавычках И МожноОткрытьКавычки(Строка, Позиция, Символ) Тогда
        ВКавычках = Истина;
        ТипКавычек = Символ;
        Возврат Истина; // Продолжить к следующему символу
    КонецЕсли;
    
    // Обработка закрытия кавычек
    Если ОбработатьЗакрытиеКавычек(Строка, Позиция, Символ, ВКавычках, ТипКавычек) Тогда
        Возврат Истина; // Продолжить к следующему символу
    КонецЕсли;
    
    Возврат Ложь; // Продолжить обработку символа
КонецФункции

Функция ПозицияНеЭкранированногоСимвола(Строка, ИскомыйСимвол, ЭтоFlowСтиль = Ложь)
    НайденнаяПозиция = 0;
    ВКавычках = Ложь;
    ТипКавычек = "";
    
    Для Позиция = 1 По СтрДлина(Строка) Цикл
        Символ = Сред(Строка, Позиция, 1);
        
        // Обработка состояния кавычек
        Если ОбработатьСостояниеКавычек(Строка, Позиция, Символ, ВКавычках, ТипКавычек) Тогда
            Продолжить;
        КонецЕсли;
        
        // Поиск символа (не в кавычках и с пробелом после)
        Если НЕ ВКавычках И Символ = ИскомыйСимвол Тогда
            Если ЭтоЗначащийСимвол(Строка, Позиция, ИскомыйСимвол, ЭтоFlowСтиль) Тогда
                НайденнаяПозиция = Позиция;
                Прервать;
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат НайденнаяПозиция;
КонецФункции

// Проверяет, является ли Символ Значащим
// (должно быть в конце строки или с пробелом/табом после него)
//
// Параметры:
//   Строка - Строка - строка для анализа
//   Позиция - Число - позиция Символа в строке
//   ИскомыйСимвол - Строка - символ, который мы ищем
//   ЭтоFlowСтиль - Булево - флаг обработки в flow-стиле (по умолчанию Ложь)
//
// Возвращаемое значение:
//   Булево - Истина, если Символ является разделителем ключ-значение
//

// Проверяет является ли символ "#" значащим комментарием
//
// Параметры:
//   Строка - Строка - исходная строка
//   Позиция - Число - позиция символа в строке
//
// Возвращаемое значение:
//   Булево - Истина, если символ является началом комментария
Функция ЭтоЗначащийКомментарий(Строка, Позиция)
    Если Не Позиция = 1 
        И Не (Сред(Строка, Позиция - 1, 1) = " " 
                Или Сред(Строка, Позиция - 1, 1) = Символы.Таб) Тогда
        Возврат Ложь;
    КонецЕсли;
    Возврат Истина;
КонецФункции

// Проверяет является ли двоеточие значащим в flow стиле
//
// Параметры:
//   Позиция - Число - позиция двоеточия в строке
//
// Возвращаемое значение:
//   Булево - Истина, если двоеточие является разделителем ключ-значение
Функция ЭтоЗначащееДвоеточиеВFlowСтиле(Позиция)
    // В flow стиле двоеточие должно быть разделителем ключ-значение
    // Не должно быть в начале строки как первый символ
    Если Позиция = 1 Тогда
        Возврат Ложь; // Двоеточие в начале не является разделителем
    КонецЕсли;
    
    Возврат Истина;
КонецФункции

// Проверяет является ли двоеточие значащим в блок стиле
//
// Параметры:
//   Строка - Строка - исходная строка
//   Позиция - Число - позиция двоеточия в строке
//
// Возвращаемое значение:
//   Булево - Истина, если двоеточие является разделителем ключ-значение
Функция ЭтоЗначащееДвоеточиеВБлокСтиле(Строка, Позиция)
    // В блок-стиле двоеточие должно иметь пробел после себя или быть в конце строки
    Если Позиция = СтрДлина(Строка) Тогда
        Возврат Истина; // Двоеточие в конце строки
    КонецЕсли;
    
    СледующийСимвол = Сред(Строка, Позиция + 1, 1);
    Возврат СледующийСимвол = " " ИЛИ СледующийСимвол = Символы.Таб;
КонецФункции

// Создает массив допустимых символов после искомого символа
//
// Параметры:
//   ЭтоМногострочнаяСтрока - Булево - флаг многострочной строки (|, >)
//
// Возвращаемое значение:
//   Массив - массив допустимых символов после искомого символа
Функция СоздатьМассивДопустимыхСимволов(ЭтоМногострочнаяСтрока)
    МассивДопустимыхСимволов = Новый Массив();
    МассивДопустимыхСимволов.Добавить(" "); // Пробел
    МассивДопустимыхСимволов.Добавить(Символы.Таб); // Табуляция
    
    Если ЭтоМногострочнаяСтрока Тогда
        МассивДопустимыхСимволов.Добавить("-");
        МассивДопустимыхСимволов.Добавить("+");
        Для Цифра = 0 По 9 Цикл
            МассивДопустимыхСимволов.Добавить(Строка(Цифра));
        КонецЦикла;
    КонецЕсли;
    
    Возврат МассивДопустимыхСимволов;
КонецФункции

Функция ЭтоЗначащийСимвол(Строка, Позиция, ИскомыйСимвол, ЭтоFlowСтиль = Ложь)

    Если ИскомыйСимвол = "#" Тогда
        Возврат ЭтоЗначащийКомментарий(Строка, Позиция);
    КонецЕсли;
    
    // Для двоеточия в flow стиле особая обработка
    Если ИскомыйСимвол = ":" И ЭтоFlowСтиль Тогда
        Возврат ЭтоЗначащееДвоеточиеВFlowСтиле(Позиция);
    КонецЕсли;
    
    // Для двоеточия в блок-стиле особая обработка
    Если ИскомыйСимвол = ":" И НЕ ЭтоFlowСтиль Тогда
        Возврат ЭтоЗначащееДвоеточиеВБлокСтиле(Строка, Позиция);
    КонецЕсли;
     
    ЭтоМногострочнаяСтрока = ИскомыйСимвол = "|" ИЛИ ИскомыйСимвол = ">";
    ЭтоЯкорьИлиАлиас = ИскомыйСимвол = "&" Или ИскомыйСимвол = "*";
    ЭтоНачалоFlowПоследовательности = ИскомыйСимвол = "{" Или ИскомыйСимвол = "[";
    
    Если ЭтоНачалоFlowПоследовательности Тогда
        // Для flow стиля проверяем, что символ находится в начале строки (после отступа)
        Возврат СтрНачинаетсяС(СокрЛП(Строка), ИскомыйСимвол);
    КонецЕсли;
    
    Если ЭтоЯкорьИлиАлиас Тогда
        Имя = МенеджерЯкорей.ИзвлечьИмяЯкоряИлиАлиаса(Строка);
        Возврат Не Имя = "";
    Иначе
        // Обработка других символов
        Если Позиция = СтрДлина(Строка) Тогда
            Возврат Истина; 
        КонецЕсли;
    КонецЕсли;
    
    МассивДопустимыхСимволов = СоздатьМассивДопустимыхСимволов(ЭтоМногострочнаяСтрока);
    СледующийСимвол = Сред(Строка, Позиция + 1, 1);
        
    ЭтоЗначащийСимвол = НЕ МассивДопустимыхСимволов.Найти(СледующийСимвол) = Неопределено;
    Возврат ЭтоЗначащийСимвол;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ОСНОВНЫЕ ПАРСЕРЫ ТИПОВ ДАННЫХ
////////////////////////////////////////////////////////////////////////////////

// Получает данные из массива строк
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Произвольный - результат парсинга
//
Функция ДанныеИзМассиваСтрок(Строки) 
    ТипСодержимого = ОпределитьТипСодержимого(Строки);
    Лог.Отладка("Обработка данных типа: " + ТипСодержимого);
    
    Если ТипСодержимого = "Объект" Тогда
        Возврат ПарсерОбъектов(Строки);
    ИначеЕсли ТипСодержимого = "Массив" Тогда
        Возврат ПарсерМассивов(Строки);
    ИначеЕсли ТипСодержимого = "FlowПоследовательность" Тогда
        Возврат ПарсерFlowПоследовательности(Строки);
    ИначеЕсли ТипСодержимого = "FlowОбъект" Тогда
        Возврат ПарсерFlowОбъекта(Строки);
    ИначеЕсли ТипСодержимого = "МногострочнаяСтрока" Тогда
        Возврат ПарсерМногострочныхСтрок(Строки);
    ИначеЕсли ТипСодержимого = "Якорь" Тогда
        Возврат ПарсерЯкорей(Строки);
    ИначеЕсли ТипСодержимого = "Алиас" Тогда
        Возврат ПарсерАлиасов(Строки);
    ИначеЕсли ТипСодержимого = "Скаляр" Тогда
        Лог.Отладка("Обработка скалярного значения");
        ОчищенныеСтроки = ОчиститьСтроки(Строки);
        ИтоговаяСтрока = СобратьСтрокуИзМассива(ОчищенныеСтроки);
        // Убираем кавычки перед обработкой
        ИтоговаяСтрока = УбратьКавычки(ИтоговаяСтрока);
        
        // Проверяем на специальные значения YAML
        СпециальноеЗначение = Неопределено;
        Если ПреобразоватьСпециальноеЗначение(ИтоговаяСтрока, СпециальноеЗначение) Тогда
            Лог.Отладка("Скаляр преобразован в специальное значение: " + СпециальноеЗначение);
            Возврат СпециальноеЗначение;
        КонецЕсли;
        
        // Безопасная проверка на число без использования исключений
        Если ЭтоЧисло(ИтоговаяСтрока) Тогда
            Результат = Число(ИтоговаяСтрока);
            Лог.Отладка("Скаляр преобразован в число: " + Результат);
            Возврат Результат;
        КонецЕсли;
        
        Лог.Отладка("Скаляр обработан как строка: " + ИтоговаяСтрока);
        Возврат ИтоговаяСтрока;
    Иначе
        Лог.Предупреждение("Неопределенный тип содержимого, возвращаем Неопределено");
        Возврат Неопределено; // Если не определено, то возвращаем неопределено
    КонецЕсли;
    
КонецФункции

// Проверяет, является ли строка заключенной в кавычки
//
// Параметры:
//   Строка - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если строка в кавычках
//
Функция ЭтоСтрокаВКавычках(Строка)
    Возврат (СтрНачинаетсяС(Строка, """") И СтрЗаканчиваетсяНа(Строка, """")) 
        Или (СтрНачинаетсяС(Строка, "'") И СтрЗаканчиваетсяНа(Строка, "'"));
КонецФункции

Функция УбратьКавычки(Строка)
    // Убираем кавычки из строки, если они есть
    Если ЭтоСтрокаВКавычках(Строка) Тогда
        Результат = УдалитьПервыйИПоследнийСимволы(Строка);
        
        // Обрабатываем экранированные символы в зависимости от типа кавычек
        Если СтрНачинаетсяС(Строка, """") Тогда
            Результат = ОбработатьEscapeПоследовательности(Результат, "double");
        КонецЕсли;
        
        Если СтрНачинаетсяС(Строка, "'") Тогда
            Результат = ОбработатьEscapeПоследовательности(Результат, "single");
        КонецЕсли;
        
        Возврат Результат;
    КонецЕсли;
    
    Возврат Строка; // Если кавычек нет, возвращаем строку как есть
    
КонецФункции

// Преобразует специальные значения YAML (булевы, null и т.д.)
//
// Параметры:
//   Строка - Строка - строка для проверки и преобразования
//   Результат - Произвольный - результат преобразования (возвращается по ссылке)
//
// Возвращаемое значение:
//   Булево - Истина, если строка была преобразована в специальное значение
//
Функция ПреобразоватьСпециальноеЗначение(Строка, Результат)
    
    ВерхнийРегистр = ВРег(Строка);
    
    Если ВерхнийРегистр = "TRUE" Тогда
        Результат = Истина;
        Возврат Истина;
    ИначеЕсли ВерхнийРегистр = "FALSE" Тогда
        Результат = Ложь;
        Возврат Истина;
    ИначеЕсли ВерхнийРегистр = "NULL" Или Строка = "~" Тогда
        Результат = Неопределено;
        Возврат Истина;
    Иначе
        Возврат Ложь;
    КонецЕсли;
    
КонецФункции

// Проверяет, является ли строка числом
// Параметры:
//   Строка - Строка - строка для проверки
// Возвращаемое значение:
//   Булево - Истина, если строка является числом
//
Функция ЭтоЧисло(Знач Строка)
    
    Если ПустаяСтрока(Строка) Тогда
        Возврат Ложь;
    КонецЕсли;
    
    // Убираем пробелы в начале и конце
    Строка = СокрЛП(Строка);
    
    // Проверяем на специальные значения
    Если ВРег(Строка) = "TRUE" Или ВРег(Строка) = "FALSE" Или ВРег(Строка) = "NULL" Тогда
        Возврат Ложь;
    КонецЕсли;
    
    // Проверяем регулярным выражением на соответствие числу
    // Простая проверка: может начинаться с + или -, далее цифры, возможно с точкой и экспонентой
    Для Позиция = 1 По СтрДлина(Строка) Цикл
        Символ = Сред(Строка, Позиция, 1);
        Если Позиция = 1 И (Символ = "+" Или Символ = "-") Тогда
            Продолжить; // Знак в начале допустим
        ИначеЕсли Символ >= "0" И Символ <= "9" Тогда
            Продолжить; // Цифра допустима
        ИначеЕсли Символ = "." Тогда
            Продолжить; // Десятичная точка допустима
        ИначеЕсли ВРег(Символ) = "E" Тогда
            Продолжить; // Экспонента допустима
        Иначе
            Возврат Ложь; // Недопустимый символ
        КонецЕсли;
    КонецЦикла;
    
    Возврат Истина;
    
КонецФункции

// Парсер объектов
//
// Параметры:
//   Строки - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Соответствие - результат парсинга объектов
//
Функция ПарсерОбъектов(Строки)
    Лог.Отладка("Начало парсинга объектов");
    
    МассивОбъектов = ПолучитьМассивСущностей(Строки);
    СоответствиеОбъектов = Новый Соответствие();
    
    Лог.Отладка("Найдено " + МассивОбъектов.Количество() + " объектов для обработки");

    // Обрабатываем объекты в порядке документа
    Для Каждого Объект Из МассивОбъектов Цикл
        Если Объект.ИмяОбъекта = "<<" Тогда
            Лог.Отладка("Обработка якоря");
            // Это якорь. Разыменуем его.
            Данные = ДанныеИзМассиваСтрок(Объект.Содержимое);
            Если не ТипЗнч(Данные) = Тип("Соответствие") Тогда
                Лог.Ошибка("Якорь должен быть объектом, а получено: " + ТипЗнч(Данные));
                ВызватьИсключение "Якорь должен быть объектом, а получено: " + ТипЗнч(Данные);
            КонецЕсли;
            // Добавляем все ключи и значения из якоря в текущее соответствие    
            Для каждого КлючИЗначение Из Данные Цикл
                СоответствиеОбъектов.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
            КонецЦикла;
        ИначеЕсли Объект.ТипОбъекта = "ОбъектЯвныйКлюч" Тогда
            Лог.Отладка("Обработка объекта с явным ключом");
            РезультатПарсинга = РазобратьЯвныйКлюч(Объект);
            СоответствиеОбъектов.Вставить(РезультатПарсинга.Ключ, РезультатПарсинга.Значение);
        Иначе
            Лог.Отладка("Обработка объекта с ключом: " + Объект.ИмяОбъекта);
            СоответствиеОбъектов.Вставить(УбратьКавычки(Объект.ИмяОбъекта), ДанныеИзМассиваСтрок(Объект.Содержимое));  
        КонецЕсли;
    КонецЦикла;
    
    Лог.Отладка("Парсинг объектов завершен, получено " + СоответствиеОбъектов.Количество() + " свойств");
    Возврат СоответствиеОбъектов;
    
КонецФункции

// Формирует ключ из массива строк с учетом многострочных литералов
//
// Параметры:
//   СтрокиКлюча - Массив - строки ключа
//
// Возвращаемое значение:
//   Строка - сформированный ключ
Функция СформироватьКлючИзСтрок(СтрокиКлюча)
    Если СтрокиКлюча.Количество() = 0 Тогда
        Возврат "";
    ИначеЕсли СтрокиКлюча.Количество() = 1 Тогда
        Возврат СтрокиКлюча[0];
    Иначе
        // Проверяем, есть ли символы многострочного литерала в первой строке
        ПерваяСтрока = СтрокиКлюча[0];
        Если ПерваяСтрока = "|" И СтрокиКлюча.Количество() >= МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ Тогда
            // Литеральный стиль - соединяем строки через символ новой строки
            СтрокиДляСоединения = Новый Массив();
            Для ИндексСтроки = 1 По СтрокиКлюча.Количество() - 1 Цикл
                СтрокиДляСоединения.Добавить(СтрокиКлюча[ИндексСтроки]);
            КонецЦикла;
            Возврат СтрСоединить(СтрокиДляСоединения, Символы.ПС) + Символы.ПС;
        ИначеЕсли ПерваяСтрока = ">" И СтрокиКлюча.Количество() >= МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ Тогда
            // Складчатый стиль - соединяем строки через пробел
            СтрокиДляСоединения = Новый Массив();
            Для ИндексСтроки = 1 По СтрокиКлюча.Количество() - 1 Цикл
                СтрокиДляСоединения.Добавить(СтрокиКлюча[ИндексСтроки]);
            КонецЦикла;
            Возврат СтрСоединить(СтрокиДляСоединения, " ");
        Иначе
            // Обычный многострочный ключ - соединяем через пробел
            Возврат СтрСоединить(СтрокиКлюча, " ");
        КонецЕсли;
    КонецЕсли;
КонецФункции

// Обрабатывает строку с двоеточием, извлекая ключ и значение
//
// Параметры:
//   СтрокаБезОтступов - Строка - строка без ведущих пробелов
//   СтрокиКлюча - Массив - массив строк ключа
//   СтрокиЗначения - Массив - массив строк значения
//
// Возвращаемое значение:
//   Соответствие - результат обработки с ключом и значением
//
Функция ОбработатьСтрокуСДвоеточием(СтрокаБезОтступов, СтрокиКлюча, СтрокиЗначения)
    ПозицияДвоеточия = ПозицияНеЭкранированногоСимвола(СтрокаБезОтступов, ":");
    Если ПозицияДвоеточия > 0 Тогда
        // Двоеточие найдено в строке - разделяем ключ и значение
        ЧастьКлюча = СокрЛП(Лев(СтрокаБезОтступов, ПозицияДвоеточия - 1));
        ЧастьЗначения = ИзвлечьЗначениеПослеДвоеточияСОчисткой(СтрокаБезОтступов, ПозицияДвоеточия);
        
        // Если эта строка начинается с "?", убираем его из ключа
        Если СтрНачинаетсяС(ЧастьКлюча, "?") Тогда
            ЧастьКлюча = УдалитьПервыйСимволСОчисткой(ЧастьКлюча);
        КонецЕсли;
        
        ДобавитьНепустоеЗначение(СтрокиКлюча, ЧастьКлюча);
        ДобавитьНепустоеЗначение(СтрокиЗначения, ЧастьЗначения);
        
        Возврат Истина;
    КонецЕсли;
    
    Возврат Ложь;
КонецФункции

// Обрабатывает случай с предопределенным именем ключа
//
// Параметры:
//   Объект - Структура - объект с именем и содержимым для обработки
//
// Возвращаемое значение:
//   Соответствие - результат обработки с ключом и значением
//
Функция ОбработатьПредопределенныйКлюч(Объект)
    РезультатРазбора = РазделитьКлючИЗначениеИзИмени(Объект.ИмяОбъекта);
    Ключ = РезультатРазбора.Ключ;
    СтрокиЗначения = РезультатРазбора.СтрокиЗначения;
    
    // Если значение не было найдено в имени, ищем в содержимом
    Если СтрокиЗначения.Количество() = 0 Тогда
        ОбработатьСодержимоеДляЗначения(Объект.Содержимое, Ключ, СтрокиЗначения);
    КонецЕсли;
    
    // Парсим значение
    Значение = СформироватьЗначениеИзСтрок(СтрокиЗначения);
    
    Результат = Новый Структура();
    Результат.Вставить("Ключ", Ключ);
    Результат.Вставить("Значение", Значение);
    Возврат Результат;
КонецФункции

Функция РазделитьКлючИЗначениеИзИмени(ИмяОбъекта)
    Ключ = "";
    СтрокиЗначения = Новый Массив();
    
    // Проверяем, есть ли двоеточие в самом имени объекта
    ПозицияДвоеточия = ПозицияНеЭкранированногоСимвола(ИмяОбъекта, ":");
    Если ПозицияДвоеточия > 0 Тогда
        // Двоеточие найдено в имени - разделяем ключ и значение
        Ключ = СокрЛП(Лев(ИмяОбъекта, ПозицияДвоеточия - 1));
        ЧастьЗначения = ИзвлечьЗначениеПослеДвоеточияСОчисткой(ИмяОбъекта, ПозицияДвоеточия);
        
        ДобавитьНепустоеЗначение(СтрокиЗначения, ЧастьЗначения);
    Иначе
        // Двоеточие не найдено в имени - используем имя как ключ
        Ключ = СокрЛП(ИмяОбъекта);
    КонецЕсли;
    
    Результат = Новый Структура();
    Результат.Вставить("Ключ", Ключ);
    Результат.Вставить("СтрокиЗначения", СтрокиЗначения);
    Возврат Результат;
КонецФункции

Процедура ОбработатьСодержимоеДляЗначения(Содержимое, Ключ, СтрокиЗначения)
    // Ищем значение в содержимом (строки, начинающиеся с ":")
    Для Каждого Строка Из Содержимое Цикл
        СтрокаБезОтступов = СокрЛП(Строка);
        Если СтрНачинаетсяС(СтрокаБезОтступов, ":") Тогда
            ОбработатьСтрокуСДвоеточиемВСодержимом(СтрокаБезОтступов, СтрокиЗначения);
        ИначеЕсли НЕ ЭтоПустаяСтрокаИлиКомментарий(Строка) И НЕ СтрНачинаетсяС(СтрокаБезОтступов, ":") И СтрокаБезОтступов <> Ключ Тогда
            // Для многострочных значений - строки с отступом больше базового (но не строки со значениями и не сам ключ)
            СтрокиЗначения.Добавить(Строка);
        Иначе
            // Пропускаем пустые строки, комментарии и строки с ключами
            Лог.Отладка("Пропускаем строку при обработке многострочного значения: %1", Строка);
        КонецЕсли;
    КонецЦикла;
КонецПроцедуры

Процедура ОбработатьСтрокуСДвоеточиемВСодержимом(СтрокаБезОтступов, СтрокиЗначения)
    // Проверяем на табы после двоеточия - это запрещено YAML спецификацией
    ПроверитьОтсутствиеТабуляцииПослеДвоеточия(СтрокаБезОтступов);
    // Извлекаем значение после ":"
    ЧастьЗначения = ИзвлечьЗначениеПослеДвоеточия(СтрокаБезОтступов);
    ДобавитьНепустоеЗначение(СтрокиЗначения, ЧастьЗначения);
КонецПроцедуры

Функция СформироватьЗначениеИзСтрок(СтрокиЗначения)
    // Парсим значение
    Возврат СпарситьЗначениеИзМассиваСтрок(СтрокиЗначения);
КонецФункции

// Обрабатывает цикл разбора содержимого для извлечения ключа и значения
//
// Параметры:
//   Объект - Структура - объект для обработки
//   СтрокиКлюча - Массив - массив строк ключа (передается по ссылке)
//   СтрокиЗначения - Массив - массив строк значения (передается по ссылке)  
//   НайденДвоеточие - Булево - флаг найденного двоеточия (передается по ссылке)
//   МногострочныйКлюч - Булево - флаг многострочного ключа (передается по ссылке)
//   ПропуститьТекущуюСтроку - Булево - флаг пропуска текущей строки (передается по ссылке)
//
Процедура ОбработатьЦиклРазбораСодержимого(Объект, СтрокиКлюча, СтрокиЗначения, НайденДвоеточие, МногострочныйКлюч, ПропуститьТекущуюСтроку)
    Для Каждого Строка Из Объект.Содержимое Цикл
        СтрокаБезОтступов = СокрЛП(Строка);
        
        Если НЕ НайденДвоеточие Тогда
            ОбработатьПоискДвоеточия(СтрокаБезОтступов, Строка, СтрокиКлюча, СтрокиЗначения, НайденДвоеточие, МногострочныйКлюч, ПропуститьТекущуюСтроку);
        Иначе
            // Двоеточие уже найдено, все остальное - часть значения
            ОбработатьДобавлениеЗначений(Строка, СтрокиЗначения);
        КонецЕсли;
    КонецЦикла;
КонецПроцедуры

Процедура ОбработатьПоискДвоеточия(СтрокаБезОтступов, ПолнаяСтрока, СтрокиКлюча, СтрокиЗначения, НайденДвоеточие, МногострочныйКлюч, ПропуститьТекущуюСтроку)
    // Ищем двоеточие в строке
    Если СтрНачинаетсяС(СтрокаБезОтступов, ":") Тогда
        ОбработатьСтрокуСДвоеточиемВНачале(СтрокаБезОтступов, СтрокиЗначения);
        НайденДвоеточие = Истина;
    Иначе
        ОбработатьПоискДвоеточияВСтроке(СтрокаБезОтступов, ПолнаяСтрока, СтрокиКлюча, СтрокиЗначения, НайденДвоеточие, МногострочныйКлюч, ПропуститьТекущуюСтроку);
    КонецЕсли;
КонецПроцедуры

Процедура ОбработатьСтрокуСДвоеточиемВНачале(СтрокаБезОтступов, СтрокиЗначения)
    // Строка начинается с двоеточия - это значение для многострочного ключа
    ЧастьЗначения = ИзвлечьЗначениеПослеДвоеточия(СтрокаБезОтступов);
    ДобавитьНепустоеЗначение(СтрокиЗначения, ЧастьЗначения);
КонецПроцедуры

Процедура ОбработатьПоискДвоеточияВСтроке(СтрокаБезОтступов, ПолнаяСтрока, СтрокиКлюча, СтрокиЗначения, НайденДвоеточие, МногострочныйКлюч, ПропуститьТекущуюСтроку)
    // Ищем двоеточие внутри строки (для однострочных ключей)
    НайденДвоеточие = ОбработатьСтрокуСДвоеточием(СтрокаБезОтступов, СтрокиКлюча, СтрокиЗначения);
    
    Если НЕ НайденДвоеточие И НЕ ЭтоПустаяСтрокаИлиКомментарий(ПолнаяСтрока) Тогда
        // Часть многострочного ключа
        ОбработатьМногострочныйКлюч(СтрокаБезОтступов, СтрокиКлюча, МногострочныйКлюч, ПропуститьТекущуюСтроку);
    ИначеЕсли НЕ НайденДвоеточие Тогда
        // Пустая строка или комментарий в процессе анализа ключа - игнорируем
        Лог.Отладка("Игнорируем пустую строку или комментарий при анализе ключа");
    Иначе
        // Двоеточие найдено - обработка завершена
        Лог.Отладка("Двоеточие найдено, продолжаем обработку");
    КонецЕсли;
КонецПроцедуры

// Инициализирует переменные для разбора явного ключа
//
// Возвращаемое значение:
//   Структура - структура с инициализированными переменными для разбора
//
Функция ИнициализироватьПеременныеРазбораКлюча()
    Результат = Новый Структура();
    Результат.Вставить("СтрокиКлюча", Новый Массив());
    Результат.Вставить("СтрокиЗначения", Новый Массив());
    Результат.Вставить("НайденДвоеточие", Ложь);
    Результат.Вставить("МногострочныйКлюч", Ложь);
    Результат.Вставить("ПропуститьТекущуюСтроку", Ложь);
    Возврат Результат;
КонецФункции

// Обрабатывает добавление строк значения после найденного двоеточия
//
// Параметры:
//   Строка - Строка - строка для добавления к значению
//   СтрокиЗначения - Массив - массив строк значения (передается по ссылке)
//
Процедура ОбработатьДобавлениеЗначений(Строка, СтрокиЗначения)
    СтрокаБезОтступов = СокрЛП(Строка);
    Если НЕ ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
        СтрокиЗначения.Добавить(СтрокаБезОтступов);
    КонецЕсли;
КонецПроцедуры

// Обрабатывает строку многострочного ключа
//
// Параметры:
//   СтрокаБезОтступов - Строка - строка без ведущих пробелов
//   СтрокиКлюча - Массив - массив строк ключа (передается по ссылке)
//   МногострочныйКлюч - Булево - флаг многострочного ключа (передается по ссылке)
//   ПропуститьТекущуюСтроку - Булево - флаг пропуска текущей строки (передается по ссылке)
//
Процедура ОбработатьМногострочныйКлюч(СтрокаБезОтступов, СтрокиКлюча, МногострочныйКлюч, ПропуститьТекущуюСтроку)
    Если СтрНачинаетсяС(СтрокаБезОтступов, "?") Тогда
        ОбработатьКлючСВопросом(СтрокаБезОтступов, СтрокиКлюча, МногострочныйКлюч, ПропуститьТекущуюСтроку);
    Иначе
        ОбработатьКлючБезВопроса(СтрокаБезОтступов, СтрокиКлюча, МногострочныйКлюч, ПропуститьТекущуюСтроку);
    КонецЕсли;
КонецПроцедуры

Процедура ОбработатьКлючСВопросом(СтрокаБезОтступов, СтрокиКлюча, МногострочныйКлюч, ПропуститьТекущуюСтроку)
    // Убираем символ "?" и пробел
    СтрокаКлюча = ОчиститьСтрокуОтКомментариев(Сред(СтрокаБезОтступов, МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ));
    
    // Проверяем на многострочный литерал (символы | и >)
    Если СтрокаКлюча = "|" ИЛИ СтрокаКлюча = ">" Тогда
        // Это многострочный литерал - собираем все последующие строки до двоеточия
        МногострочныйКлюч = "";
        ПропуститьТекущуюСтроку = Истина;
    Иначе
        ДобавитьНепустоеЗначение(СтрокиКлюча, СтрокаКлюча);
        Если ПустаяСтрока(СтрокаКлюча) Тогда
            // Пустая строка ключа - игнорируем
            // Ничего не делаем, переходим к следующей строке
            Лог.Отладка("Пропускаем пустую строку в ключе");
        КонецЕсли;
    КонецЕсли;
КонецПроцедуры

Процедура ОбработатьКлючБезВопроса(СтрокаБезОтступов, СтрокиКлюча, МногострочныйКлюч, ПропуститьТекущуюСтроку)
    // Если активен многострочный литерал, добавляем эту строку к нему
    Если ПропуститьТекущуюСтроку Тогда
        ОбработатьАктивныйМногострочныйКлюч(СтрокаБезОтступов, МногострочныйКлюч);
    Иначе
        ОбработатьОбычнуюСтрокуКлюча(СтрокаБезОтступов, СтрокиКлюча);
    КонецЕсли;
КонецПроцедуры

Процедура ОбработатьАктивныйМногострочныйКлюч(СтрокаБезОтступов, МногострочныйКлюч)
    СтрокаКлючаБезКомментариев = ОчиститьСтрокуОтКомментариев(СтрокаБезОтступов);
    Если НЕ ПустаяСтрока(СтрокаКлючаБезКомментариев) Тогда
        Если НЕ ПустаяСтрока(МногострочныйКлюч) Тогда
            МногострочныйКлюч = МногострочныйКлюч + Символы.ПС;
        КонецЕсли;
        МногострочныйКлюч = МногострочныйКлюч + СтрокаКлючаБезКомментариев;
    КонецЕсли;
КонецПроцедуры

Процедура ОбработатьОбычнуюСтрокуКлюча(СтрокаБезОтступов, СтрокиКлюча)
    СтрокаКлючаБезКомментариев = ОчиститьСтрокуОтКомментариев(СтрокаБезОтступов);
    ДобавитьНепустоеЗначение(СтрокиКлюча, СтрокаКлючаБезКомментариев);
КонецПроцедуры

// Создает финальный результат для явного ключа
//
// Параметры:
//   СтрокиКлюча - Массив - массив строк ключа
//   СтрокиЗначения - Массив - массив строк значения
//   МногострочныйКлюч - Строка - многострочный ключ
//
// Возвращаемое значение:
//   Структура - структура с полями "Ключ" и "Значение"
//
Функция СоздатьФинальныйРезультат(СтрокиКлюча, СтрокиЗначения, МногострочныйКлюч)
    // Если был многострочный ключ, добавляем его
    Если НЕ ПустаяСтрока(МногострочныйКлюч) Тогда
        СтрокиКлюча.Добавить(МногострочныйКлюч);
    КонецЕсли;
    
    // Собираем ключ из строк
    Ключ = СформироватьКлючИзСтрок(СтрокиКлюча);
    
    // Парсим значение
    Значение = СпарситьЗначениеИзМассиваСтрок(СтрокиЗначения);
    
    Результат = Новый Структура();
    Результат.Вставить("Ключ", УбратьКавычки(Ключ));
    Результат.Вставить("Значение", Значение);
    
    Лог.Отладка("Явный ключ разобран: ключ='" + Результат.Ключ + "', тип значения=" + ТипЗнч(Результат.Значение));
    Возврат Результат;
КонецФункции

// Разбирает явный ключ на ключ и значение
//
// Параметры:
//   Объект - Структура - объект с явным ключом
//
// Возвращаемое значение:
//   Структура - с полями Ключ и Значение
//
Функция РазобратьЯвныйКлюч(Объект)
    
    // Если имя ключа уже определено в первой строке (после ?), используем его
    Если НЕ ПустаяСтрока(Объект.ИмяОбъекта) Тогда
        Возврат ОбработатьПредопределенныйКлюч(Объект);
    Иначе
        // Инициализация переменных для обработки
        Переменные = ИнициализироватьПеременныеРазбораКлюча();
        СтрокиКлюча = Переменные.СтрокиКлюча;
        СтрокиЗначения = Переменные.СтрокиЗначения;
        НайденДвоеточие = Переменные.НайденДвоеточие;
        ПропуститьТекущуюСтроку = Переменные.ПропуститьТекущуюСтроку;
        МногострочныйКлюч = "";
        
        // Обрабатываем содержимое для извлечения ключа и значения
        ОбработатьЦиклРазбораСодержимого(Объект, СтрокиКлюча, СтрокиЗначения, НайденДвоеточие, МногострочныйКлюч, ПропуститьТекущуюСтроку);
        
        Возврат СоздатьФинальныйРезультат(СтрокиКлюча, СтрокиЗначения, МногострочныйКлюч);
    КонецЕсли;
КонецФункции

// Парсер якорей
//
// Параметры:
//   Строки - Массив - массив строк для парсинга якоря
//
// Возвращаемое значение:
//   Соответствие - результат парсинга объекта с якорем
//
Функция ПарсерЯкорей(Строки)
    Лог.Отладка("Начало парсинга якоря");
    
    // Находим параметры якоря
    ПараметрыЯкоря = НайтиПараметрыЯкоря(Строки);
    
    Если ПараметрыЯкоря = Неопределено Тогда
        Лог.Ошибка("Не найдено определение якоря");
        ВызватьИсключение "Не найдено определение якоря";
    КонецЕсли;
    
    Лог.Отладка("Найден якорь с именем: " + ПараметрыЯкоря.ИмяЯкоря);
    
    // Извлекаем строки содержимого (без строки с определением якоря)
    СтрокиСодержимого = ИзвлечьСодержимоеЯкоря(Строки, ПараметрыЯкоря);
    
    // Парсим содержимое как объект
    РезультатПарсинга = ДанныеИзМассиваСтрок(СтрокиСодержимого);
    
    // Сохраняем результат под якорем
    МенеджерЯкорей.СохранитьЯкорь(ПараметрыЯкоря.ИмяЯкоря, РезультатПарсинга);
    Лог.Отладка("Якорь сохранен в менеджере якорей");
    
    // Возвращаем результат парсинга
    Возврат РезультатПарсинга;
    
КонецФункции

Функция ПарсерАлиасов(Строки)
    Лог.Отладка("Начало парсинга алиаса");
    
    Для каждого Строка Из Строки Цикл
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Продолжить;
        КонецЕсли;
        ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
        Если ДанныеУправляющегоСимвола.Символ <> "*" Тогда
            Лог.Ошибка("Ожидался алиас, а найдено: " + Строка);
            ВызватьИсключение "Ожидался алиас, а найдено: " + Строка;
        КонецЕсли;
        ИмяАлиаса = МенеджерЯкорей.ИзвлечьИмяЯкоряИлиАлиаса(Строка);
        Если ПустаяСтрока(ИмяАлиаса) Тогда
            Лог.Ошибка("Не указано имя алиаса в строке: " + Строка);
            ВызватьИсключение "Не указано имя алиаса в строке: " + Строка;
        КонецЕсли;
        Лог.Отладка("Найден алиас с именем: " + ИмяАлиаса);
        Прервать;
    КонецЦикла;
    
    // Получаем значение алиаса из менеджера якорей
    ЗначениеАлиаса = МенеджерЯкорей.ПолучитьЗначениеЯкоря(ИмяАлиаса);
    
    Если ЗначениеАлиаса = Неопределено Тогда
        Лог.Ошибка("Не найден алиас: " + ИмяАлиаса);
        ВызватьИсключение "Не найден алиас: " + ИмяАлиаса;
    КонецЕсли;
    
    Лог.Отладка("Алиас успешно разрешен");
    Возврат ЗначениеАлиаса;
КонецФункции
// Парсер массивов
//
// Параметры:
//   Строки - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Массив - результат парсинга массива
//
Функция ПарсерМассивов(Строки)
    Лог.Отладка("Начало парсинга массива");
    
    МассивЭлементов = ПолучитьМассивСущностей(Строки);
    МассивРезультат = Новый Массив();
    
    Лог.Отладка("Найдено " + МассивЭлементов.Количество() + " элементов массива");
    
    Для Каждого Элемент Из МассивЭлементов Цикл
        Лог.Отладка("Обработка элемента массива");
        МассивРезультат.Добавить(ДанныеИзМассиваСтрок(Элемент.Содержимое));
    КонецЦикла;
    
    Лог.Отладка("Парсинг массива завершен, получено " + МассивРезультат.Количество() + " элементов");
    Возврат МассивРезультат;
КонецФункции

// Создает структуру сущности с базовыми параметрами
//
// Параметры:
//   ТипОбъекта - Строка - тип объекта (Объект, ЭлементМассива)
//   ИмяОбъекта - Строка - имя объекта
//   МинимальныйОтступ - Число - минимальный отступ
//
// Возвращаемое значение:
//   Структура - структура сущности
//
Функция СоздатьСтруктуруСущности(ТипОбъекта, ИмяОбъекта, МинимальныйОтступ)
    Сущность = Новый Структура();
    Сущность.Вставить("ТипОбъекта", ТипОбъекта);
    Сущность.Вставить("ИмяОбъекта", ИмяОбъекта);
    Сущность.Вставить("МинимальныйОтступ", МинимальныйОтступ);
    Возврат Сущность;
КонецФункции

// Обрабатывает одну сущность из массива строк
//
// Параметры:
//   Строка - Строка - обрабатываемая строка
//   Строки - Массив - массив всех строк
//   Индекс - Число - индекс текущей строки
//   МассивСущностей - Массив - уже обработанные сущности
//
// Возвращаемое значение:
//   Структура - результат обработки сущности с полями: Сущность, НовыйИндекс
//

// Обрабатывает объект с двоеточием
//
// Параметры:
//   Строка - Строка - исходная строка
//   ПозицияДвоеточия - Число - позиция двоеточия
//   ТекущийОтступ - Число - текущий отступ
//
// Возвращаемое значение:
//   Структура - сущность и модифицированная строка
Функция ОбработатьОбъектСДвоеточием(Строка, ПозицияДвоеточия, ТекущийОтступ)
    ИмяОбъекта = СокрЛП(Лев(Строка, ПозицияДвоеточия - 1));
    Сущность = СоздатьСтруктуруСущности("Объект", ИмяОбъекта, ТекущийОтступ + 1);
    Лог.Отладка("Найден объект: " + ИмяОбъекта);
    
    МодифицированнаяСтрока = ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, ПозицияДвоеточия);
    СледующийУправляющийСимвол = НайтиУправляющийСимволИЕгоПозицию(МодифицированнаяСтрока);
    
    Если СледующийУправляющийСимвол.Позиция > 0 
            И (СледующийУправляющийСимвол.Символ = ":" 
            Или СледующийУправляющийСимвол.Символ = "-") Тогда
        Лог.Ошибка("Найдено несколько управляющих символов в строке: " + Строка);
        ВызватьИсключение "Найдено несколько управляющих символов в строке: " + Строка;
    КонецЕсли;
    
    Результат = Новый Структура("Сущность, МодифицированнаяСтрока", Сущность, МодифицированнаяСтрока);
    Возврат Результат;
КонецФункции

// Обрабатывает объект с явным ключом (символ ?)
//
// Параметры:
//   Строка - Строка - исходная строка
//   ПозицияВопроса - Число - позиция знака вопроса
//   ТекущийОтступ - Число - текущий отступ
//
// Возвращаемое значение:
//   Структура - сущность и модифицированная строка
Функция ОбработатьОбъектСЯвнымКлючом(Строка, ПозицияВопроса, ТекущийОтступ)
    // Для явного ключа имя всегда пустое - ключ будет собран из содержимого
    ИмяОбъекта = "";
    Сущность = СоздатьСтруктуруСущности("ОбъектЯвныйКлюч", ИмяОбъекта, ТекущийОтступ + 1);
    Лог.Отладка("Найден объект с явным ключом: " + ИмяОбъекта);
    
    МодифицированнаяСтрока = ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, ПозицияВопроса);
    
    Результат = Новый Структура("Сущность, МодифицированнаяСтрока", Сущность, МодифицированнаяСтрока);
    Возврат Результат;
КонецФункции

// Обрабатывает элемент массива (символ -)
//
// Параметры:
//   Строка - Строка - исходная строка
//   ПозицияТире - Число - позиция тире
//   ТекущийОтступ - Число - текущий отступ
//
// Возвращаемое значение:
//   Структура - сущность и модифицированная строка
Функция ОбработатьЭлементМассива(Строка, ПозицияТире, ТекущийОтступ)
    Сущность = СоздатьСтруктуруСущности("ЭлементМассива", "ЭлементМассива", ТекущийОтступ + 1);
    Лог.Отладка("Найден элемент массива");
    
    МодифицированнаяСтрока = ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, ПозицияТире);
    
    Результат = Новый Структура("Сущность, МодифицированнаяСтрока", Сущность, МодифицированнаяСтрока);
    Возврат Результат;
КонецФункции

// Обрабатывает якорь (символ &)
//
// Параметры:
//   Строка - Строка - исходная строка
//   ПозицияЯкоря - Число - позиция символа &
//   ТекущийОтступ - Число - текущий отступ
//
// Возвращаемое значение:
//   Структура - сущность и модифицированная строка
Функция ОбработатьЯкорь(Строка, ПозицияЯкоря, ТекущийОтступ)
    // Ищем следующий управляющий символ после якоря
    ОстатокСтроки = Сред(Строка, ПозицияЯкоря + 1);
    СледующийСимвол = НайтиУправляющийСимволИЕгоПозицию(ОстатокСтроки);
    
    Если СледующийСимвол.Символ = ":" Тогда
        // Якорь с объектом: &anchor key: value
        ПозицияДвоеточия = ПозицияЯкоря + СледующийСимвол.Позиция;
        ПолнаяСтрокаДоДвоеточия = СокрЛП(Лев(Строка, ПозицияДвоеточия - 1));
        // Убираем якорь из имени - ищем пробел после якоря
        ПозицияПробела = Найти(ПолнаяСтрокаДоДвоеточия, " ");
        Если ПозицияПробела > 0 Тогда
            ИмяОбъекта = СокрЛП(Сред(ПолнаяСтрокаДоДвоеточия, ПозицияПробела + 1));
        Иначе
            ИмяОбъекта = ПолнаяСтрокаДоДвоеточия;
        КонецЕсли;
        
        // Проверяем на недопустимое сочетание якоря и алиаса в ключе
        Если Найти(ИмяОбъекта, "*") > 0 Тогда
            ВызватьИсключение("YAML Error: Недопустимо использование алиаса (*) в ключе, который уже содержит якорь (&)");
        КонецЕсли;
        
        Сущность = СоздатьСтруктуруСущности("Объект", ИмяОбъекта, ТекущийОтступ + 1);
        Лог.Отладка("Найден объект с якорем: " + ИмяОбъекта);
        МодифицированнаяСтрока = ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, ПозицияДвоеточия);
    Иначе
        // Обычный якорь
        Сущность = СоздатьСтруктуруСущности("Якорь", "", ТекущийОтступ + 1);
        Лог.Отладка("Найден якорь");
        МодифицированнаяСтрока = ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, ПозицияЯкоря);
    КонецЕсли;
    
    Результат = Новый Структура("Сущность, МодифицированнаяСтрока", Сущность, МодифицированнаяСтрока);
    Возврат Результат;
КонецФункции

// Обрабатывает алиас (символ *)
//
// Параметры:
//   Строка - Строка - исходная строка
//   ПозицияАлиаса - Число - позиция символа *
//   ТекущийОтступ - Число - текущий отступ
//
// Возвращаемое значение:
//   Структура - сущность и модифицированная строка
Функция ОбработатьАлиас(Строка, ПозицияАлиаса, ТекущийОтступ)
    Сущность = СоздатьСтруктуруСущности("Алиас", "", ТекущийОтступ + 1);
    Лог.Отладка("Найден алиас");
    
    МодифицированнаяСтрока = ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, ПозицияАлиаса);
    
    Результат = Новый Структура("Сущность, МодифицированнаяСтрока", Сущность, МодифицированнаяСтрока);
    Возврат Результат;
КонецФункции

Функция ОбработатьОднуСущность(Строка, Строки, Индекс, МассивСущностей)
    ТекущийОтступ = ОпределитьОтступ(Строка);
    ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
    
    РезультатОбработки = Неопределено;
    
    Если ДанныеУправляющегоСимвола.Символ = ":" Тогда // Это объект
        РезультатОбработки = ОбработатьОбъектСДвоеточием(Строка, ДанныеУправляющегоСимвола.Позиция, ТекущийОтступ);
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "?" Тогда // Это объект с явным ключом
        РезультатОбработки = ОбработатьОбъектСЯвнымКлючом(Строка, ДанныеУправляющегоСимвола.Позиция, ТекущийОтступ);
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "-" Тогда // Это элемент массива
        РезультатОбработки = ОбработатьЭлементМассива(Строка, ДанныеУправляющегоСимвола.Позиция, ТекущийОтступ);
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "&" Тогда // Это якорь
        РезультатОбработки = ОбработатьЯкорь(Строка, ДанныеУправляющегоСимвола.Позиция, ТекущийОтступ);
    ИначеЕсли ДанныеУправляющегоСимвола.Символ = "*" Тогда // Это алиас
        РезультатОбработки = ОбработатьАлиас(Строка, ДанныеУправляющегоСимвола.Позиция, ТекущийОтступ);
    Иначе
        Лог.Ошибка("Не удалось выделить управляющий символ в строке: " + Строка);
        ВызватьИсключение "Не удалось выделить управляющий символ в строке: " + Строка;
    КонецЕсли;
    
    Сущность = РезультатОбработки.Сущность;
    МодифицированнаяСтрока = РезультатОбработки.МодифицированнаяСтрока;
    
    ПроверитьВалидностьСущности(Сущность, МассивСущностей);

    Строки[Индекс] = МодифицированнаяСтрока; // Обновим строку с отступом
    
    // Для явных ключей используем особую логику выделения содержимого
    Если Сущность.ТипОбъекта = "ОбъектЯвныйКлюч" Тогда
        СтрокиСодержимого = ВыделитьСодержимоеЯвногоКлюча(Строки, Индекс, ТекущийОтступ);
    Иначе
        СтрокиСодержимого = ВыделитьСодержимое(Строки, Индекс, ТекущийОтступ);
    КонецЕсли;
    
    Сущность.Вставить("Содержимое", СтрокиСодержимого);
    НовыйИндекс = Индекс + СтрокиСодержимого.Количество() - 1;

    Результат = СоздатьРезультатОбработкиСущности(Сущность, НовыйИндекс);
    Возврат Результат;
КонецФункции

// Получение массива объектов из строк
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Массив - массив структур с описанием объектов
//
Функция ПолучитьМассивСущностей(Строки)
    Лог.Отладка("Начало извлечения сущностей из " + Строки.Количество() + " строк");
    
    МассивСущностей = Новый Массив();
    
    Для Индекс = 0 По Строки.Количество() - 1 Цикл
        Строка = Строки[Индекс];

        // Пропускаем пустые строки и комментарии
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Продолжить;
        КонецЕсли;
        
        РезультатОбработки = ОбработатьОднуСущность(Строка, Строки, Индекс, МассивСущностей);
        МассивСущностей.Добавить(РезультатОбработки.Сущность);
        Индекс = РезультатОбработки.НовыйИндекс;
    КонецЦикла;
    
    Лог.Отладка("Извлечение сущностей завершено, найдено " + МассивСущностей.Количество() + " сущностей");
    Возврат МассивСущностей;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ ДЛЯ ОБРАБОТКИ СТРОК И ОТСТУПОВ
////////////////////////////////////////////////////////////////////////////////

Функция ЗаменитьВСтрокеПрефиксОпределенияНаПробелы(Строка, Позиция)
    
    Отступ = "";
    Пока СтрДлина(Отступ) < Позиция Цикл
        Отступ = Отступ + " ";
    КонецЦикла;
    ПолучившаясяСтрока = Отступ + Сред(Строка, Позиция + 1);
    Возврат ПолучившаясяСтрока;
КонецФункции

Процедура ПроверитьВалидностьСущности(Сущность, МассивСущностей)
    
    Если МассивСущностей.Количество() = 0 Тогда
        Возврат; // Если массив пустой, то валидность не проверяем
    КонецЕсли;
    ПервыйОбъект = МассивСущностей[0];
    
    Если НЕ Сущность.МинимальныйОтступ = ПервыйОбъект.МинимальныйОтступ Тогда
        ТекстОшибки = СтрШаблон(
                "Отступ <%1> отличается от требуемого <%2>. Все сущности должны иметь одинаковый отступ.",
                Сущность.МинимальныйОтступ - 1, ПервыйОбъект.МинимальныйОтступ - 1);
        Лог.Ошибка(ТекстОшибки);
        ВызватьИсключение ТекстОшибки;
    КонецЕсли;
    
    Если НЕ (Сущность.ТипОбъекта = ПервыйОбъект.ТипОбъекта 
            ИЛИ (ЭтоТипОбъекта(Сущность.ТипОбъекта) И ЭтоТипОбъекта(ПервыйОбъект.ТипОбъекта))) Тогда
        ТекстОшибки = СтрШаблон(
                "Тип сущности <%1> отличается от требуемого <%2>. Все сущности должны иметь одинаковый тип.",
                Сущность.ТипОбъекта, ПервыйОбъект.ТипОбъекта);
        Лог.Ошибка(ТекстОшибки);
        ВызватьИсключение ТекстОшибки;
    КонецЕсли;

КонецПроцедуры

// Проверяет, является ли тип объектным типом (обычный объект или объект с явным ключом)
//
// Параметры:
//   ТипОбъекта - Строка - тип объекта для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если это объектный тип
//
Функция ЭтоТипОбъекта(ТипОбъекта)
    Возврат ТипОбъекта = "Объект" ИЛИ ТипОбъекта = "ОбъектЯвныйКлюч";
КонецФункции

// Функция для выделения содержимого из строк
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//   Индекс - Число - индекс строки для анализа
//   ТекущийОтступ - Число - минимальный отступ для выделения содержимого
//
// Возвращаемое значение:
//   Массив - массив строк, содержащих выделенное содержимое
//
Функция ВыделитьСодержимое(Строки, Индекс, ТекущийОтступ)
    
    Содержимое = Новый Массив();
    Для НомерСтроки = Индекс По Строки.Количество() - 1 Цикл
        Строка = Строки[НомерСтроки];
        Если ОпределитьОтступ(Строка) > ТекущийОтступ ИЛИ ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
            Содержимое.Добавить(Строка);
        Иначе
            Прервать;
        КонецЕсли;
    КонецЦикла;
    
    Возврат Содержимое;
КонецФункции

// Функция для выделения содержимого явного ключа (включает строку с : на том же уровне)
//
// Параметры:
//   Строки - Массив - массив строк для анализа
//   Индекс - Число - индекс строки для анализа
//   ТекущийОтступ - Число - минимальный отступ для выделения содержимого
//
// Возвращаемое значение:
//   Массив - массив строк, содержащих выделенное содержимое
//

// Проверяет является ли строка двоеточием с валидацией
//
// Параметры:
//   СтрокаБезОтступов - Строка - строка без отступов
//   ОтступСтроки - Число - отступ строки
//   ТекущийОтступ - Число - ожидаемый отступ
//
// Возвращаемое значение:
//   Булево - Истина, если строка начинается с двоеточия
Функция ЭтоДвоеточиеЯвногоКлюча(СтрокаБезОтступов, ОтступСтроки, ТекущийОтступ)
    Если НЕ СтрНачинаетсяС(СтрокаБезОтступов, ":") ИЛИ ОтступСтроки <> ТекущийОтступ Тогда
        Возврат Ложь;
    КонецЕсли;
    
    // Проверяем на табы после двоеточия - это запрещено YAML спецификацией
    ПроверитьОтсутствиеТабуляцииПослеДвоеточия(СтрокаБезОтступов);
    
    Возврат Истина;
КонецФункции

// Проверяет является ли строка новым явным ключом
//
// Параметры:
//   СтрокаБезОтступов - Строка - строка без отступов
//   ОтступСтроки - Число - отступ строки  
//   ТекущийОтступ - Число - ожидаемый отступ
//   НомерСтроки - Число - номер текущей строки
//   Индекс - Число - начальный индекс
//   НайденоДвоеточие - Булево - найдено ли двоеточие
//
// Возвращаемое значение:
//   Булево - Истина, если строка является новым явным ключом
Функция ЭтоНовыйЯвныйКлюч(СтрокаБезОтступов, ОтступСтроки, ТекущийОтступ, НомерСтроки, Индекс, НайденоДвоеточие)
    Если НЕ СтрНачинаетсяС(СтрокаБезОтступов, "?") ИЛИ ОтступСтроки <> ТекущийОтступ Тогда
        Возврат Ложь;
    КонецЕсли;
    
    // Новый явный ключ, если двоеточие найдено или это не первая строка
    Возврат НайденоДвоеточие ИЛИ НомерСтроки > Индекс;
КонецФункции

// Проверяет является ли строка якорем на том же уровне
//
// Параметры:
//   СтрокаБезОтступов - Строка - строка без отступов
//   ОтступСтроки - Число - отступ строки
//   ТекущийОтступ - Число - ожидаемый отступ
//
// Возвращаемое значение:
//   Булево - Истина, если строка является якорем на том же уровне
Функция ЭтоЯкорьНаТомЖеУровне(СтрокаБезОтступов, ОтступСтроки, ТекущийОтступ)
    Возврат СтрНачинаетсяС(СтрокаБезОтступов, "&") И ОтступСтроки = ТекущийОтступ;
КонецФункции

// Проверяет является ли строка обычным ключом на том же уровне
//
// Параметры:
//   СтрокаБезОтступов - Строка - строка без отступов
//   ОтступСтроки - Число - отступ строки
//   ТекущийОтступ - Число - ожидаемый отступ
//   НомерСтроки - Число - номер текущей строки
//   Индекс - Число - начальный индекс
//
// Возвращаемое значение:
//   Булево - Истина, если строка является обычным ключом на том же уровне
Функция ЭтоОбычныйКлючНаТомЖеУровне(СтрокаБезОтступов, ОтступСтроки, ТекущийОтступ, НомерСтроки, Индекс)
    Возврат ОтступСтроки = ТекущийОтступ 
        И НомерСтроки > Индекс 
        И Найти(СтрокаБезОтступов, ":") > 0 
        И НЕ СтрНачинаетсяС(СтрокаБезОтступов, ":");
КонецФункции

// Определяет действие для строки при выделении содержимого явного ключа
//
// Параметры:
//   Строка - Строка - исходная строка
//   НомерСтроки - Число - номер строки
//   Индекс - Число - начальный индекс
//   ТекущийОтступ - Число - текущий отступ
//   НайденоДвоеточие - Булево - найдено ли двоеточие (изменяется)
//
// Возвращаемое значение:
//   Строка - действие: "добавить", "двоеточие", "прервать", "пропустить"
Функция ОпределитьДействиеДляСтрокиЯвногоКлюча(Строка, НомерСтроки, Индекс, ТекущийОтступ, НайденоДвоеточие)
    ОтступСтроки = ОпределитьОтступ(Строка);
    
    Если ОтступСтроки < ТекущийОтступ И НЕ ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
        Лог.Отладка("Строка с меньшим отступом, завершаем блок");
        Возврат ДЕЙСТВИЕ_ПРЕРВАТЬ;
    КонецЕсли;
    
    СтрокаБезОтступов = СокрЛП(Строка);
    
    Если ЭтоДвоеточиеЯвногоКлюча(СтрокаБезОтступов, ОтступСтроки, ТекущийОтступ) Тогда
        Лог.Отладка("Найдено двоеточие, добавляем строку значения");
        НайденоДвоеточие = Истина;
        Возврат "двоеточие";
    КонецЕсли;
    
    Если ЭтоНовыйЯвныйКлюч(СтрокаБезОтступов, ОтступСтроки, ТекущийОтступ, НомерСтроки, Индекс, НайденоДвоеточие) Тогда
        Лог.Отладка("Найден следующий явный ключ, завершаем блок");
        Возврат ДЕЙСТВИЕ_ПРЕРВАТЬ;
    КонецЕсли;
    
    Если ЭтоЯкорьНаТомЖеУровне(СтрокаБезОтступов, ОтступСтроки, ТекущийОтступ) Тогда
        Лог.Отладка("Найден якорь на том же уровне, завершаем блок");
        Возврат ДЕЙСТВИЕ_ПРЕРВАТЬ;
    КонецЕсли;
    
    Если ЭтоОбычныйКлючНаТомЖеУровне(СтрокаБезОтступов, ОтступСтроки, ТекущийОтступ, НомерСтроки, Индекс) Тогда
        Лог.Отладка("Найден обычный ключ на том же уровне, завершаем блок");
        Возврат ДЕЙСТВИЕ_ПРЕРВАТЬ;
    КонецЕсли;
    
    Лог.Отладка("Добавляем строку в содержимое");
    Возврат "добавить";
КонецФункции

Функция ВыделитьСодержимоеЯвногоКлюча(Строки, Индекс, ТекущийОтступ)
    Содержимое = Новый Массив();
    НайденоДвоеточие = Ложь;
    
    Лог.Отладка("Выделение содержимого явного ключа начиная с индекса " + Индекс + ", отступ " + ТекущийОтступ);
    
    // Для явного ключа ищем строки до двоеточия (включая само двоеточие и значение после него)
    // Начинаем сразу с текущей строки, которая содержит "? ..."
    Для НомерСтроки = Индекс По Строки.Количество() - 1 Цикл
        Строка = Строки[НомерСтроки];
        Лог.Отладка("Анализ строки " + НомерСтроки + ": '" + Строка + "'");
        
        Действие = ОпределитьДействиеДляСтрокиЯвногоКлюча(Строка, НомерСтроки, Индекс, ТекущийОтступ, НайденоДвоеточие);
        
        Если Действие = "прервать" Тогда
            Прервать;
        ИначеЕсли Действие = "двоеточие" Тогда
            Содержимое.Добавить(Строка);
            НайденоДвоеточие = Истина;
        ИначеЕсли Действие = "добавить" Тогда
            Содержимое.Добавить(Строка);
        Иначе
            // Действие "пропустить" - ничего не делаем
            Продолжить;
        КонецЕсли;
    КонецЦикла;
    
    Лог.Отладка("Содержимое явного ключа выделено: " + Содержимое.Количество() + " строк");
    Возврат Содержимое;
КонецФункции

Функция ОпределитьОтступ(Строка)
    // Определяем отступ в строке (только пробелы в начале)
    // YAML спецификация: отступ может состоять только из пробелов
    Отступ = 0;
    Для а = 1 По СтрДлина(Строка) Цикл
        Символ = Сред(Строка, а, 1);
        Если Символ = " " Тогда
            Отступ = Отступ + 1;
        Иначе
            // Встретили любой не-пробельный символ (включая таб) - отступ закончился
            Прервать;
        КонецЕсли;
    КонецЦикла;
    
    Возврат Отступ;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПАРСЕРЫ МНОГОСТРОЧНЫХ СТРОК И СПЕЦИАЛЬНЫХ КОНСТРУКЦИЙ
////////////////////////////////////////////////////////////////////////////////

// Парсер многострочных строк
//
// Параметры:
//   МассивСтрок - Массив - массив строк для парсинга многострочной строки
//
// Возвращаемое значение:
//   Строка - результат парсинга многострочной строки
//
Функция ПарсерМногострочныхСтрок(МассивСтрок)
    
    // Определяем параметры многострочной строки
    ПараметрыМногострочнойСтроки = НайтиПараметрыМногострочнойСтроки(МассивСтрок);
    
    Если ПараметрыМногострочнойСтроки = Неопределено Тогда
        Возврат ""; // Не найден управляющий символ, возвращаем пустую строку
    КонецЕсли;
    
    // Извлекаем строки содержимого
    СтрокиСодержимого = ИзвлечьСодержимоеМногострочнойСтроки(МассивСтрок, ПараметрыМногострочнойСтроки);
    
    // Обрабатываем пустые строки в конце если необходимо
    СтрокиСодержимого = ОбработатьПустыеСтрокиВКонце(СтрокиСодержимого, ПараметрыМногострочнойСтроки);
    
    // Собираем финальную строку
    Возврат СобратьМногострочнуюСтроку(СтрокиСодержимого, ПараметрыМногострочнойСтроки);
    
КонецФункции

// Создает структуру параметров многострочной строки
//
// Параметры:
//   ТипСтроки - Строка - тип многострочной строки ("|" или ">")
//   УправляющийПодсимвол - Строка - подсимвол (+, -, или пустая строка)
//   ИндексНачалаСодержимого - Число - индекс строки начала содержимого
//   ОтступСодержимого - Число - отступ содержимого
//
// Возвращаемое значение:
//   Структура - структура параметров многострочной строки
//
Функция СоздатьПараметрыМногострочнойСтроки(ТипСтроки, УправляющийПодсимвол, ИндексНачалаСодержимого, ОтступСодержимого)
    Параметры = Новый Структура();
    Параметры.Вставить("ТипСтроки", ТипСтроки); // "|" или ">"
    Параметры.Вставить("СохранятьПустыеСтрокиВКонце", УправляющийПодсимвол = "+");
    Параметры.Вставить("ДобавлятьПереносПоследнейСтроки", УправляющийПодсимвол <> "-");
    Параметры.Вставить("ИндексНачалаСодержимого", ИндексНачалаСодержимого);
    Параметры.Вставить("ОтступСодержимого", ОтступСодержимого);
    
    Возврат Параметры;
КонецФункции

// Находит параметры многострочной строки по управляющим символам
//
// Параметры:
//   МассивСтрок - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Структура - параметры многострочной строки или Неопределено
//
Функция НайтиПараметрыМногострочнойСтроки(МассивСтрок)
    Лог.Отладка("Поиск параметров многострочной строки");
    
    Для Индекс = 0 По МассивСтрок.Количество() - 1 Цикл
        Строка = МассивСтрок[Индекс];
        
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) тогда
            Продолжить; // Пропускаем пустые строки и комментарии
        КонецЕсли;
        
        Строка = УбратьКомментарийИзСтроки(Строка);
        ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
        
        Если НЕ (ДанныеУправляющегоСимвола.Символ = "|" ИЛИ ДанныеУправляющегоСимвола.Символ = ">") тогда
            Лог.Ошибка("Ожидался управляющий символ многострочной строки, но найдено: " + Строка);
            ВызватьИсключение "Ожидался управляющий символ многострочной строки, но найдено: " + Строка;
        КонецЕсли;
        
        УправляющийПодсимвол = ПолучитьУправляющийПодсимвол(Строка, ДанныеУправляющегоСимвола.Позиция + 1);
        Лог.Отладка("Найден управляющий символ: " + ДанныеУправляющегоСимвола.Символ + " с подсимволом: " + УправляющийПодсимвол);
        Если Не СокрЛП(СтрЗаменить(Строка, ДанныеУправляющегоСимвола.Символ+УправляющийПодсимвол, "")) = "" Тогда
            Лог.Ошибка("В многострочной строке не должно быть ничего после управляющей последовательности");
            ВызватьИсключение "В многострочной строке не должно быть ничего после управляющей последовательности";
        КонецЕсли;

        // Определяем отступ для содержимого
        ОтступСодержимого = 0;
        Если Индекс + 1 < МассивСтрок.Количество() Тогда
            ОтступСодержимого = ОпределитьОтступ(МассивСтрок[Индекс + 1]);
        КонецЕсли;
        
        Параметры = СоздатьПараметрыМногострочнойСтроки(
            ДанныеУправляющегоСимвола.Символ, 
            УправляющийПодсимвол, 
            Индекс + 1, 
            ОтступСодержимого
        );
        
        Лог.Отладка("Параметры многострочной строки найдены");
        Возврат Параметры;
    КонецЦикла;
    
    Лог.Предупреждение("Управляющий символ многострочной строки не найден");
    Возврат Неопределено; // Управляющий символ не найден
    
КонецФункции

// Извлекает строки содержимого многострочной строки
//
// Параметры:
//   МассивСтрок - Массив - исходный массив строк
//   Параметры - Структура - параметры многострочной строки
//
// Возвращаемое значение:
//   Массив - массив строк содержимого
//
Функция ИзвлечьСодержимоеМногострочнойСтроки(МассивСтрок, Параметры)
    Лог.Отладка("Извлечение содержимого многострочной строки");
    
    СтрокиСодержимого = Новый Массив();
    
    Для Индекс = Параметры.ИндексНачалаСодержимого По МассивСтрок.Количество() - 1 Цикл
        ИсходнаяСтрока = МассивСтрок[Индекс];
        
        Если ОпределитьОтступ(ИсходнаяСтрока) < Параметры.ОтступСодержимого 
            И Не ЭтоПустаяСтрокаИлиКомментарий(ИсходнаяСтрока) Тогда
             Лог.Ошибка("Отступ строки меньше требуемого");
             ВызватьИсключение "Отступ строки меньше требуемого"; // Прерываем, если отступ меньше, чем заданный
        КонецЕсли;  
        // Убираем отступ с учетом базового отступа содержимого
        СтрокаБезОтступа = Сред(ИсходнаяСтрока, Параметры.ОтступСодержимого + 1);
        СтрокиСодержимого.Добавить(СтрокаБезОтступа);
    КонецЦикла;
    
    Лог.Отладка("Извлечено " + СтрокиСодержимого.Количество() + " строк содержимого");
    Возврат СтрокиСодержимого;
    
КонецФункции

// Обрабатывает пустые строки в конце массива строк
//
// Параметры:
//   СтрокиСодержимого - Массив - строки содержимого
//   Параметры - Структура - параметры многострочной строки
//
// Возвращаемое значение:
//   Массив - обработанный массив строк
//
Функция ОбработатьПустыеСтрокиВКонце(СтрокиСодержимого, Параметры)
    
    Если Параметры.СохранятьПустыеСтрокиВКонце Тогда
        Возврат СтрокиСодержимого; // Сохраняем все строки как есть
    КонецЕсли;
    
    // Удаляем пустые строки с конца
    Пока СтрокиСодержимого.Количество() > 0 
        И СтрЗаменить(СтрокиСодержимого[СтрокиСодержимого.Количество() - 1], " ", "") = "" Цикл
        СтрокиСодержимого.Удалить(СтрокиСодержимого.Количество() - 1);
    КонецЦикла;
    
    Возврат СтрокиСодержимого;
    
КонецФункции

// Собирает финальную многострочную строку
//
// Параметры:
//   СтрокиСодержимого - Массив - строки содержимого
//   Параметры - Структура - параметры многострочной строки
//
// Возвращаемое значение:
//   Строка - собранная многострочная строка
//
Функция СобратьМногострочнуюСтроку(СтрокиСодержимого, Параметры)
    
    Если СтрокиСодержимого.Количество() = 0 Тогда
        Возврат "";
    КонецЕсли;
    
    // Соединяем строки разделителем
    
    
    // Заменяем двойные пробелы на переносы строк для блочного стиля
    Если Параметры.ТипСтроки = ">" Тогда
        РезультирующаяСтрока = СобратьСтрокуИзМассива(СтрокиСодержимого);
    Иначе
        РезультирующаяСтрока = СтрСоединить(СтрокиСодержимого, Символы.ПС);
    КонецЕсли;
    
    // Добавляем перенос строки в конце если необходимо
    Если Параметры.ДобавлятьПереносПоследнейСтроки Тогда
        РезультирующаяСтрока = РезультирующаяСтрока + Символы.ПС;
    КонецЕсли;
    
    Возврат РезультирующаяСтрока;
    
КонецФункции

Функция ПолучитьУправляющийПодсимвол(Строка, Позиция)
    Если СтрДлина(Строка) < Позиция Тогда
        Возврат ""; // Нет подсимвола, возвращаем пустую строку
    КонецЕсли;
    Возврат СокрЛП(Сред(Строка, Позиция, МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ));
КонецФункции

Функция СобратьСтрокуИзМассива(МассивСтрок)
    Результат = "";
    СтрокаБезРазделителя = Истина;
    Для Каждого Строка Из МассивСтрок Цикл
        Если ЭтоПустаяСтрокаПослеОбрезки(Строка) Тогда
            Результат = Результат + Символы.ПС;
            СтрокаБезРазделителя = Истина;
        Иначе
            Результат = Результат + ?(СтрокаБезРазделителя,"", " ")+ Строка;
            СтрокаБезРазделителя = Ложь; 
        КонецЕсли;        
    КонецЦикла;
    Возврат СокрЛП(Результат);
    
КонецФункции

// Создает структуру параметров якоря
//
// Параметры:
//   ИмяЯкоря - Строка - имя якоря
//   ИндексСтрокиСЯкорем - Число - индекс строки с якорем
//
// Возвращаемое значение:
//   Структура - структура параметров якоря
//
Функция СоздатьПараметрыЯкоря(ИмяЯкоря, ИндексСтрокиСЯкорем)
    Параметры = Новый Структура();
    Параметры.Вставить("ИмяЯкоря", ИмяЯкоря);
    Параметры.Вставить("ИндексСтрокиСЯкорем", ИндексСтрокиСЯкорем);
    
    Возврат Параметры;
КонецФункции

// Находит параметры якоря по управляющему символу &
//
// Параметры:
//   МассивСтрок - Массив - массив строк для анализа
//
// Возвращаемое значение:
//   Структура - параметры якоря или Неопределено
//
Функция НайтиПараметрыЯкоря(МассивСтрок)
    Лог.Отладка("Поиск параметров якоря");
    
    Для Индекс = 0 По МассивСтрок.Количество() - 1 Цикл
        Строка = МассивСтрок[Индекс];
        
        Если ЭтоПустаяСтрокаИлиКомментарий(Строка) тогда
            Продолжить; // Пропускаем пустые строки и комментарии
        КонецЕсли;
        
        ДанныеУправляющегоСимвола = НайтиУправляющийСимволИЕгоПозицию(Строка);
        
        Если НЕ ДанныеУправляющегоСимвола.Символ = "&" тогда
            Лог.Ошибка("Ожидался управляющий символ якоря (&), но найдено: " + Строка);
            ВызватьИсключение "Ожидался управляющий символ якоря (&), но найдено: " + Строка;
        КонецЕсли;
        
        
        // Извлекаем имя якоря
        ИмяЯкоря = МенеджерЯкорей.ИзвлечьИмяЯкоряИлиАлиаса(Строка);
        Если ПустаяСтрока(ИмяЯкоря) Тогда
            Лог.Ошибка("Не удалось извлечь имя якоря из строки: " + Строка);
            ВызватьИсключение "Не удалось извлечь имя якоря из строки: " + Строка;
        КонецЕсли;
        
        Лог.Отладка("Найден якорь с именем: " + ИмяЯкоря);
        
        Параметры = СоздатьПараметрыЯкоря(ИмяЯкоря, Индекс);
        
        Возврат Параметры;
    КонецЦикла;
    
    Лог.Предупреждение("Управляющий символ якоря не найден");
    Возврат Неопределено; // Управляющий символ якоря не найден
    
КонецФункции

// Извлекает строки содержимого якоря (убирает строку с определением якоря)
//
// Параметры:
//   МассивСтрок - Массив - исходный массив строк
//   Параметры - Структура - параметры якоря
//
// Возвращаемое значение:
//   Массив - массив строк содержимого без определения якоря
//
Функция ИзвлечьСодержимоеЯкоря(МассивСтрок, Параметры)
    
    СтрокиСодержимого = Новый Массив();
    
    // Обрабатываем строку с якорем - убираем определение якоря
    СтрокаСЯкорем = МассивСтрок[Параметры.ИндексСтрокиСЯкорем];
    ОчищеннаяСтрока = МенеджерЯкорей.УдалитьОпределениеЯкоря(СтрокаСЯкорем);
   
    СтрокиСодержимого.Добавить(ОчищеннаяСтрока);
   
    
    // Добавляем все остальные строки
    Для Индекс = Параметры.ИндексСтрокиСЯкорем + 1 По МассивСтрок.Количество() - 1 Цикл
        СтрокиСодержимого.Добавить(МассивСтрок[Индекс]);
    КонецЦикла;

    Возврат СтрокиСодержимого;
    
КонецФункции

// Проверяет корректность YAML строки flow последовательности
//
// Параметры:
//   СтрокаFlow - Строка - строка flow последовательности для проверки
//
// Исключения:
//   При некорректном формате flow последовательности
//
Процедура ВалидироватьFlowПоследовательность(СтрокаFlow)
    Если ПустаяСтрока(СтрокаFlow) Тогда
        Лог.Ошибка("Не найдена строка с flow последовательностью");
        ВызватьИсключение "Не найдена строка с flow последовательностью";
    КонецЕсли;
    
    Если НЕ СтрНачинаетсяС(СтрокаFlow, "[") Тогда
        Лог.Ошибка("Flow последовательность должна начинаться с [. Получено: " + СтрокаFlow);
        ВызватьИсключение "Flow последовательность должна начинаться с [";
    КонецЕсли;
КонецПроцедуры

// Парсер flow последовательностей (массивов в стиле [1, 2, 3])
//
// Параметры:
//   Строки - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Массив - результат парсинга flow последовательности
//
Функция ПарсерFlowПоследовательности(Строки)
    Лог.Отладка("Начало парсинга flow последовательности");
    
    // Объединяем все строки в одну, удаляя комментарии
    СтрокаFlow = ОбъединитьСтрокиFlowСинтаксиса(Строки);
    
    // Валидируем строку flow последовательности
    ВалидироватьFlowПоследовательность(СтрокаFlow);
    
    // Найдем позицию соответствующей закрывающей скобки
    ПозицияЗакрытия = НайтиСоответствующуюЗакрывающуюСкобку(СтрокаFlow, 1);
    Если ПозицияЗакрытия = 0 Тогда
        Лог.Ошибка("Flow последовательность должна заканчиваться ]. Получено: " + СтрокаFlow);
        ВызватьИсключение "Flow последовательность должна заканчиваться ]";
    КонецЕсли;
    
    // Проверим, что после соответствующей закрывающей скобки нет значащих символов
    ОстатокСтроки = СокрЛП(Сред(СтрокаFlow, ПозицияЗакрытия + 1));
    Если НЕ ПустаяСтрока(ОстатокСтроки) Тогда
        Лог.Ошибка("После закрывающей скобки flow последовательности не должно быть других символов. Получено: " + СтрокаFlow);
        ВызватьИсключение "После закрывающей скобки flow последовательности не должно быть других символов";
    КонецЕсли;

    СодержимоеМассива = Сред(СтрокаFlow, МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ, ПозицияЗакрытия - МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ);
    Лог.Отладка("Содержимое flow последовательности: " + СодержимоеМассива);
    
    // Проверяем валидность синтаксиса
    ПроверитьВалидностьFlowПоследовательности(СодержимоеМассива);
    
    // Разбираем элементы
    Элементы = РазбитьFlowЭлементы(СодержимоеМассива);
    
    МассивРезультат = Новый Массив();
    Для Каждого Элемент Из Элементы Цикл
        ОчищенныйЭлемент = СокрЛП(Элемент);
        Если НЕ ПустаяСтрока(ОчищенныйЭлемент) Тогда
            // Рекурсивно обрабатываем каждый элемент
            СтрокиЭлемента = Новый Массив();
            СтрокиЭлемента.Добавить(ОчищенныйЭлемент);
            МассивРезультат.Добавить(ДанныеИзМассиваСтрок(СтрокиЭлемента));
        КонецЕсли;
    КонецЦикла;
    
    Лог.Отладка("Парсинг flow последовательности завершен, получено " + МассивРезультат.Количество() + " элементов");
    Возврат МассивРезультат;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ ДЛЯ FLOW-СИНТАКСИСА
////////////////////////////////////////////////////////////////////////////////

// Объединяет массив строк в одну строку, удаляя комментарии
//
// Параметры:
//   Строки - Массив - массив строк для объединения
//
// Возвращаемое значение:
//   Строка - объединенная строка без комментариев
//
Функция ОбъединитьСтрокиFlowСинтаксиса(Строки)
    СтрокаFlow = "";
    Для Каждого Строка Из Строки Цикл
        Если НЕ ПустаяСтрока(СокрЛП(Строка)) Тогда
            // Удаляем комментарии из строки
            СтрокаБезКомментария = УбратьКомментарийИзСтроки(Строка);
            Если НЕ ПустаяСтрока(СокрЛП(СтрокаБезКомментария)) Тогда
                СтрокаFlow = СтрокаFlow + " " + СокрЛП(СтрокаБезКомментария);
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
    Возврат СокрЛП(СтрокаFlow);
КонецФункции

// Обрабатывает один элемент flow объекта
//
// Параметры:
//   ОчищенныйЭлемент - Строка - элемент для обработки
//   СоответствиеРезультат - Соответствие - результирующее соответствие
//
Процедура ОбработатьЭлементFlowОбъекта(ОчищенныйЭлемент, СоответствиеРезультат)
    Если ПустаяСтрока(ОчищенныйЭлемент) Тогда
        Возврат;
    КонецЕсли;
    
    // Ищем разделитель ключ-значение
    ПозицияДвоеточия = ПозицияНеЭкранированногоСимвола(ОчищенныйЭлемент, ":", Истина);
    Если ПозицияДвоеточия = 0 Тогда
        Лог.Отладка("Не найден разделитель ':' в элементе flow объекта: " + ОчищенныйЭлемент);
        Ключ = ОчищенныйЭлемент;
        Значение = "";
    Иначе
        Ключ = СокрЛП(Лев(ОчищенныйЭлемент, ПозицияДвоеточия - 1));
        Значение = ИзвлечьЗначениеПослеДвоеточияСОчисткой(ОчищенныйЭлемент, ПозицияДвоеточия);
    КонецЕсли;
    
    // Убираем кавычки с ключа
    Ключ = УбратьКавычки(Ключ);
    
    // Обрабатываем пустые значения
    Если ПустаяСтрока(Значение) Тогда
        СоответствиеРезультат.Вставить(Ключ, Null);
    Иначе
        // Рекурсивно обрабатываем значение
        СтрокиЗначения = Новый Массив();
        СтрокиЗначения.Добавить(Значение);
        СоответствиеРезультат.Вставить(Ключ, ДанныеИзМассиваСтрок(СтрокиЗначения));
    КонецЕсли;
КонецПроцедуры

// Проверяет корректность YAML строки flow объекта
//
// Параметры:
//   СтрокаFlow - Строка - строка flow объекта для проверки
//
// Исключения:
//   При некорректном формате flow объекта
//
Процедура ВалидироватьFlowОбъект(СтрокаFlow)
    Если ПустаяСтрока(СтрокаFlow) Тогда
        Лог.Ошибка("Не найдена строка с flow объектом");
        ВызватьИсключение "Не найдена строка с flow объектом";
    КонецЕсли;
    
    Если НЕ (СтрНачинаетсяС(СтрокаFlow, "{") И СтрЗаканчиваетсяНа(СтрокаFlow, "}")) Тогда
        Лог.Ошибка("Flow объект должен начинаться с { и заканчиваться }. Получено: " + СтрокаFlow);
        ВызватьИсключение "Flow объект должен начинаться с { и заканчиваться }";
    КонецЕсли;
КонецПроцедуры

// Парсер flow объектов (объектов в стиле {key1: value1, key2: value2})
//
// Параметры:
//   Строки - Массив - массив строк для парсинга
//
// Возвращаемое значение:
//   Соответствие - результат парсинга flow объекта
//
Функция ПарсерFlowОбъекта(Строки)
    Лог.Отладка("Начало парсинга flow объекта");
    
    // Объединяем все строки в одну, удаляя комментарии
    СтрокаFlow = ОбъединитьСтрокиFlowСинтаксиса(Строки);
    
    // Валидируем строку flow объекта
    ВалидироватьFlowОбъект(СтрокаFlow);
    
    СодержимоеОбъекта = УдалитьПервыйИПоследнийСимволы(СтрокаFlow);
    Лог.Отладка("Содержимое flow объекта: " + СодержимоеОбъекта);
    
    // Проверяем валидность синтаксиса
    ПроверитьВалидностьFlowОбъекта(СодержимоеОбъекта);
    
    // Разбираем пары ключ-значение
    Элементы = РазбитьFlowЭлементы(СодержимоеОбъекта);
    
    СоответствиеРезультат = Новый Соответствие();
    Для Каждого Элемент Из Элементы Цикл
        ОчищенныйЭлемент = СокрЛП(Элемент);
        ОбработатьЭлементFlowОбъекта(ОчищенныйЭлемент, СоответствиеРезультат);
    КонецЦикла;
    
    Лог.Отладка("Парсинг flow объекта завершен, получено " + СоответствиеРезультат.Количество() + " свойств");
    Возврат СоответствиеРезультат;
КонецФункции

// Разбивает строку flow элементов на отдельные элементы с учетом вложенности
//
// Параметры:
//   СтрокаЭлементов - Строка - строка с элементами для разбиения
//
// Возвращаемое значение:
//   Массив - массив отдельных элементов
//
Функция РазбитьFlowЭлементы(СтрокаЭлементов)
    Лог.Отладка("Разбиение flow элементов: " + СтрокаЭлементов);
    
    Элементы = Новый Массив();
    ТекущийЭлемент = "";
    УровеньВложенности = 0;
    ВКавычках = Ложь;
    ТипКавычек = "";
    
    Для Позиция = 1 По СтрДлина(СтрокаЭлементов) Цикл
        Символ = Сред(СтрокаЭлементов, Позиция, 1);
        
        // Обработка кавычек
        Если ОбработатьКавычки(Символ, ВКавычках, ТипКавычек) Тогда
            ТекущийЭлемент = ТекущийЭлемент + Символ;
            Продолжить;
        КонецЕсли;
        
        Если НЕ ВКавычках Тогда
            // Обрабатываем элементы вне кавычек
            Если ОбработатьЭлементВнеКавычек(Символ, УровеньВложенности, ТекущийЭлемент, Элементы) Тогда
                Продолжить;
            КонецЕсли;
        КонецЕсли;
        
        ТекущийЭлемент = ТекущийЭлемент + Символ;
    КонецЦикла;
    
    // Добавляем последний элемент
    Если НЕ ПустаяСтрока(ТекущийЭлемент) Тогда
        Элементы.Добавить(ТекущийЭлемент);
    КонецЕсли;
    
    Лог.Отладка("Разбиение завершено, получено " + Элементы.Количество() + " элементов");
    Возврат Элементы;
КонецФункции

// Обрабатывает кавычки в flow элементах
//
// Параметры:
//   Символ - Строка - текущий символ
//   ВКавычках - Булево - флаг нахождения в кавычках (передается по ссылке)
//   ТипКавычек - Строка - тип кавычек (передается по ссылке)
//
// Возвращаемое значение:
//   Булево - Истина, если символ обработан как кавычка
//
Функция ОбработатьКавычки(Символ, ВКавычках, ТипКавычек)
    
    Если (Символ = """" ИЛИ Символ = "'") И НЕ ВКавычках Тогда
        ВКавычках = Истина;
        ТипКавычек = Символ;
        Возврат Истина;
    ИначеЕсли ВКавычках И Символ = ТипКавычек Тогда
        ВКавычках = Ложь;
        ТипКавычек = "";
        Возврат Истина;
    Иначе
        Возврат Ложь;
    КонецЕсли;
    
КонецФункции

// Обрабатывает элемент вне кавычек
//
// Параметры:
//   Символ - Строка - текущий символ
//   УровеньВложенности - Число - уровень вложенности (передается по ссылке)
//   ТекущийЭлемент - Строка - текущий элемент (передается по ссылке)
//   Элементы - Массив - массив элементов (передается по ссылке)
//
// Возвращаемое значение:
//   Булево - Истина, если нужно продолжить итерацию
//
Функция ОбработатьЭлементВнеКавычек(Символ, УровеньВложенности, ТекущийЭлемент, Элементы)
    
    Если Символ = "[" ИЛИ Символ = "{" Тогда
        УровеньВложенности = УровеньВложенности + 1;
    ИначеЕсли Символ = "]" ИЛИ Символ = "}" Тогда
        УровеньВложенности = УровеньВложенности - 1;
    ИначеЕсли Символ = "," И УровеньВложенности = 0 Тогда
        // Это разделитель элементов на верхнем уровне
        Элементы.Добавить(ТекущийЭлемент);
        ТекущийЭлемент = "";
        Возврат Истина;
    Иначе
        Возврат Ложь;
    КонецЕсли;
    
    Возврат Ложь;
    
КонецФункции

// Проверяет валидность flow последовательности
//
// Параметры:
//   СодержимоеМассива - Строка - содержимое между [ и ]
//
// Исключения:
//   При обнаружении некорректного синтаксиса
//
Процедура ПроверитьВалидностьFlowПоследовательности(СодержимоеМассива)
    
    Если ПустаяСтрока(СокрЛП(СодержимоеМассива)) Тогда
        Возврат; // Пустая последовательность валидна
    КонецЕсли;
    
    // Проверяем на недопустимые символы в начале
    ОчищенноеСодержимое = СокрЛП(СодержимоеМассива);
    Если СтрНачинаетсяС(ОчищенноеСодержимое, ",") Тогда
        Лог.Ошибка("Flow последовательность не может начинаться с запятой");
        ВызватьИсключение "Flow последовательность не может начинаться с запятой";
    КонецЕсли;
    
    Если СтрНачинаетсяС(ОчищенноеСодержимое, "-") Тогда
        Лог.Ошибка("Flow последовательность не может содержать дефисы");
        ВызватьИсключение "Flow последовательность не может содержать дефисы";
    КонецЕсли;
    
    // Проверяем на двойные запятые (недопустимо)
    Если СтрНайти(СодержимоеМассива, ",,") > 0 Тогда
        Лог.Ошибка(ОШИБКА_ЛИШНИЕ_ЗАПЯТЫЕ_FLOW);
        ВызватьИсключение ОШИБКА_ЛИШНИЕ_ЗАПЯТЫЕ_FLOW;
    КонецЕсли;
    
    // Проверяем на запятые с пробелами между ними (тоже недопустимо)
    Если СтрНайти(СодержимоеМассива, ", ,") > 0 Тогда
        Лог.Ошибка(ОШИБКА_ЛИШНИЕ_ЗАПЯТЫЕ_FLOW);
        ВызватьИсключение ОШИБКА_ЛИШНИЕ_ЗАПЯТЫЕ_FLOW;
    КонецЕсли;
    
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// МЕТОДЫ ВАЛИДАЦИИ И ПРОВЕРКИ СИНТАКСИСА
////////////////////////////////////////////////////////////////////////////////

// Проверяет валидность flow объекта
//
// Параметры:
//   СодержимоеОбъекта - Строка - содержимое между { и }
//
// Возвращаемое значение:
//   Булево - истина, если синтаксис корректен
//
Функция ПроверитьВалидностьFlowОбъекта(СодержимоеОбъекта)
    
    // Проверяем на недопустимые конструкции
    ОчищенноеСодержимое = СокрЛП(СодержимоеОбъекта);
    
    // Проверяем на недопустимые запятые
    Если СтрНачинаетсяС(ОчищенноеСодержимое, ",") Тогда
        Лог.Ошибка("Flow объект не может начинаться с запятой");
        ВызватьИсключение "Flow объект не может начинаться с запятой";
    КонецЕсли;
    
    Возврат Истина;
    
КонецФункции

// Поиск соответствующей закрывающей скобки с учетом вложенности
//
// Параметры:
//   Строка - Строка - строка для поиска
//   НачальнаяПозиция - Число - позиция открывающей скобки
//
// Возвращаемое значение:
//   Число - позиция соответствующей закрывающей скобки или 0, если не найдена
//
Функция НайтиСоответствующуюЗакрывающуюСкобку(Строка, НачальнаяПозиция)
    
    УровеньВложенности = 1;
    ДлинаСтроки = СтрДлина(Строка);
    
    Для Позиция = НачальнаяПозиция + 1 По ДлинаСтроки Цикл
        Символ = Сред(Строка, Позиция, 1);
        
        Если Символ = "[" Тогда
            УровеньВложенности = УровеньВложенности + 1;
        ИначеЕсли Символ = "]" Тогда
            УровеньВложенности = УровеньВложенности - 1;
            Если УровеньВложенности = 0 Тогда
                Возврат Позиция;
            КонецЕсли;
        Иначе
            Продолжить;
        КонецЕсли;
    КонецЦикла;
    
    Возврат 0; // Не найдена соответствующая закрывающая скобка
    
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ИНИЦИАЛИЗАЦИЯ МОДУЛЯ
////////////////////////////////////////////////////////////////////////////////

// Инициализация константы YAML символов
YAML_РАЗДЕЛИТЕЛЬ_ДОКУМЕНТА = "---";
YAML_ТЕРМИНАТОР_ДОКУМЕНТА = "...";

// Инициализация констант для работы со строками
МИНИМАЛЬНАЯ_ДЛИНА_ДЛЯ_ПОДСТРОКИ = 2;
ДЕЙСТВИЕ_ПРЕРВАТЬ = "прервать";
ОШИБКА_ЛИШНИЕ_ЗАПЯТЫЕ_FLOW = "Flow последовательность содержит лишние запятые";

// Инициализация логгера модуля
Лог = Логирование.ПолучитьЛог("oscript.oscript-yaml.deserializer");

////////////////////////////////////////////////////////////////////////////////
// АРХИТЕКТУРНЫЕ ЗАМЕТКИ
//
// Модуль организован по принципу разделения ответственности:
// 1. Публичные методы - точки входа в модуль
// 2. Методы работы с документами - разбиение на документы, обработка разделителей
// 3. Методы работы со строками и комментариями - очистка, обработка кавычек
// 4. Методы определения типов данных - анализ содержимого для выбора парсера
// 5. Основные парсеры типов данных - парсинг различных YAML-структур
// 6. Парсеры многострочных строк - специальная обработка | и > синтаксиса
// 7. Вспомогательные методы для flow-синтаксиса - парсинг [...] и {...}
// 8. Вспомогательные методы для строк и отступов - работа с форматированием
// 9. Методы валидации и проверки синтаксиса - контроль корректности YAML
//
// Каждая секция содержит логически связанные функции, что упрощает навигацию
// и поддержку кода.
////////////////////////////////////////////////////////////////////////////////