// Модуль для парсинга Flow Style структур YAML ([массивы] и {объекты})
//)

// Функция для парсинга Flow style массивов и объектов
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для парсинга
//
// Возвращаемое значение:
//   Массив, Соответствие, Неопределено - результат парсинга
//
Функция ПарсингFlowStyle(ЗначениеСтрока) Экспорт
	// Определяем тип структуры: массив [] или объект {}
	ОчищеннаяСтрока = СокрЛП(ЗначениеСтрока);
	
	Если Лев(ОчищеннаяСтрока, 1) = "[" И Прав(ОчищеннаяСтрока, 1) = "]" Тогда
		Возврат ПарсингFlowStyleМассив(ЗначениеСтрока);
	ИначеЕсли Лев(ОчищеннаяСтрока, 1) = "{" И Прав(ОчищеннаяСтрока, 1) = "}" Тогда
		Возврат ПарсингFlowStyleОбъект(ЗначениеСтрока);
	ИначеЕсли Лев(ОчищеннаяСтрока, 1) = "[" ИЛИ Лев(ОчищеннаяСтрока, 1) = "{" Тогда
		// Проверяем на незакрытые скобки только в случае, если это явно
		// похоже на flow style структуру (начинается с открывающей скобки)
		ВызватьИсключение "Ошибка парсинга YAML: незакрытая скобка в структуре Flow style";
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Функция для парсинга массивов Flow style [value1, value2, ...]
//
// Параметры:
//   ЗначениеСтрока - Строка - строка, содержащая flow style массив
//
// Возвращаемое значение:
//   Массив - распарсенный массив значений
//
Функция ПарсингFlowStyleМассив(ЗначениеСтрока) Экспорт
	// Удаляем квадратные скобки
	СодержимоеМассива = Сред(ЗначениеСтрока, 2, СтрДлина(ЗначениеСтрока) - 2);
	
	Если ПустаяСтрока(СокрЛП(СодержимоеМассива)) Тогда
		Возврат Новый Массив; // Пустой массив
	КонецЕсли;
	
	Элементы = РазделитьЭлементыНаВерхнемУровне(СодержимоеМассива, ",");
	МассивРезультат = Новый Массив;
	
	Для Каждого Элемент Из Элементы Цикл
		ЗначениеЭлемента = СокрЛП(Элемент);
		ЗначениеЭлемента = ПарсерУровней.УдалитьКомментарии(ЗначениеЭлемента);
		
		Если НЕ ПустаяСтрока(ЗначениеЭлемента) Тогда
			ЗначениеДляДобавления = ОбработатьЭлементFlowStyleМассива(ЗначениеЭлемента);
			МассивРезультат.Добавить(ЗначениеДляДобавления);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивРезультат;
КонецФункции

// Обработка элемента Flow style массива
//
// Параметры:
//   ЗначениеЭлемента - Строка - элемент массива
//
// Возвращаемое значение:
//   Произвольный - обработанное значение
//
Функция ОбработатьЭлементFlowStyleМассива(ЗначениеЭлемента)
	// Проверяем на null
	Если НРег(ЗначениеЭлемента) = "null" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Проверяем, является ли элемент вложенной структурой
	Если ЭтоFlowStyleСтруктура(ЗначениеЭлемента) Тогда
		Возврат ПарсингFlowStyle(ЗначениеЭлемента);
	Иначе
		Возврат ПреобразовательЗначений.ПреобразоватьЗначение(ЗначениеЭлемента);
	КонецЕсли;
КонецФункции

// Проверка, является ли строка Flow style структурой
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если это Flow style структура
//
Функция ЭтоFlowStyleСтруктура(ЗначениеСтрока)
	Возврат (Лев(ЗначениеСтрока, 1) = "[" И Прав(ЗначениеСтрока, 1) = "]") 
		ИЛИ (Лев(ЗначениеСтрока, 1) = "{" И Прав(ЗначениеСтрока, 1) = "}");
КонецФункции

// Функция для парсинга объектов Flow style {key1: value1, key2: value2, ...}
//
// Параметры:
//   ЗначениеСтрока - Строка - строка, содержащая flow style объект
//
// Возвращаемое значение:
//   Соответствие - распарсенный объект с ключами и значениями
//
Функция ПарсингFlowStyleОбъект(ЗначениеСтрока)
	// Удаляем фигурные скобки
	СодержимоеОбъекта = Сред(ЗначениеСтрока, 2, СтрДлина(ЗначениеСтрока) - 2);
	
	Если ПустаяСтрока(СокрЛП(СодержимоеОбъекта)) тогда
		Возврат Новый Соответствие; // Пустой объект
	КонецЕсли;
	
	Пары = РазделитьЭлементыНаВерхнемУровне(СодержимоеОбъекта, ",");
	ОбъектРезультат = Новый Соответствие;
	
	Для Каждого Пара Из Пары Цикл
		ОбработатьПаруКлючЗначениеFlowStyle(Пара, ОбъектРезультат);
	КонецЦикла;
	
	Возврат ОбъектРезультат;
КонецФункции

// Обработка пары ключ-значение в Flow style объекте
//
// Параметры:
//   Пара - Строка - строка с парой ключ-значение
//   ОбъектРезультат - Соответствие - объект для добавления пары
//
Процедура ОбработатьПаруКлючЗначениеFlowStyle(Пара, ОбъектРезультат)
	ЗначениеПары = СокрЛП(Пара);
	ЗначениеПары = ПарсерУровней.УдалитьКомментарии(ЗначениеПары);
	
	Если ПустаяСтрока(ЗначениеПары) Тогда
		Возврат;
	КонецЕсли;
	
	ПозицияДвоеточия = Найти(ЗначениеПары, ":");
	Если ПозицияДвоеточия = 0 Тогда
		Возврат; // Некорректная пара
	КонецЕсли;
	
	Ключ = СокрЛП(Лев(ЗначениеПары, ПозицияДвоеточия - 1));
	ЗначениеКлюча = СокрЛП(Сред(ЗначениеПары, ПозицияДвоеточия + 1));
	
	// Убираем кавычки из ключа, если они есть
	Если ПреобразовательЗначений.ЭтоСтрокаВКавычках(Ключ) Тогда
		Ключ = Сред(Ключ, 2, СтрДлина(Ключ) - 2);
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ЗначениеКлюча) Тогда
		// Проверяем, является ли значение вложенной структурой
		ВложеннаяСтруктура = ПарсингFlowStyle(ЗначениеКлюча);
		Если ВложеннаяСтруктура <> Неопределено Тогда
			ОбъектРезультат.Вставить(Ключ, ВложеннаяСтруктура);
		Иначе
			ОбъектРезультат.Вставить(Ключ, ПреобразовательЗначений.ПреобразоватьЗначение(ЗначениеКлюча));
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Функция для разделения элементов на верхнем уровне структуры, учитывая вложенность
// 
// Параметры:
//   Строка - Строка - строка для разделения
//   Разделитель - Строка - символ-разделитель элементов
//
// Возвращаемое значение:
//   Массив - массив разделенных элементов
//
Функция РазделитьЭлементыНаВерхнемУровне(Строка, Разделитель)
	Результат = Новый Массив;
	Буфер = "";
	Счетчики = СоздатьСчетчикиВложенности();
	
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Позиция, 1);
		
		ОбработатьСимвол(Символ, Буфер, Счетчики, Разделитель, Результат);
	КонецЦикла;
	
	ПроверитьЗакрытыеСкобки(Счетчики);
	
	// Добавляем последний элемент
	Если НЕ ПустаяСтрока(Буфер) Тогда
		Результат.Добавить(Буфер);
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Создание структуры для отслеживания уровней вложенности
//
// Возвращаемое значение:
//   Структура - структура с счетчиками
//
Функция СоздатьСчетчикиВложенности()
	Возврат Новый Структура("УровеньКвадратныхСкобок, УровеньФигурныхСкобок, УровеньДвойныхКавычек, УровеньОдинарныхКавычек", 0, 0, 0, 0);
КонецФункции

// Обработка одного символа при разделении элементов
//
// Параметры:
//   Символ - Строка - текущий символ
//   Буфер - Строка - буфер для накопления символов
//   Счетчики - Структура - счетчики вложенности
//   Разделитель - Строка - разделитель элементов
//   Результат - Массив - массив результатов
//
Процедура ОбработатьСимвол(Символ, Буфер, Счетчики, Разделитель, Результат)
	Если ЭтоОткрывающаяСкобка(Символ) Тогда
		ОбработатьОткрывающуюСкобку(Символ, Счетчики);
		Буфер = Буфер + Символ;
	ИначеЕсли ЭтоЗакрывающаяСкобка(Символ) Тогда
		ОбработатьЗакрывающуюСкобку(Символ, Счетчики);
		Буфер = Буфер + Символ;
	ИначеЕсли ЭтоКавычка(Символ) Тогда
		ОбработатьКавычку(Символ, Счетчики);
		Буфер = Буфер + Символ;
	ИначеЕсли ЭтоРазделительНаВерхнемУровне(Символ, Разделитель, Счетчики) Тогда
		Результат.Добавить(Буфер);
		Буфер = "";
	Иначе
		Буфер = Буфер + Символ;
	КонецЕсли;
КонецПроцедуры

// Проверка, является ли символ открывающей скобкой
//
// Параметры:
//   Символ - Строка - символ для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если символ - открывающая скобка
//
Функция ЭтоОткрывающаяСкобка(Символ)
	Возврат Символ = "[" ИЛИ Символ = "{";
КонецФункции

// Проверка, является ли символ закрывающей скобкой
//
// Параметры:
//   Символ - Строка - символ для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если символ - закрывающая скобка
//
Функция ЭтоЗакрывающаяСкобка(Символ)
	Возврат Символ = "]" ИЛИ Символ = "}";
КонецФункции

// Проверка, является ли символ кавычкой
//
// Параметры:
//   Символ - Строка - символ для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если символ - кавычка
//
Функция ЭтоКавычка(Символ)
	Возврат Символ = """" ИЛИ Символ = "'";
КонецФункции

// Обработка открывающей скобки
//
// Параметры:
//   Символ - Строка - символ скобки
//   Счетчики - Структура - счетчики вложенности
//
Процедура ОбработатьОткрывающуюСкобку(Символ, Счетчики)
	Если Символ = "[" Тогда
		Счетчики.УровеньКвадратныхСкобок = Счетчики.УровеньКвадратныхСкобок + 1;
	ИначеЕсли Символ = "{" Тогда
		Счетчики.УровеньФигурныхСкобок = Счетчики.УровеньФигурныхСкобок + 1;
	Иначе
		Возврат; // Неизвестный символ скобки, игнорируем
	КонецЕсли;
КонецПроцедуры

// Обработка закрывающей скобки
//
// Параметры:
//   Символ - Строка - символ скобки
//   Счетчики - Структура - счетчики вложенности
//
Процедура ОбработатьЗакрывающуюСкобку(Символ, Счетчики)
	Если Символ = "]" Тогда
		Счетчики.УровеньКвадратныхСкобок = Счетчики.УровеньКвадратныхСкобок - 1;
		Если Счетчики.УровеньКвадратныхСкобок < 0 Тогда
			ВызватьИсключение "Ошибка парсинга: непарная закрывающая квадратная скобка";
		КонецЕсли;
	ИначеЕсли Символ = "}" Тогда
		Счетчики.УровеньФигурныхСкобок = Счетчики.УровеньФигурныхСкобок - 1;
		Если Счетчики.УровеньФигурныхСкобок < 0 Тогда
			ВызватьИсключение "Ошибка парсинга: непарная закрывающая фигурная скобка";
		КонецЕсли;
	Иначе
		// Символ не является закрывающей скобкой
		;
	КонецЕсли;
КонецПроцедуры

// Обработка кавычки
//
// Параметры:
//   Символ - Строка - символ кавычки
//   Счетчики - Структура - счетчики вложенности
//
Процедура ОбработатьКавычку(Символ, Счетчики)
	Если Символ = """" И Счетчики.УровеньОдинарныхКавычек = 0 Тогда
		// Учитываем кавычки, только если не находимся внутри одинарных кавычек
		Счетчики.УровеньДвойныхКавычек = 1 - Счетчики.УровеньДвойныхКавычек; // Переключаем 0/1
	ИначеЕсли Символ = "'" И Счетчики.УровеньДвойныхКавычек = 0 Тогда
		// Учитываем одинарные кавычки, только если не находимся внутри двойных кавычек
		Счетчики.УровеньОдинарныхКавычек = 1 - Счетчики.УровеньОдинарныхКавычек; // Переключаем 0/1
	Иначе
		// Кавычка не обрабатывается в данном контексте
		;
	КонецЕсли;
КонецПроцедуры

// Проверка, является ли символ разделителем на верхнем уровне
//
// Параметры:
//   Символ - Строка - символ для проверки
//   Разделитель - Строка - ожидаемый разделитель
//   Счетчики - Структура - счетчики вложенности
//
// Возвращаемое значение:
//   Булево - Истина, если это разделитель на верхнем уровне
//
Функция ЭтоРазделительНаВерхнемУровне(Символ, Разделитель, Счетчики)
	Возврат Символ = Разделитель 
		И Счетчики.УровеньКвадратныхСкобок = 0 
		И Счетчики.УровеньФигурныхСкобок = 0 
		И Счетчики.УровеньДвойныхКавычек = 0 
		И Счетчики.УровеньОдинарныхКавычек = 0;
КонецФункции

// Проверка закрытых скобок и кавычек
//
// Параметры:
//   Счетчики - Структура - счетчики вложенности
//
Процедура ПроверитьЗакрытыеСкобки(Счетчики)
	Если Счетчики.УровеньКвадратныхСкобок > 0 Тогда
		ВызватьИсключение "Ошибка парсинга: незакрытая квадратная скобка";
	КонецЕсли;
	
	Если Счетчики.УровеньФигурныхСкобок > 0 Тогда
		ВызватьИсключение "Ошибка парсинга: незакрытая фигурная скобка";
	КонецЕсли;
	
	Если Счетчики.УровеньДвойныхКавычек > 0 Тогда
		ВызватьИсключение "Ошибка парсинга: незакрытая двойная кавычка";
	КонецЕсли;
	
	Если Счетчики.УровеньОдинарныхКавычек > 0 Тогда
		ВызватьИсключение "Ошибка парсинга: незакрытая одинарная кавычка";
	КонецЕсли;
КонецПроцедуры

// Проверка, является ли строка началом многострочной flow структуры
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если это начало многострочной flow структуры
//
Функция ЭтоНачалоМногострочнойFlowСтруктуры(ЗначениеСтрока) Экспорт
	ЗначениеБезПробелов = СокрЛП(ЗначениеСтрока);
	
	// Проверяем, начинается ли с открывающей скобки, но не заканчивается соответствующей закрывающей
	Если Лев(ЗначениеБезПробелов, 1) = "[" И НЕ СтрЗаканчиваетсяНа(ЗначениеБезПробелов, "]") Тогда
		Возврат Истина;
	ИначеЕсли Лев(ЗначениеБезПробелов, 1) = "{" И НЕ СтрЗаканчиваетсяНа(ЗначениеБезПробелов, "}") Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

// Сбор многострочной flow структуры
//
// Параметры:
//   Строки - Массив - массив всех строк
//   Индекс - Число - индекс начальной строки
//   ТекущийУровеньОтступа - Число - уровень отступа родительского элемента
//
// Возвращаемое значение:
//   Структура - структура с полями "Строка" (собранная flow структура) и "КоличествоОбработанныхСтрок"
//
Функция СобратьМногострочнуюFlowСтруктуру(Строки, Индекс, ТекущийУровеньОтступа) Экспорт
	СобраннаяСтрока = СокрЛП(Строки[Индекс]);
	ИндексСтроки = Индекс + 1;
	КоличествоОбработанныхСтрок = 1; // Включая начальную строку
	
	// Определяем тип открывающей скобки
	ОткрывающаяСкобка = Лев(СобраннаяСтрока, 1);
	
	Счетчики = СоздатьСчетчикиВложенности();
	// Инициализируем счетчик для уже найденной открывающей скобки
	Если ОткрывающаяСкобка = "[" Тогда
		Счетчики.УровеньКвадратныхСкобок = 1;
	Иначе
		Счетчики.УровеньФигурныхСкобок = 1;
	КонецЕсли;
	
	// Проверяем остальную часть первой строки на наличие скобок
	ОбработатьСтрокуДляСчетчиков(СобраннаяСтрока, Счетчики, 2); // Начинаем с позиции 2, так как первый символ уже обработан
	
	// Если структура уже закрыта на первой строке, возвращаем её
	Если СтруктураЗакрыта(Счетчики) Тогда
		Возврат Новый Структура("Строка, КоличествоОбработанныхСтрок", СобраннаяСтрока, КоличествоОбработанныхСтрок);
	КонецЕсли;
	
	// Собираем остальные строки
	Пока ИндексСтроки <= Строки.ВГраница() Цикл
		Строка = Строки[ИндексСтроки];
		СодержимоеСтроки = СокрЛП(Строка);
		
		// Пропускаем пустые строки и комментарии
		Если ПустаяСтрока(СодержимоеСтроки) ИЛИ СтрНачинаетсяС(СодержимоеСтроки, "#") Тогда
			ИндексСтроки = ИндексСтроки + 1;
			Продолжить;
		КонецЕсли;
		
		// Проверяем уровень отступа текущей строки
		ТекущийОтступ = СтрДлина(Строка) - СтрДлина(СокрЛП(Строка));
		
		// Если уровень отступа меньше или равен исходному и это новый ключ, прекращаем сбор
		Если ТекущийОтступ <= ТекущийУровеньОтступа И СтрНайти(СодержимоеСтроки, ":") > 0 Тогда
			Прервать;
		КонецЕсли;
		
		// Если строка начинается с "-" и находится на том же уровне отступа, прекращаем сбор  
		Если ТекущийОтступ <= ТекущийУровеньОтступа И СтрНачинаетсяС(СодержимоеСтроки, "-") Тогда
			Прервать;
		КонецЕсли;
		
		// Добавляем содержимое строки
		СобраннаяСтрока = СобраннаяСтрока + " " + СодержимоеСтроки;
		ОбработатьСтрокуДляСчетчиков(СодержимоеСтроки, Счетчики, 1);
		КоличествоОбработанныхСтрок = ИндексСтроки - Индекс + 1;
		
		// Если структура закрыта, завершаем сбор
		Если СтруктураЗакрыта(Счетчики) Тогда
			Прервать;
		КонецЕсли;
		
		ИндексСтроки = ИндексСтроки + 1;
	КонецЦикла;
	
	// Структура может остаться незакрытой, если была прервана границами YAML блока
	// В этом случае возвращаем собранное содержимое как есть
	Возврат Новый Структура("Строка, КоличествоОбработанныхСтрок", СобраннаяСтрока, КоличествоОбработанныхСтрок);
КонецФункции

// Обработка строки для подсчета скобок и кавычек
//
// Параметры:
//   Строка - Строка - строка для обработки
//   Счетчики - Структура - счетчики вложенности
//   НачальнаяПозиция - Число - позиция, с которой начинать обработку
//
Процедура ОбработатьСтрокуДляСчетчиков(Строка, Счетчики, НачальнаяПозиция)
	Для Позиция = НачальнаяПозиция По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Позиция, 1);
		
		Если ЭтоОткрывающаяСкобка(Символ) Тогда
			ОбработатьОткрывающуюСкобку(Символ, Счетчики);
		ИначеЕсли ЭтоЗакрывающаяСкобка(Символ) Тогда
			ОбработатьЗакрывающуюСкобку(Символ, Счетчики);
		ИначеЕсли ЭтоКавычка(Символ) Тогда
			ОбработатьКавычку(Символ, Счетчики);
		Иначе
			Продолжить; // Пропускаем остальные символы
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Проверка, закрыта ли flow структура (упрощенная версия для отладки)
//
// Параметры:
//   Счетчики - Структура - счетчики вложенности
//
// Возвращаемое значение:
//   Булево - Истина, если все скобки закрыты
//
Функция СтруктураЗакрыта(Счетчики)
	Возврат Счетчики.УровеньКвадратныхСкобок = 0 
		И Счетчики.УровеньФигурныхСкобок = 0;
КонецФункции
