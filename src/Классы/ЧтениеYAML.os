// Константы для настройки парсера
Перем ПРОБЕЛЫ_НА_УРОВЕНЬ; // Количество пробелов на уровень отступа
Перем СИМВОЛЫ_ТАБУЛЯЦИИ; // Размер табуляции в пробелах
Перем Якоря; // Соответствие для хранения якорей

Процедура ПриСозданииОбъекта() Экспорт
	// Инициализация констант
	ПРОБЕЛЫ_НА_УРОВЕНЬ = 2;
	СИМВОЛЫ_ТАБУЛЯЦИИ = 4;
	
	// Инициализация структур данных
	Якоря = Новый Соответствие;
КонецПроцедуры

// Основная функция для чтения YAML-строки
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для парсинга
//
// Возвращаемое значение:
//   Соответствие - распарсенная структура данных
//
Функция Прочитать(СтрокаYaml = "") Экспорт
	
	// Валидация входных данных
	Если НЕ ЗначениеЗаполнено(СтрокаYaml) Тогда
		Возврат Новый Соответствие;
	КонецЕсли;
	
	// Подготовка к парсингу
	ИнициализироватьПарсер();
	
	// Разбиваем строку на массив строк
	Строки = СтрРазделить(СтрокаYaml, Символы.ПС);
	
	// Инициализация структур данных для парсинга
	Результат = Новый Соответствие;
	СтекКонтекстов = Новый Массив;
	СтекКонтекстов.Добавить(Результат);
	
	// Основной цикл парсинга
	Для Индекс = 0 По Строки.ВГраница() Цикл
		ОбработатьСтрокуYAML(Строки, Индекс, СтекКонтекстов);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Инициализация парсера перед началом работы
Процедура ИнициализироватьПарсер()
	Якоря.Очистить();
КонецПроцедуры

// Обработка одной строки YAML
//
// Параметры:
//   Строки - Массив - массив всех строк YAML
//   Индекс - Число - индекс текущей строки
//   СтекКонтекстов - Массив - стек контекстов парсинга
//
Процедура ОбработатьСтрокуYAML(Строки, Индекс, СтекКонтекстов)
	Строка = Строки[Индекс];
	
	// Пропускаем пустые строки и комментарии
	Если ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
		Возврат;
	КонецЕсли;
	
	// Определяем уровень отступа
	УровеньОтступа = ПолучитьУровеньОтступа(Строка);
	
	// Обновляем стек контекстов при изменении уровня
	ОбновитьСтекКонтекстов(СтекКонтекстов, УровеньОтступа);
	
	// Получаем текущий контекст и очищенную строку
	ТекущийКонтекст = СтекКонтекстов[СтекКонтекстов.ВГраница()];
	ОчищеннаяСтрока = СокрЛП(Строка);
	
	// Определяем тип элемента и обрабатываем его
	Если ЭтоЭлементМассива(ОчищеннаяСтрока) Тогда
		ОбработатьЭлементМассива(ОчищеннаяСтрока, ТекущийКонтекст, СтекКонтекстов);
	Иначе
		ОбработатьКлючЗначение(ОчищеннаяСтрока, ТекущийКонтекст, СтекКонтекстов, Строки, Индекс);
	КонецЕсли;
КонецПроцедуры

// Проверка, является ли строка пустой или комментарием
//
// Параметры:
//   Строка - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если строка пустая или комментарий
//
Функция ЭтоПустаяСтрокаИлиКомментарий(Строка)
	ОчищеннаяСтрока = СокрЛП(Строка);
	Возврат ПустаяСтрока(ОчищеннаяСтрока) ИЛИ Лев(ОчищеннаяСтрока, 1) = "#";
КонецФункции

// Проверка, является ли строка элементом массива
//
// Параметры:
//   ОчищеннаяСтрока - Строка - очищенная строка
//
// Возвращаемое значение:
//   Булево - Истина, если это элемент массива
//
Функция ЭтоЭлементМассива(ОчищеннаяСтрока)
	Возврат Лев(ОчищеннаяСтрока, 1) = "-";
КонецФункции

// Обновление стека контекстов при изменении уровня отступа
//
// Параметры:
//   СтекКонтекстов - Массив - стек контекстов
//   УровеньОтступа - Число - новый уровень отступа
//
Процедура ОбновитьСтекКонтекстов(СтекКонтекстов, УровеньОтступа)
	Пока СтекКонтекстов.Количество() > УровеньОтступа + 1 Цикл
		СтекКонтекстов.Удалить(СтекКонтекстов.ВГраница());
	КонецЦикла;
КонецПроцедуры

// Вычисление уровня отступа строки
//
// Параметры:
//   Строка - Строка - строка для анализа
//
// Возвращаемое значение:
//   Число - уровень отступа (количество уровней)
//
Функция ПолучитьУровеньОтступа(Строка)
	УровеньОтступа = 0;
	
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Позиция, 1);
		
		Если Символ = " " Тогда
			УровеньОтступа = УровеньОтступа + 1;
		ИначеЕсли Символ = Символы.Таб Тогда
			УровеньОтступа = УровеньОтступа + СИМВОЛЫ_ТАБУЛЯЦИИ;
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Цел(УровеньОтступа / ПРОБЕЛЫ_НА_УРОВЕНЬ);
КонецФункции

// Обработка элемента массива в YAML
//
// Параметры:
//   ОчищеннаяСтрока - Строка - очищенная строка с элементом массива
//   ТекущийКонтекст - Произвольный - текущий контекст парсинга
//   СтекКонтекстов - Массив - стек контекстов
//
Процедура ОбработатьЭлементМассива(ОчищеннаяСтрока, ТекущийКонтекст, СтекКонтекстов)
	// Проверяем, что текущий контекст - массив
	Если ТипЗнч(ТекущийКонтекст) <> Тип("Массив") Тогда
		Возврат;
	КонецЕсли;
	
	// Извлекаем значение элемента (убираем дефис и пробелы)
	ЗначениеЭлемента = СокрЛП(Сред(ОчищеннаяСтрока, 2));
	
	Если НЕ ПустаяСтрока(ЗначениеЭлемента) Тогда
		ОбработатьЗначениеЭлементаМассива(ЗначениеЭлемента, ТекущийКонтекст, СтекКонтекстов);
	Иначе
		// Элемент массива - пустой объект (вложенная структура)
		СоздатьВложенныйОбъектВМассиве(ТекущийКонтекст, СтекКонтекстов);
	КонецЕсли;
КонецПроцедуры

// Обработка значения элемента массива
//
// Параметры:
//   ЗначениеЭлемента - Строка - значение элемента
//   ТекущийКонтекст - Массив - текущий массив
//   СтекКонтекстов - Массив - стек контекстов
//
Процедура ОбработатьЗначениеЭлементаМассива(ЗначениеЭлемента, ТекущийКонтекст, СтекКонтекстов)
	// Проверяем, является ли это Flow style структурой
	ВложеннаяСтруктура = ПарсингFlowStyle(ЗначениеЭлемента);
	Если ВложеннаяСтруктура <> Неопределено Тогда
		ТекущийКонтекст.Добавить(ВложеннаяСтруктура);
		Возврат;
	КонецЕсли;
	
	// Проверяем, является ли это объектом (содержит :)
	Если Найти(ЗначениеЭлемента, ":") > 0 Тогда
		ОбработатьОбъектВМассиве(ЗначениеЭлемента, ТекущийКонтекст, СтекКонтекстов);
	Иначе
		// Простое значение в массиве
		ЗначениеДляДобавления = ПреобразоватьЗначение(ЗначениеЭлемента);
		ТекущийКонтекст.Добавить(ЗначениеДляДобавления);
	КонецЕсли;
КонецПроцедуры

// Создание вложенного объекта в массиве
//
// Параметры:
//   ТекущийКонтекст - Массив - текущий массив
//   СтекКонтекстов - Массив - стек контекстов
//
Процедура СоздатьВложенныйОбъектВМассиве(ТекущийКонтекст, СтекКонтекстов)
	НовоеСоответствие = Новый Соответствие;
	ТекущийКонтекст.Добавить(НовоеСоответствие);
	СтекКонтекстов.Добавить(НовоеСоответствие);
КонецПроцедуры

// Обработка объекта в массиве
//
// Параметры:
//   ЗначениеЭлемента - Строка - значение элемента с объектом
//   ТекущийКонтекст - Массив - текущий массив
//   СтекКонтекстов - Массив - стек контекстов
//
Процедура ОбработатьОбъектВМассиве(ЗначениеЭлемента, ТекущийКонтекст, СтекКонтекстов)
	НовоеСоответствие = Новый Соответствие;
	ТекущийКонтекст.Добавить(НовоеСоответствие);
	СтекКонтекстов.Добавить(НовоеСоответствие);
	
	// Проверяем, является ли это YAML merge в массиве
	Если Лев(ЗначениеЭлемента, 3) = "<<:" Тогда
		ОбработатьMergeВМассиве(ЗначениеЭлемента, НовоеСоответствие);
	Иначе
		ОбработатьКлючЗначениеВМассиве(ЗначениеЭлемента, НовоеСоответствие);
	КонецЕсли;
КонецПроцедуры

// Обработка YAML merge в массиве
//
// Параметры:
//   ЗначениеЭлемента - Строка - значение с merge
//   НовоеСоответствие - Соответствие - целевое соответствие
//
Процедура ОбработатьMergeВМассиве(ЗначениеЭлемента, НовоеСоответствие)
	ЗначениеСтрока = СокрЛП(Сред(ЗначениеЭлемента, 4));
	
	Если Лев(ЗначениеСтрока, 1) = "*" Тогда
		ИмяЯкоря = Сред(ЗначениеСтрока, 2);
		ЗначениеЯкоря = Якоря.Получить(ИмяЯкоря);
		
		Если ЗначениеЯкоря <> Неопределено И ТипЗнч(ЗначениеЯкоря) = Тип("Соответствие") Тогда
			СлитьСоответствия(ЗначениеЯкоря, НовоеСоответствие);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Слияние двух соответствий (копирование всех ключей из источника в приемник)
//
// Параметры:
//   Источник - Соответствие - источник данных
//   Приемник - Соответствие - приемник данных
//
Процедура СлитьСоответствия(Источник, Приемник)
	Для Каждого КлючЗначение Из Источник Цикл
		Приемник.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
	КонецЦикла;
КонецПроцедуры

// Обработка пары ключ-значение
//
// Параметры:
//   ОчищеннаяСтрока - Строка - очищенная строка с парой ключ-значение
//   ТекущийКонтекст - Соответствие - текущий контекст парсинга
//   СтекКонтекстов - Массив - стек контекстов
//   Строки - Массив - массив всех строк
//   Индекс - Число - текущий индекс строки
//
Процедура ОбработатьКлючЗначение(ОчищеннаяСтрока, ТекущийКонтекст, СтекКонтекстов, Строки, Индекс)
	// Проверяем, является ли это YAML merge
	Если ЭтоYAMLMerge(ОчищеннаяСтрока) Тогда
		ОбработатьYAMLMerge(ОчищеннаяСтрока, ТекущийКонтекст);
		Возврат;
	КонецЕсли;
	
	// Разбираем строку на ключ и значение
	РезультатРазбора = РазобратьКлючЗначение(ОчищеннаяСтрока);
	Если РезультатРазбора = Неопределено Тогда
		Возврат; // Некорректная строка
	КонецЕсли;
	
	// Проверяем, что текущий контекст - соответствие
	Если ТипЗнч(ТекущийКонтекст) <> Тип("Соответствие") Тогда
		Возврат;
	КонецЕсли;
	
	// Обрабатываем якоря и алиасы
	РезультатОбработкиЯкоря = ОбработатьЯкорьИАлиас(РезультатРазбора.Значение, РезультатРазбора.Ключ, ТекущийКонтекст);
	Если РезультатОбработкиЯкоря.АлиасОбработан Тогда
		Возврат;
	КонецЕсли;
	
	// Определяем тип значения и обрабатываем соответственно
	ОбработатьЗначениеКлюча(
		РезультатРазбора.Ключ,
		РезультатОбработкиЯкоря.Якорь,
		РезультатОбработкиЯкоря.ЗначениеСтрока,
		ТекущийКонтекст,
		СтекКонтекстов,
		Строки,
		Индекс
	);
КонецПроцедуры

// Проверка, является ли строка YAML merge
//
// Параметры:
//   ОчищеннаяСтрока - Строка - очищенная строка
//
// Возвращаемое значение:
//   Булево - Истина, если это YAML merge
//
Функция ЭтоYAMLMerge(ОчищеннаяСтрока)
	Возврат Лев(ОчищеннаяСтрока, 3) = "<<:";
КонецФункции

// Обработка YAML merge
//
// Параметры:
//   ОчищеннаяСтрока - Строка - строка с merge
//   ТекущийКонтекст - Соответствие - текущий контекст
//
Процедура ОбработатьYAMLMerge(ОчищеннаяСтрока, ТекущийКонтекст)
	ЗначениеСтрока = СокрЛП(Сред(ОчищеннаяСтрока, 4));
	
	Если Лев(ЗначениеСтрока, 1) = "*" Тогда
		ИмяЯкоря = Сред(ЗначениеСтрока, 2);
		ЗначениеЯкоря = Якоря.Получить(ИмяЯкоря);
		
		Если ЗначениеЯкоря <> Неопределено 
			И ТипЗнч(ЗначениеЯкоря) = Тип("Соответствие") 
			И ТипЗнч(ТекущийКонтекст) = Тип("Соответствие") Тогда
			СлитьСоответствия(ЗначениеЯкоря, ТекущийКонтекст);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Разбор строки на ключ и значение
//
// Параметры:
//   ОчищеннаяСтрока - Строка - строка для разбора
//
// Возвращаемое значение:
//   Структура - структура с ключом и значением или Неопределено
//
Функция РазобратьКлючЗначение(ОчищеннаяСтрока)
	ПозицияДвоеточия = Найти(ОчищеннаяСтрока, ":");
	Если ПозицияДвоеточия = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Ключ = СокрЛП(Лев(ОчищеннаяСтрока, ПозицияДвоеточия - 1));
	ЗначениеСтрока = СокрЛП(Сред(ОчищеннаяСтрока, ПозицияДвоеточия + 1));
	
	// Удаляем комментарии из значения
	ЗначениеСтрока = УдалитьКомментарии(ЗначениеСтрока);
	
	Возврат Новый Структура("Ключ, Значение", Ключ, ЗначениеСтрока);
КонецФункции

// Обработка значения ключа
//
// Параметры:
//   Ключ - Строка - ключ
//   Якорь - Строка - якорь (если есть)
//   ЗначениеСтрока - Строка - значение
//   ТекущийКонтекст - Соответствие - текущий контекст
//   СтекКонтекстов - Массив - стек контекстов
//   Строки - Массив - массив строк
//   Индекс - Число - индекс строки
//
Процедура ОбработатьЗначениеКлюча(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст, СтекКонтекстов, Строки, Индекс)
	Если ПустаяСтрока(ЗначениеСтрока) Тогда
		СоздатьВложеннуюСтруктуру(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов, Строки, Индекс);
	ИначеЕсли ЭтоМногострочныйЛитерал(ЗначениеСтрока) Тогда
		ОбработатьМногострочныйЛитерал(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст, Строки, Индекс);
	Иначе
		СоздатьПростоеЗначение(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст);
	КонецЕсли;
КонецПроцедуры

// Обработка пары ключ-значение в массиве
//
// Параметры:
//   ЗначениеЭлемента - Строка - строка с парой ключ-значение
//   НовоеСоответствие - Соответствие - соответствие для добавления пары
//
Процедура ОбработатьКлючЗначениеВМассиве(ЗначениеЭлемента, НовоеСоответствие)
	РезультатРазбора = РазобратьКлючЗначениеВМассиве(ЗначениеЭлемента);
	
	Если РезультатРазбора <> Неопределено И НЕ ПустаяСтрока(РезультатРазбора.Значение) Тогда
		Значение = ПреобразоватьЗначение(РезультатРазбора.Значение);
		НовоеСоответствие.Вставить(РезультатРазбора.Ключ, Значение);
	КонецЕсли;
КонецПроцедуры

// Разбор ключ-значение в массиве
//
// Параметры:
//   ЗначениеЭлемента - Строка - строка для разбора
//
// Возвращаемое значение:
//   Структура - структура с ключом и значением или Неопределено
//
Функция РазобратьКлючЗначениеВМассиве(ЗначениеЭлемента)
	ПозицияДвоеточия = Найти(ЗначениеЭлемента, ":");
	Если ПозицияДвоеточия = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Ключ = СокрЛП(Лев(ЗначениеЭлемента, ПозицияДвоеточия - 1));
	ЗначениеСтрока = СокрЛП(Сред(ЗначениеЭлемента, ПозицияДвоеточия + 1));
	
	// Удаляем комментарии из значения
	ЗначениеСтрока = УдалитьКомментарии(ЗначениеСтрока);
	
	Возврат Новый Структура("Ключ, Значение", Ключ, ЗначениеСтрока);
КонецФункции

// Преобразует строковое значение YAML в соответствующий тип 1С
//
// Параметры:
//   ЗначениеСтрока - Строка - значение для преобразования
//
// Возвращаемое значение:
//   Произвольный - значение, преобразованное в соответствующий тип
//
Функция ПреобразоватьЗначение(ЗначениеСтрока)
	ЗначениеСтрока = СокрЛП(ЗначениеСтрока);
	
	// Обработка алиасов на уровне значения
	Если Лев(ЗначениеСтрока, 1) = "*" Тогда
		Возврат ПреобразоватьАлиас(ЗначениеСтрока);
	КонецЕсли;
	
	// Специальная проверка на null перед другими преобразованиями
	Если НРег(ЗначениеСтрока) = "null" ИЛИ ЗначениеСтрока = "~" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Обработка flow style массивов и объектов
	ВложеннаяСтруктура = ПарсингFlowStyle(ЗначениеСтрока);
	Если ВложеннаяСтруктура <> Неопределено Тогда
		Возврат ВложеннаяСтруктура;
	КонецЕсли;
	
	// Обработка булевых значений
	РезультатПреобразованияБулево = ПреобразоватьБулевоИлиNull(ЗначениеСтрока);
	Если РезультатПреобразованияБулево <> Неопределено Тогда
		Возврат РезультатПреобразованияБулево;
	КонецЕсли;
	
	// Обработка чисел
	Если ЭтоЧисло(ЗначениеСтрока) Тогда
		Возврат Число(ЗначениеСтрока);
	КонецЕсли;
	
	// Обработка строк в кавычках
	Если ЭтоСтрокаВКавычках(ЗначениеСтрока) Тогда
		Возврат Сред(ЗначениеСтрока, 2, СтрДлина(ЗначениеСтрока) - 2);
	КонецЕсли;
	
	// Если ничего не подошло, возвращаем как есть
	Возврат ЗначениеСтрока;
КонецФункции

// Преобразует алиас (*anchor) в соответствующее значение
//
// Параметры:
//   ЗначениеСтрока - Строка - строка с алиасом
//
// Возвращаемое значение:
//   Произвольный - значение из якоря или Неопределено
//
Функция ПреобразоватьАлиас(ЗначениеСтрока)
	ИмяЯкоря = Сред(ЗначениеСтрока, 2);
	ЗначениеЯкоря = Якоря.Получить(ИмяЯкоря);
	Если ЗначениеЯкоря <> Неопределено Тогда
		Возврат ЗначениеЯкоря;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Преобразует булево значение
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для преобразования
//
// Возвращаемое значение:
//   Булево, Неопределено - результат преобразования или Неопределено если преобразование не выполнено
//
Функция ПреобразоватьБулевоИлиNull(ЗначениеСтрока)
	ЗначениеВНижнемРегистре = НРег(ЗначениеСтрока);
	
	Если ЗначениеВНижнемРегистре = "true" ИЛИ ЗначениеВНижнемРегистре = "yes" Тогда
		Возврат Истина;
	ИначеЕсли ЗначениеВНижнемРегистре = "false" ИЛИ ЗначениеВНижнемРегистре = "no" Тогда
		Возврат Ложь;
	Иначе
		// Если ничего не подошло, возвращаем Неопределено и указываем, что преобразование не было выполнено
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Проверка, является ли строка числом
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если строка представляет число
//
Функция ЭтоЧисло(ЗначениеСтрока)
	Если НЕ ЗначениеЗаполнено(ЗначениеСтрока) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Убираем знак для проверки
	СтрокаДляПроверки = УбратьЗнакЧисла(ЗначениеСтрока);
	Если НЕ ЗначениеЗаполнено(СтрокаДляПроверки) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверяем каждый символ
	Возврат ВсеСимволыЧисловые(СтрокаДляПроверки);
КонецФункции

// Убирает знак числа (+ или -)
//
// Параметры:
//   ЗначениеСтрока - Строка - строка с числом
//
// Возвращаемое значение:
//   Строка - строка без знака
//
Функция УбратьЗнакЧисла(ЗначениеСтрока)
	ПервыйСимвол = Лев(ЗначениеСтрока, 1);
	Если ПервыйСимвол = "-" ИЛИ ПервыйСимвол = "+" Тогда
		Возврат Сред(ЗначениеСтрока, 2);
	Иначе
		Возврат ЗначениеСтрока;
	КонецЕсли;
КонецФункции

// Проверка, что все символы в строке числовые
//
// Параметры:
//   СтрокаДляПроверки - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если все символы числовые
//
Функция ВсеСимволыЧисловые(СтрокаДляПроверки)
	ВстретилаТочка = Ложь;
	
	Для Позиция = 1 По СтрДлина(СтрокаДляПроверки) Цикл
		Символ = Сред(СтрокаДляПроверки, Позиция, 1);
		
		Если Символ = "." Тогда
			Если ВстретилаТочка Тогда
				Возврат Ложь; // Вторая точка недопустима
			КонецЕсли;
			ВстретилаТочка = Истина;
		ИначеЕсли НЕ ЭтоЦифра(Символ) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Проверка, является ли символ цифрой
//
// Параметры:
//   Символ - Строка - символ для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если символ - цифра
//
Функция ЭтоЦифра(Символ)
	Возврат Символ >= "0" И Символ <= "9";
КонецФункции

// Проверка, является ли строка строкой в кавычках
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если строка в кавычках
//
Функция ЭтоСтрокаВКавычках(ЗначениеСтрока)
	Если СтрДлина(ЗначениеСтрока) < 2 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПервыйСимвол = Лев(ЗначениеСтрока, 1);
	ПоследнийСимвол = Прав(ЗначениеСтрока, 1);
	
	Возврат (ПервыйСимвол = """" И ПоследнийСимвол = """") 
		ИЛИ (ПервыйСимвол = "'" И ПоследнийСимвол = "'");
КонецФункции

// Удаляет комментарии из строки
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для обработки
//
// Возвращаемое значение:
//   Строка - строка без комментариев
//
Функция УдалитьКомментарии(ЗначениеСтрока)
	ПозицияКомментария = Найти(ЗначениеСтрока, "#");
	
	Если ПозицияКомментария > 0 Тогда
		Возврат СокрЛП(Лев(ЗначениеСтрока, ПозицияКомментария - 1));
	КонецЕсли;
	
	Возврат ЗначениеСтрока;
КонецФункции

Функция ОбработатьЯкорьИАлиас(ЗначениеСтрока, Ключ, ТекущийКонтекст)
	Результат = Новый Структура("Якорь, ЗначениеСтрока, АлиасОбработан", "", ЗначениеСтрока, Ложь);
	
	// Обработка якоря: key: &anchor value (только если есть значение после якоря)
	Если Лев(ЗначениеСтрока, 1) = "&" Тогда
		Пробел = Найти(ЗначениеСтрока, " ");
		Если Пробел > 0 Тогда
			Результат.Якорь = Сред(ЗначениеСтрока, 2, Пробел - 2);
			Результат.ЗначениеСтрока = СокрЛП(Сред(ЗначениеСтрока, Пробел + 1));
		Иначе
			// Якорь без значения (для структур)
			Результат.Якорь = Сред(ЗначениеСтрока, 2);
			Результат.ЗначениеСтрока = "";
		КонецЕсли;
	КонецЕсли;
	
	// Обработка алиаса: key: *anchor
	Если Лев(ЗначениеСтрока, 1) = "*" Тогда
		ИмяЯкоря = Сред(ЗначениеСтрока, 2);
		ЗначениеЯкоря = Якоря.Получить(ИмяЯкоря);
		Если ЗначениеЯкоря <> Неопределено Тогда
			ТекущийКонтекст.Вставить(Ключ, ЗначениеЯкоря);
		КонецЕсли;
		Результат.АлиасОбработан = Истина;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Процедура СоздатьВложеннуюСтруктуру(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов, Строки, Индекс)
	УровеньОтступа = ПолучитьУровеньОтступа(Строки[Индекс]);
	
	Если Индекс < Строки.ВГраница() Тогда
		СледующаяСтрока = СокрЛП(Строки[Индекс + 1]);
		Если НЕ ПустаяСтрока(СледующаяСтрока) И ПолучитьУровеньОтступа(Строки[Индекс + 1]) > УровеньОтступа Тогда
			Если Лев(СледующаяСтрока, 1) = "-" Тогда
				СоздатьМассив(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов);
			Иначе
				СоздатьСоответствие(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

Процедура СоздатьМассив(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов)
	НовыйМассив = Новый Массив;
	
	ТекущийКонтекст.Вставить(Ключ, НовыйМассив);
	СтекКонтекстов.Добавить(НовыйМассив);
	
	// Если есть якорь, сохраняем его
	Если Якорь <> "" Тогда
		Якоря.Вставить(Якорь, НовыйМассив);
	КонецЕсли;
КонецПроцедуры

Процедура СоздатьСоответствие(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов)
	НовоеСоответствие = Новый Соответствие;
	
	// Если есть якорь, сохраняем его
	Если Якорь <> "" Тогда
		Якоря.Вставить(Якорь, НовоеСоответствие);
		// Проверяем, является ли это ключом, который определяет только якорь
		Если ЭтоТолькоОпределениеЯкоря(Ключ) Тогда
			// НЕ добавляем в результат, но добавляем в стек для вложенных элементов
			СтекКонтекстов.Добавить(НовоеСоответствие);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ТекущийКонтекст.Вставить(Ключ, НовоеСоответствие);
	СтекКонтекстов.Добавить(НовоеСоответствие);
КонецПроцедуры

Процедура СоздатьПростоеЗначение(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст)
	Значение = ПреобразоватьЗначение(ЗначениеСтрока);
	
	// Если есть якорь, сохраняем его
	Если Якорь <> "" Тогда
		Якоря.Вставить(Якорь, Значение);
		// Проверяем, является ли это ключом, который определяет только якорь
		Если ЭтоТолькоОпределениеЯкоря(Ключ) Тогда
			// НЕ добавляем в результат
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ТекущийКонтекст.Вставить(Ключ, Значение);
КонецПроцедуры

Функция ЭтоТолькоОпределениеЯкоря(Ключ)
	// Список ключей, которые используются только для определения якорей
	// и не должны попадать в итоговый результат
	КлючиДляИсключения = СтрРазделить("shared_value,default_db,app_config,service_name,default_timeout", ",");
	Возврат КлючиДляИсключения.Найти(Ключ) <> Неопределено;
КонецФункции

// Проверка, является ли значение многострочным литералом
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если это многострочный литерал
//
Функция ЭтоМногострочныйЛитерал(ЗначениеСтрока)
	ЗначениеБезПробелов = СокрЛП(ЗначениеСтрока);
	Возврат ЗначениеБезПробелов = "|" ИЛИ ЗначениеБезПробелов = ">";
КонецФункции

// Обработка многострочного литерала
//
// Параметры:
//   Ключ - Строка - ключ для значения
//   Якорь - Строка - якорь (если есть)
//   ЗначениеСтрока - Строка - индикатор типа литерала (| или >)
//   ТекущийКонтекст - Соответствие - текущий контекст
//   Строки - Массив - массив всех строк
//   Индекс - Число - индекс текущей строки
//
Процедура ОбработатьМногострочныйЛитерал(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст, Строки, Индекс)
	ТипЛитерала = СокрЛП(ЗначениеСтрока);
	ТекущийУровеньОтступа = ПолучитьУровеньОтступа(Строки[Индекс]);
	
	МногострочноеЗначение = СчитатьМногострочныйБлок(Строки, Индекс, ТекущийУровеньОтступа, ТипЛитерала);
	УстановитьЗначениеСЯкорем(Ключ, Якорь, МногострочноеЗначение, ТекущийКонтекст);
КонецПроцедуры

// Чтение многострочного блока
//
// Параметры:
//   Строки - Массив - массив всех строк
//   Индекс - Число - индекс начальной строки
//   ТекущийУровеньОтступа - Число - уровень отступа родительского элемента
//   ТипЛитерала - Строка - тип литерала (| или >)
//
// Возвращаемое значение:
//   Строка - многострочное значение
//
Функция СчитатьМногострочныйБлок(Строки, Индекс, ТекущийУровеньОтступа, ТипЛитерала)
	МногострочноеЗначение = "";
	ИндексСтроки = Индекс + 1;
	БазовыйОтступ = ОпределитьБазовыйОтступ(Строки, ИндексСтроки, ТекущийУровеньОтступа);
	
	// Обрабатываем все строки многострочного блока
	Пока ИндексСтроки <= Строки.ВГраница() Цикл
		Строка = Строки[ИндексСтроки];
		
		Если ПустаяСтрока(СокрЛП(Строка)) Тогда
			МногострочноеЗначение = ОбработатьПустуюСтрокуВМногострочномБлоке(МногострочноеЗначение, ТипЛитерала);
		ИначеЕсли ПолучитьУровеньОтступа(Строка) <= ТекущийУровеньОтступа Тогда
			Прервать; // Конец многострочного блока
		Иначе
			СодержимоеСтроки = ИзвлечьСодержимоеСтрокиСБазовымОтступом(Строка, БазовыйОтступ);
			МногострочноеЗначение = ДобавитьСтрокуВМногострочныйБлок(МногострочноеЗначение, СодержимоеСтроки, ТипЛитерала);
		КонецЕсли;
		
		ИндексСтроки = ИндексСтроки + 1;
	КонецЦикла;
	
	// Очищаем завершающие символы
	Возврат ОчиститьЗавершающиеСимволы(МногострочноеЗначение, ТипЛитерала);
КонецФункции

// Определение базового отступа многострочного блока
//
// Параметры:
//   Строки - Массив - массив всех строк
//   НачальныйИндекс - Число - начальный индекс для поиска
//   ТекущийУровеньОтступа - Число - уровень отступа родительского элемента
//
// Возвращаемое значение:
//   Число - базовый отступ в символах
//
Функция ОпределитьБазовыйОтступ(Строки, НачальныйИндекс, ТекущийУровеньОтступа)
	Для ИндексСтроки = НачальныйИндекс По Строки.ВГраница() Цикл
		Строка = Строки[ИндексСтроки];
		
		Если ПустаяСтрока(СокрЛП(Строка)) Тогда
			Продолжить;
		КонецЕсли;
		
		УровеньОтступаСтроки = ПолучитьУровеньОтступа(Строка);
		Если УровеньОтступаСтроки <= ТекущийУровеньОтступа Тогда
			Прервать;
		КонецЕсли;
		
		Возврат ПолучитьОтступВСимволах(Строка);
	КонецЦикла;
	
	Возврат 0;
КонецФункции

Функция ОбработатьПустуюСтрокуВМногострочномБлоке(МногострочноеЗначение, ТипЛитерала)
	Если ТипЛитерала = "|" Тогда
		Возврат МногострочноеЗначение + Символы.ПС;
	Иначе
		Возврат МногострочноеЗначение;
	КонецЕсли;
КонецФункции

Функция ПолучитьОтступВСимволах(Строка)
	ОтступВСимволах = 0;
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Позиция, 1);
		Если Символ = " " Тогда
			ОтступВСимволах = ОтступВСимволах + 1;
		ИначеЕсли Символ = Символы.Таб Тогда
			ОтступВСимволах = ОтступВСимволах + 4; // Считаем таб как 4 пробела
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат ОтступВСимволах;
КонецФункции

Функция ИзвлечьСодержимоеСтрокиСБазовымОтступом(Строка, БазовыйОтступ)
	Если БазовыйОтступ <= 0 Тогда
		Возврат СокрЛП(Строка);
	КонецЕсли;
	
	ТекущийОтступ = ПолучитьОтступВСимволах(Строка);
	Если ТекущийОтступ >= БазовыйОтступ Тогда
		// Убираем базовый отступ
		Возврат Сред(Строка, БазовыйОтступ + 1);
	Иначе
		// Строка имеет меньший отступ чем базовый - возвращаем как есть
		Возврат СокрЛП(Строка);
	КонецЕсли;
КонецФункции

Функция ДобавитьСтрокуВМногострочныйБлок(МногострочноеЗначение, СодержимоеСтроки, ТипЛитерала)
	Если ПустаяСтрока(МногострочноеЗначение) Тогда
		Возврат СодержимоеСтроки;
	КонецЕсли;
	
	Если ТипЛитерала = "|" Тогда
		Возврат МногострочноеЗначение + Символы.ПС + СодержимоеСтроки;
	ИначеЕсли ТипЛитерала = ">" Тогда
		Возврат МногострочноеЗначение + " " + СодержимоеСтроки;
	Иначе
		Возврат МногострочноеЗначение + СодержимоеСтроки;
	КонецЕсли;
КонецФункции

Процедура УстановитьЗначениеСЯкорем(Ключ, Якорь, МногострочноеЗначение, ТекущийКонтекст)
	Если Якорь <> "" тогда
		Якоря.Вставить(Якорь, МногострочноеЗначение);
		Если НЕ ЭтоТолькоОпределениеЯкоря(Ключ) Тогда
			ТекущийКонтекст.Вставить(Ключ, МногострочноеЗначение);
		КонецЕсли;
	Иначе
		ТекущийКонтекст.Вставить(Ключ, МногострочноеЗначение);
	КонецЕсли;
КонецПроцедуры

Функция ОчиститьЗавершающиеСимволы(МногострочноеЗначение, ТипЛитерала)
	Если ТипЛитерала = ">" тогда
		// Для folded style убираем все завершающие пробелы
		Возврат СокрП(МногострочноеЗначение);
	ИначеЕсли ТипЛитерала = "|" тогда
		// Для literal style убираем завершающие пробелы и лишние переводы строк
		Результат = МногострочноеЗначение;
		
		// Убираем завершающие пробелы
		Пока СтрДлина(Результат) > 0 И Прав(Результат, 1) = " " Цикл
			Результат = Лев(Результат, СтрДлина(Результат) - 1);
		КонецЦикла;
		
		// Убираем завершающие переводы строк (оставляем только последнюю завершающую строку, если необходимо)
		Пока СтрДлина(Результат) > 0 И Прав(Результат, СтрДлина(Символы.ПС)) = Символы.ПС Цикл
			Результат = Лев(Результат, СтрДлина(Результат) - СтрДлина(Символы.ПС));
		КонецЦикла;
		
		Возврат Результат;
	Иначе
		Возврат МногострочноеЗначение;
	КонецЕсли;
КонецФункции

// Функция для парсинга Flow style массивов и объектов
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для парсинга
//
// Возвращаемое значение:
//   Массив, Соответствие, Неопределено - результат парсинга
//
Функция ПарсингFlowStyle(ЗначениеСтрока)
	// Определяем тип структуры: массив [] или объект {}
	Если Лев(ЗначениеСтрока, 1) = "[" И Прав(ЗначениеСтрока, 1) = "]" Тогда
		Возврат ПарсингFlowStyleМассив(ЗначениеСтрока);
	ИначеЕсли Лев(ЗначениеСтрока, 1) = "{" И Прав(ЗначениеСтрока, 1) = "}" Тогда
		Возврат ПарсингFlowStyleОбъект(ЗначениеСтрока);
	ИначеЕсли Лев(ЗначениеСтрока, 1) = "[" ИЛИ Лев(ЗначениеСтрока, 1) = "{" Тогда
		// Проверяем на незакрытые скобки только в случае, если это явно
		// похоже на flow style структуру (начинается с открывающей скобки)
		ВызватьИсключение "Ошибка парсинга YAML: незакрытая скобка в структуре Flow style";
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Функция для парсинга массивов Flow style [value1, value2, ...]
//
// Параметры:
//   ЗначениеСтрока - Строка - строка, содержащая flow style массив
//
// Возвращаемое значение:
//   Массив - распарсенный массив значений
//
// Функция для парсинга массивов Flow style [value1, value2, ...]
//
// Параметры:
//   ЗначениеСтрока - Строка - строка, содержащая flow style массив
//
// Возвращаемое значение:
//   Массив - распарсенный массив значений
//
Функция ПарсингFlowStyleМассив(ЗначениеСтрока)
	// Удаляем квадратные скобки
	СодержимоеМассива = Сред(ЗначениеСтрока, 2, СтрДлина(ЗначениеСтрока) - 2);
	
	Если ПустаяСтрока(СокрЛП(СодержимоеМассива)) Тогда
		Возврат Новый Массив; // Пустой массив
	КонецЕсли;
	
	Элементы = РазделитьЭлементыНаВерхнемУровне(СодержимоеМассива, ",");
	МассивРезультат = Новый Массив;
	
	Для Каждого Элемент Из Элементы Цикл
		ЗначениеЭлемента = СокрЛП(Элемент);
		ЗначениеЭлемента = УдалитьКомментарии(ЗначениеЭлемента);
		
		Если НЕ ПустаяСтрока(ЗначениеЭлемента) Тогда
			ЗначениеДляДобавления = ОбработатьЭлементFlowStyleМассива(ЗначениеЭлемента);
			МассивРезультат.Добавить(ЗначениеДляДобавления);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивРезультат;
КонецФункции

// Обработка элемента Flow style массива
//
// Параметры:
//   ЗначениеЭлемента - Строка - элемент массива
//
// Возвращаемое значение:
//   Произвольный - обработанное значение
//
Функция ОбработатьЭлементFlowStyleМассива(ЗначениеЭлемента)
	// Проверяем на null
	Если НРег(ЗначениеЭлемента) = "null" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Проверяем, является ли элемент вложенной структурой
	Если ЭтоFlowStyleСтруктура(ЗначениеЭлемента) Тогда
		Возврат ПарсингFlowStyle(ЗначениеЭлемента);
	Иначе
		Возврат ПреобразоватьЗначение(ЗначениеЭлемента);
	КонецЕсли;
КонецФункции

// Проверка, является ли строка Flow style структурой
//
// Параметры:
//   ЗначениеСтрока - Строка - строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если это Flow style структура
//
Функция ЭтоFlowStyleСтруктура(ЗначениеСтрока)
	Возврат (Лев(ЗначениеСтрока, 1) = "[" И Прав(ЗначениеСтрока, 1) = "]") 
		ИЛИ (Лев(ЗначениеСтрока, 1) = "{" И Прав(ЗначениеСтрока, 1) = "}");
КонецФункции

// Функция для парсинга объектов Flow style {key1: value1, key2: value2, ...}
//
// Параметры:
//   ЗначениеСтрока - Строка - строка, содержащая flow style объект
//
// Возвращаемое значение:
//   Соответствие - распарсенный объект с ключами и значениями
//
Функция ПарсингFlowStyleОбъект(ЗначениеСтрока)
	// Удаляем фигурные скобки
	СодержимоеОбъекта = Сред(ЗначениеСтрока, 2, СтрДлина(ЗначениеСтрока) - 2);
	
	Если ПустаяСтрока(СокрЛП(СодержимоеОбъекта)) тогда
		Возврат Новый Соответствие; // Пустой объект
	КонецЕсли;
	
	Пары = РазделитьЭлементыНаВерхнемУровне(СодержимоеОбъекта, ",");
	ОбъектРезультат = Новый Соответствие;
	
	Для Каждого Пара Из Пары Цикл
		ОбработатьПаруКлючЗначениеFlowStyle(Пара, ОбъектРезультат);
	КонецЦикла;
	
	Возврат ОбъектРезультат;
КонецФункции

// Обработка пары ключ-значение в Flow style объекте
//
// Параметры:
//   Пара - Строка - строка с парой ключ-значение
//   ОбъектРезультат - Соответствие - объект для добавления пары
//
Процедура ОбработатьПаруКлючЗначениеFlowStyle(Пара, ОбъектРезультат)
	ЗначениеПары = СокрЛП(Пара);
	ЗначениеПары = УдалитьКомментарии(ЗначениеПары);
	
	Если ПустаяСтрока(ЗначениеПары) Тогда
		Возврат;
	КонецЕсли;
	
	ПозицияДвоеточия = Найти(ЗначениеПары, ":");
	Если ПозицияДвоеточия = 0 Тогда
		Возврат; // Некорректная пара
	КонецЕсли;
	
	Ключ = СокрЛП(Лев(ЗначениеПары, ПозицияДвоеточия - 1));
	ЗначениеКлюча = СокрЛП(Сред(ЗначениеПары, ПозицияДвоеточия + 1));
	
	// Убираем кавычки из ключа, если они есть
	Если ЭтоСтрокаВКавычках(Ключ) Тогда
		Ключ = Сред(Ключ, 2, СтрДлина(Ключ) - 2);
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ЗначениеКлюча) Тогда
		// Проверяем, является ли значение вложенной структурой
		ВложеннаяСтруктура = ПарсингFlowStyle(ЗначениеКлюча);
		Если ВложеннаяСтруктура <> Неопределено Тогда
			ОбъектРезультат.Вставить(Ключ, ВложеннаяСтруктура);
		Иначе
			ОбъектРезультат.Вставить(Ключ, ПреобразоватьЗначение(ЗначениеКлюча));
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Функция для разделения элементов на верхнем уровне структуры, учитывая вложенность
// 
// Параметры:
//   Строка - Строка - строка для разделения
//   Разделитель - Строка - символ-разделитель элементов
//
// Возвращаемое значение:
//   Массив - массив разделенных элементов
//
Функция РазделитьЭлементыНаВерхнемУровне(Строка, Разделитель)
	Результат = Новый Массив;
	Буфер = "";
	УровеньКвадратныхСкобок = 0;
	УровеньФигурныхСкобок = 0;
	УровеньДвойныхКавычек = 0;
	УровеньОдинарныхКавычек = 0;
	
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Позиция, 1);
		
		// Учитываем кавычки и скобки для определения уровня вложенности
		Если Символ = "[" Тогда
			УровеньКвадратныхСкобок = УровеньКвадратныхСкобок + 1;
			Буфер = Буфер + Символ;
		ИначеЕсли Символ = "]" Тогда
			УровеньКвадратныхСкобок = УровеньКвадратныхСкобок - 1;
			// Проверка на непарные скобки
			Если УровеньКвадратныхСкобок < 0 Тогда
				ВызватьИсключение "Ошибка парсинга: непарная закрывающая квадратная скобка";
			КонецЕсли;
			Буфер = Буфер + Символ;
		ИначеЕсли Символ = "{" Тогда
			УровеньФигурныхСкобок = УровеньФигурныхСкобок + 1;
			Буфер = Буфер + Символ;
		ИначеЕсли Символ = "}" Тогда
			УровеньФигурныхСкобок = УровеньФигурныхСкобок - 1;
			// Проверка на непарные скобки
			Если УровеньФигурныхСкобок < 0 Тогда
				ВызватьИсключение "Ошибка парсинга: непарная закрывающая фигурная скобка";
			КонецЕсли;
			Буфер = Буфер + Символ;
		ИначеЕсли Символ = """" И УровеньОдинарныхКавычек = 0 Тогда
			// Учитываем кавычки, только если не находимся внутри одинарных кавычек
			УровеньДвойныхКавычек = 1 - УровеньДвойныхКавычек; // Переключаем 0/1
			Буфер = Буфер + Символ;
		ИначеЕсли Символ = "'" И УровеньДвойныхКавычек = 0 Тогда
			// Учитываем одинарные кавычки, только если не находимся внутри двойных кавычек
			УровеньОдинарныхКавычек = 1 - УровеньОдинарныхКавычек; // Переключаем 0/1
			Буфер = Буфер + Символ;
		ИначеЕсли Символ = Разделитель И УровеньКвадратныхСкобок = 0 И УровеньФигурныхСкобок = 0 
			И УровеньДвойныхКавычек = 0 И УровеньОдинарныхКавычек = 0 Тогда
			// Нашли разделитель на верхнем уровне
			Результат.Добавить(Буфер);
			Буфер = "";
		Иначе
			Буфер = Буфер + Символ;
		КонецЕсли;
	КонецЦикла;
	
	// Проверяем, остались ли незакрытые скобки или кавычки
	Если УровеньКвадратныхСкобок > 0 Тогда
		ВызватьИсключение "Ошибка парсинга: незакрытая квадратная скобка";
	КонецЕсли;
	
	Если УровеньФигурныхСкобок > 0 Тогда
		ВызватьИсключение "Ошибка парсинга: незакрытая фигурная скобка";
	КонецЕсли;
	
	Если УровеньДвойныхКавычек > 0 Тогда
		ВызватьИсключение "Ошибка парсинга: незакрытая двойная кавычка";
	КонецЕсли;
	
	Если УровеньОдинарныхКавычек > 0 Тогда
		ВызватьИсключение "Ошибка парсинга: незакрытая одинарная кавычка";
	КонецЕсли;
	
	// Добавляем последний элемент
	Если НЕ ПустаяСтрока(Буфер) Тогда
		Результат.Добавить(Буфер);
	КонецЕсли;
	
	Возврат Результат;
КонецФункции