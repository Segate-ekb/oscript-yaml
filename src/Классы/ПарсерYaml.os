#Использовать "../internal"

Процедура ПриСозданииОбъекта() Экспорт
	
	// Инициализация структур данных
	МенеджерЯкорей.Инициализировать();
КонецПроцедуры

// Основная функция для чтения YAML-строки
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для парсинга
//
// Возвращаемое значение:
//   Произвольный - распарсенная структура данных или скалярное значение
//
Функция ПрочитатьYaml(СтрокаYaml = "") Экспорт
	
	// Валидация входных данных
	Если НЕ ЗначениеЗаполнено(СтрокаYaml) Тогда
		Возврат Новый Соответствие;
	КонецЕсли;
	
	// Проверим, содержит ли строка YAML только скалярное значение
	СтрокаБезПробелов = СокрЛП(СтрокаYaml);
	Если ЭтоСкалярноеЗначение(СтрокаБезПробелов) Тогда
		// Для скалярных значений, возвращаем напрямую преобразованное значение
		Возврат ПреобразовательЗначений.ПреобразоватьЗначение(СтрокаБезПробелов);
	КонецЕсли;
	
	// Проверка на массив верхнего уровня
	Если ЭтоМассивВерхнегоУровня(СтрокаYaml) Тогда
		Возврат ПреобразоватьМассивВерхнегоУровня(СтрокаYaml);
	КонецЕсли;
	
	// Проверка на flow style структуру верхнего уровня (JSON)
	Если ЭтоFlowStyleВерхнегоУровня(СтрокаYaml) Тогда
		Возврат ПреобразоватьFlowStyleВерхнегоУровня(СтрокаYaml);
	КонецЕсли;
	
	// Подготовка к парсингу для сложных структур
	Возврат ВыполнитьОсновнойПарсинг(СтрокаYaml);
КонецФункции

// Проверяет, является ли YAML-строка скалярным значением
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если строка содержит только скалярное значение
//
Функция ЭтоСкалярноеЗначение(СтрокаYaml)
	Возврат СтрДлина(СтрокаYaml) > 0
	И НЕ СтрНайти(СтрокаYaml, ":") > 0
	И НЕ Лев(СтрокаYaml, 1) = "-"
		И НЕ Лев(СтрокаYaml, 1) = "[";
КонецФункции

// Проверяет, является ли YAML-строка массивом верхнего уровня
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если строка содержит массив верхнего уровня
//
Функция ЭтоМассивВерхнегоУровня(СтрокаYaml)
	СтрокаБезПробелов = СокрЛП(СтрокаYaml);
	
	// Проверяем flow-style массив (в квадратных скобках)
	Если СтрНачинаетсяС(СтрокаБезПробелов, "[") И СтрЗаканчиваетсяНа(СтрокаБезПробелов, "]") Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Проверяем block-style массив (строки, начинающиеся с "- ")
	Строки = СтрРазделить(СтрокаYaml, Символы.ПС, Ложь);
	Для Каждого СтрокаЭлемент Из Строки Цикл
		ОчищеннаяСтрока = СокрЛП(СтрокаЭлемент);
		Если ПустаяСтрока(ОчищеннаяСтрока) ИЛИ СтрНачинаетсяС(ОчищеннаяСтрока, "#") Тогда
			Продолжить;
		КонецЕсли;
		
		Если НЕ СтрНачинаетсяС(ОчищеннаяСтрока, "- ") И НЕ ОчищеннаяСтрока = "-" Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Строки.Количество() > 0;
КонецФункции

// Преобразует YAML-строку, содержащую массив верхнего уровня, в массив значений
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для преобразования
//
// Возвращаемое значение:
//   Массив - массив преобразованных значений
//
Функция ПреобразоватьМассивВерхнегоУровня(СтрокаYaml)
	СтрокаБезПробелов = СокрЛП(СтрокаYaml);
	
	// Если это flow-style массив, используем парсер потокового стиля
	Если СтрНачинаетсяС(СтрокаБезПробелов, "[") И СтрЗаканчиваетсяНа(СтрокаБезПробелов, "]") Тогда
		Возврат ПарсерПотоковыйСтиль.ПарсингFlowStyleМассив(СтрокаБезПробелов);
	КонецЕсли;
	
	// Иначе это block-style массив
	МассивРезультат = Новый Массив;
	Строки = СтрРазделить(СтрокаYaml, Символы.ПС, Ложь);
	
	Для Каждого СтрокаЭлемент Из Строки Цикл
		ОчищеннаяСтрока = СокрЛП(СтрокаЭлемент);
		Если ПустаяСтрока(ОчищеннаяСтрока) ИЛИ СтрНачинаетсяС(ОчищеннаяСтрока, "#") Тогда
			Продолжить;
		КонецЕсли;
		
		ЗначениеЭлемента = СокрЛП(Сред(ОчищеннаяСтрока, 2));
		МассивРезультат.Добавить(ПреобразовательЗначений.ПреобразоватьЗначение(ЗначениеЭлемента));
	КонецЦикла;
	
	Возврат МассивРезультат;
КонецФункции

// Выполняет основной парсинг YAML для сложных структур
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для парсинга
//
// Возвращаемое значение:
//   Соответствие - распарсенная структура данных
//
Функция ВыполнитьОсновнойПарсинг(СтрокаYaml)
	// Подготовка к парсингу
	ИнициализироватьПарсер();
	
	// Разбиваем строку на массив строк для основного парсинга
	Строки = СтрРазделить(СтрокаYaml, Символы.ПС);
	
	// Инициализация структур данных для парсинга
	Результат = Новый Соответствие;
	СтекКонтекстов = Новый Массив;
	СтекКонтекстов.Добавить(Результат);
	
	// Основной цикл парсинга
	Индекс = 0;
	Пока Индекс <= Строки.ВГраница() Цикл
		КоличествоПропущенныхСтрок = ОбработатьСтрокуYAML(Строки, Индекс, СтекКонтекстов);
		Индекс = Индекс + КоличествоПропущенныхСтрок;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Инициализация парсера перед началом работы
Процедура ИнициализироватьПарсер()
	МенеджерЯкорей.Очистить();
	ПарсерУровней.ИнициализироватьПарсерУровней();
	ПарсерУровней.ОчиститьСловарьОтступов();
КонецПроцедуры

// Обработка одной строки YAML
//
// Параметры:
//   Строки - Массив - массив всех строк YAML
//   Индекс - Число - индекс текущей строки
//   СтекКонтекстов - Массив - стек контекстов парсинга
//
// Возвращаемое значение:
//   Число - количество обработанных строк (обычно 1, но может быть больше для многострочных структур)
//
Функция ОбработатьСтрокуYAML(Строки, Индекс, СтекКонтекстов)
	Строка = Строки[Индекс];
	
	// Пропускаем пустые строки и комментарии
	Если ПарсерУровней.ЭтоПустаяСтрокаИлиКомментарий(Строка) Тогда
		Возврат 1;
	КонецЕсли;
	
	// Валидируем отступ
	РезультатВалидации = ПарсерУровней.ВалидироватьОтступ(Строка);
	Если НЕ РезультатВалидации.Корректный Тогда
		ВызватьИсключение СтрШаблон("Ошибка парсинга YAML на строке %1: %2", Индекс + 1, РезультатВалидации.ОписаниеОшибки);
	КонецЕсли;
	
	УровеньОтступа = РезультатВалидации.УровеньОтступа;
	
	// Обновляем стек контекстов при изменении уровня
	ПарсерУровней.ОбновитьСтекКонтекстов(СтекКонтекстов, УровеньОтступа);
	
	// Получаем текущий контекст и очищенную строку
	ТекущийКонтекст = СтекКонтекстов[СтекКонтекстов.ВГраница()];
	ОчищеннаяСтрока = СокрЛП(Строка);
	
	// Определяем тип элемента и обрабатываем его
	Если ПарсерУровней.ЭтоЭлементМассива(ОчищеннаяСтрока) Тогда
		ПарсерМассивов.ОбработатьЭлементМассива(ОчищеннаяСтрока, ТекущийКонтекст, СтекКонтекстов, МенеджерЯкорей);
		Возврат 1;
	Иначе
		Возврат ОбработатьКлючЗначение(ОчищеннаяСтрока, ТекущийКонтекст, СтекКонтекстов, Строки, Индекс);
	КонецЕсли;
КонецФункции

// Обработка пары ключ-значение
//
// Параметры:
//   ОчищеннаяСтрока - Строка - очищенная строка с парой ключ-значение
//   ТекущийКонтекст - Соответствие - текущий контекст парсинга
//   СтекКонтекстов - Массив - стек контекстов
//   Строки - Массив - массив всех строк
//   Индекс - Число - текущий индекс строки
//
// Возвращаемое значение:
//   Число - количество обработанных строк
//
Функция ОбработатьКлючЗначение(ОчищеннаяСтрока, ТекущийКонтекст, СтекКонтекстов, Строки, Индекс)
	// Проверяем, является ли это YAML merge
	Если ПарсерКлючЗначение.ЭтоYAMLMerge(ОчищеннаяСтрока) Тогда
		ПарсерКлючЗначение.ОбработатьYAMLMerge(ОчищеннаяСтрока, ТекущийКонтекст, МенеджерЯкорей);
		Возврат 1;
	КонецЕсли;
	
	// Разбираем строку на ключ и значение
	РезультатРазбора = ПарсерКлючЗначение.РазобратьКлючЗначение(ОчищеннаяСтрока);
	Если РезультатРазбора = Неопределено Тогда
		Возврат 1; // Некорректная строка
	КонецЕсли;
	
	// Проверяем, что текущий контекст - соответствие
	Если ТипЗнч(ТекущийКонтекст) <> Тип("Соответствие") Тогда
		Возврат 1;
	КонецЕсли;
	
	// Обрабатываем якоря и алиасы
	РезультатОбработкиЯкоря = МенеджерЯкорей.ОбработатьЯкорьИАлиас(РезультатРазбора.Значение, РезультатРазбора.Ключ, ТекущийКонтекст);
	Если РезультатОбработкиЯкоря.АлиасОбработан Тогда
		Возврат 1;
	КонецЕсли;
	
	// Определяем тип значения и обрабатываем соответственно
	Возврат ОбработатьЗначениеКлюча(
		РезультатРазбора.Ключ,
		РезультатОбработкиЯкоря.Якорь,
		РезультатОбработкиЯкоря.ЗначениеСтрока,
		ТекущийКонтекст,
		СтекКонтекстов,
		Строки,
		Индекс
	);
КонецФункции



// Обработка значения ключа
//
// Параметры:
//   Ключ - Строка - ключ
//   Якорь - Строка - якорь (если есть)
//   ЗначениеСтрока - Строка - значение
//   ТекущийКонтекст - Соответствие - текущий контекст
//   СтекКонтекстов - Массив - стек контекстов
//   Строки - Массив - массив строк
//   Индекс - Число - индекс строки
//
// Возвращаемое значение:
//   Число - количество обработанных строк
//
Функция ОбработатьЗначениеКлюча(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст, СтекКонтекстов, Строки, Индекс)
	Если ПустаяСтрока(ЗначениеСтрока) Тогда
		СоздатьВложеннуюСтруктуру(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов, Строки, Индекс);
		Возврат 1;
	ИначеЕсли ПарсерМногострочныхЛитералов.ЭтоМногострочныйЛитерал(ЗначениеСтрока) Тогда
		ОбработатьМногострочныйЛитерал(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст, Строки, Индекс);
		Возврат 1;
	ИначеЕсли ПарсерПотоковыйСтиль.ЭтоНачалоМногострочнойFlowСтруктуры(ЗначениеСтрока) И ЕстьСледующиеСтроки(Строки, Индекс) Тогда
		Возврат ОбработатьМногострочнуюFlowСтруктуру(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст, Строки, Индекс);
	Иначе
		СоздатьПростоеЗначение(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст);
		Возврат 1;
	КонецЕсли;
КонецФункции

// Преобразует строковое значение YAML в соответствующий тип 1С
//
// Параметры:
//   ЗначениеСтрока - Строка - значение для преобразования
//
// Возвращаемое значение:
//   Произвольный - значение, преобразованное в соответствующий тип
//
Функция ПреобразоватьЗначение(ЗначениеСтрока)
	ЗначениеСтрока = СокрЛП(ЗначениеСтрока);
	
	// Обработка алиасов на уровне значения
	Если Лев(ЗначениеСтрока, 1) = "*" Тогда
		Возврат МенеджерЯкорей.ПреобразоватьАлиас(ЗначениеСтрока);
	КонецЕсли;
	
	// Обработка flow style массивов и объектов
	ВложеннаяСтруктура = ПарсерПотоковыйСтиль.ПарсингFlowStyle(ЗначениеСтрока);
	Если ВложеннаяСтруктура <> Неопределено Тогда
		Возврат ВложеннаяСтруктура;
	КонецЕсли;
	
	// Остальное преобразование делегируем модулю
	Возврат ПреобразовательЗначений.ПреобразоватьЗначение(ЗначениеСтрока);
КонецФункции

Процедура СоздатьВложеннуюСтруктуру(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов, Строки, Индекс)
	УровеньОтступа = ПарсерУровней.ПолучитьУровеньОтступа(Строки[Индекс]);
	
	Если Индекс < Строки.ВГраница() Тогда
		СледующаяСтрока = СокрЛП(Строки[Индекс + 1]);
		Если НЕ ПустаяСтрока(СледующаяСтрока) И ПарсерУровней.ПолучитьУровеньОтступа(Строки[Индекс + 1]) > УровеньОтступа Тогда
			Если Лев(СледующаяСтрока, 1) = "-" Тогда
				СоздатьМассив(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов);
			Иначе
				СоздатьСоответствие(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

Процедура СоздатьМассив(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов)
	НовыйМассив = Новый Массив;
	
	ТекущийКонтекст.Вставить(Ключ, НовыйМассив);
	СтекКонтекстов.Добавить(НовыйМассив);
	
	// Если есть якорь, сохраняем его
	МенеджерЯкорей.СохранитьЯкорь(Якорь, НовыйМассив);
КонецПроцедуры

Процедура СоздатьСоответствие(Ключ, Якорь, ТекущийКонтекст, СтекКонтекстов)
	НовоеСоответствие = Новый Соответствие;
	
	// Если есть якорь, сохраняем его
	Если Якорь <> "" Тогда
		МенеджерЯкорей.СохранитьЯкорь(Якорь, НовоеСоответствие);
		// Проверяем, является ли это ключом, который определяет только якорь
		Если МенеджерЯкорей.ЭтоТолькоОпределениеЯкоря(Ключ) Тогда
			// НЕ добавляем в результат, но добавляем в стек для вложенных элементов
			СтекКонтекстов.Добавить(НовоеСоответствие);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ТекущийКонтекст.Вставить(Ключ, НовоеСоответствие);
	СтекКонтекстов.Добавить(НовоеСоответствие);
КонецПроцедуры

Процедура СоздатьПростоеЗначение(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст)
	Значение = ПреобразоватьЗначение(ЗначениеСтрока);
	
	МенеджерЯкорей.УстановитьЗначениеСЯкорем(Ключ, Якорь, Значение, ТекущийКонтекст);
КонецПроцедуры

// Обработка многострочного литерала
//
// Параметры:
//   Ключ - Строка - ключ для значения
//   Якорь - Строка - якорь (если есть)
//   ЗначениеСтрока - Строка - индикатор типа литерала (| или >)
//   ТекущийКонтекст - Соответствие - текущий контекст
//   Строки - Массив - массив всех строк
//   Индекс - Число - индекс текущей строки
//
Процедура ОбработатьМногострочныйЛитерал(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст, Строки, Индекс)
	ТипЛитерала = СокрЛП(ЗначениеСтрока);
	ТекущийУровеньОтступа = ПарсерУровней.ПолучитьУровеньОтступа(Строки[Индекс]);
	
	МногострочноеЗначение = ПарсерМногострочныхЛитералов.СчитатьМногострочныйБлок(Строки, Индекс, ТекущийУровеньОтступа, ТипЛитерала);
	УстановитьЗначениеСЯкорем(Ключ, Якорь, МногострочноеЗначение, ТекущийКонтекст);
КонецПроцедуры

// Обработка многострочной flow структуры
//
// Параметры:
//   Ключ - Строка - ключ для значения
//   Якорь - Строка - якорь (если есть)
//   ЗначениеСтрока - Строка - начало flow структуры
//   ТекущийКонтекст - Соответствие - текущий контекст
//   Строки - Массив - массив всех строк
//   Индекс - Число - индекс текущей строки
//
// Возвращаемое значение:
//   Число - количество обработанных строк
//
Функция ОбработатьМногострочнуюFlowСтруктуру(Ключ, Якорь, ЗначениеСтрока, ТекущийКонтекст, Строки, Индекс)
	ТекущийУровеньОтступа = ПарсерУровней.ПолучитьУровеньОтступа(Строки[Индекс]);
	
	// Собираем многострочную flow структуру в одну строку
	// Проверяем, что это действительно начало flow структуры
	Если НЕ ПарсерПотоковыйСтиль.ЭтоНачалоМногострочнойFlowСтруктуры(ЗначениеСтрока) Тогда
		ВызватьИсключение "Некорректный вызов обработки многострочной flow структуры";
	КонецЕсли;
	
	// Создаем новый массив строк, где первая строка содержит только значение
	МодифицированныеСтроки = Новый Массив;
	Для Инд = 0 По Строки.ВГраница() Цикл
		Если Инд = Индекс Тогда
			МодифицированныеСтроки.Добавить(ЗначениеСтрока); // Только значение без ключа
		Иначе
			МодифицированныеСтроки.Добавить(Строки[Инд]);
		КонецЕсли;
	КонецЦикла;
	
	РезультатСбора = ПарсерПотоковыйСтиль.СобратьМногострочнуюFlowСтруктуру(МодифицированныеСтроки, Индекс, ТекущийУровеньОтступа);
	
	// Парсим собранную строку как обычную flow структуру
	Значение = ПреобразоватьЗначение(РезультатСбора.Строка);
	
	МенеджерЯкорей.УстановитьЗначениеСЯкорем(Ключ, Якорь, Значение, ТекущийКонтекст);
	
	Возврат РезультатСбора.КоличествоОбработанныхСтрок;
КонецФункции

Процедура УстановитьЗначениеСЯкорем(Ключ, Якорь, МногострочноеЗначение, ТекущийКонтекст)
	МенеджерЯкорей.УстановитьЗначениеСЯкорем(Ключ, Якорь, МногострочноеЗначение, ТекущийКонтекст);
КонецПроцедуры

// Проверяет, есть ли следующие строки для обработки многострочной flow структуры
//
// Параметры:
//   Строки - Массив - массив всех строк
//   Индекс - Число - текущий индекс строки
//
// Возвращаемое значение:
//   Булево - Истина, если есть следующие строки
//
Функция ЕстьСледующиеСтроки(Строки, Индекс)
	Возврат Индекс < Строки.ВГраница();
КонецФункции

// Проверяет, является ли YAML-строка flow style структурой верхнего уровня (JSON)
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если строка содержит flow style структуру верхнего уровня
//
Функция ЭтоFlowStyleВерхнегоУровня(СтрокаYaml)
	СтрокаБезПробелов = СокрЛП(СтрокаYaml);
	
	// Проверяем, начинается ли весь YAML с { или [ и заканчивается соответствующими скобками
	Если СтрНачинаетсяС(СтрокаБезПробелов, "{") И СтрЗаканчиваетсяНа(СтрокаБезПробелов, "}") Тогда
		Возврат Истина;
	ИначеЕсли СтрНачинаетсяС(СтрокаБезПробелов, "[") И СтрЗаканчиваетсяНа(СтрокаБезПробелов, "]") Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

// Преобразует YAML-строку, содержащую flow style структуру верхнего уровня
//
// Параметры:
//   СтрокаYaml - Строка - YAML-строка для преобразования
//
// Возвращаемое значение:
//   Произвольный - преобразованная структура данных
//
Функция ПреобразоватьFlowStyleВерхнегоУровня(СтрокаYaml)
	// Убираем все переносы строк и лишние пробелы, объединяя в одну строку
	ОднострочныйYaml = СтрЗаменить(СтрокаYaml, Символы.ПС, " ");
	ОднострочныйYaml = СтрЗаменить(ОднострочныйYaml, Символы.ВТаб, " ");
	
	// Убираем множественные пробелы
	Пока СтрНайти(ОднострочныйYaml, "  ") > 0 Цикл
		ОднострочныйYaml = СтрЗаменить(ОднострочныйYaml, "  ", " ");
	КонецЦикла;
	
	ОднострочныйYaml = СокрЛП(ОднострочныйYaml);
	
	// Используем стандартный парсер flow style
	Возврат ПарсерПотоковыйСтиль.ПарсингFlowStyle(ОднострочныйYaml);
КонецФункции